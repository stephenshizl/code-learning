commit 1c991e6e15e476bde64850ccf30fea194ba94f6f
Author: stephen <shizl@youyoutech.net>
Date:   Thu Nov 3 22:41:49 2022 +0800

     for  pad 4g

diff --git a/device/sprd/roc1/ud710_2h10/youyou/device.mk b/device/sprd/roc1/ud710_2h10/youyou/device.mk
old mode 100644
new mode 100755
index b94d217..ff1e57b
--- a/device/sprd/roc1/ud710_2h10/youyou/device.mk
+++ b/device/sprd/roc1/ud710_2h10/youyou/device.mk
@@ -9,29 +9,46 @@ persist.sys.country=CN \
 persist.sys.timezone=Asia/Shanghai \
 persist.sys.locale=zh-Hans-CN \
 ro.product.locale.language=zh \
-ro.product.locale.region=CN
+ro.product.locale.region=CN \
+persist.vendor.radio.phone_count=1 \
+persist.radio.multisim.config=ssss
 
 SIM_COUNT := 1
 PRODUCT_PROPERTY_OVERRIDES := \
-        ro.telephony.default_network=22 \
+        ril.fibocom.dialmode=1 \
+        ril.fibocom.NetifName=eth0 \
+        ro.telephony.default_network=9 \
         persist.vendor.radio.phone_count=1 \
         persist.radio.multisim.config=ssss \
         $(PRODUCT_PROPERTY_OVERRIDES)
 
 PRODUCT_PACKAGES += \
+    android.hardware.wifi@1.0-service \
     tinycap \
     tinyplay \
     tinyhostless \
     tinypcminfo \
-    libreference-ril \
     libril_static \
+    libril \
+    libreference-ril \
     librilutils \
     librilutils_static \
     sap-api-java-static \
-    rild
+    rild \
+    dhcpcd
 
 SUPPORT_LOCATION_GNSS := disabled
 SUPPORT_LOCATION := disabled
 PRODUCT_SUPPORT_WCN  := false
 SUPPORT_LOCATION_GNSS := disabled
 SUPPORT_GNSS_HARDWARE := false
+
+
+PRODUCT_PROPERTY_OVERRIDES += \
+    rild.libpath=/vendor/lib64/libreference-ril.so \
+    vendor.rild.libpath=/vendor/lib64/libreference-ril.so
+
+#$(LOCAL_PATH)/youyou/libreference-ril.so:$(TARGET_COPY_OUT_VENDOR)/lib64/libreference-ril.so 
+PRODUCT_COPY_FILES += \
+    frameworks/native/data/etc/android.hardware.wifi.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.wifi.xml \
+    $(LOCAL_PATH)/youyou/dhcpcd:$(TARGET_COPY_OUT_VENDOR)/bin/dhcpcd
diff --git a/device/sprd/roc1/ud710_2h10/youyou/dhcpcd b/device/sprd/roc1/ud710_2h10/youyou/dhcpcd
new file mode 100755
index 0000000..6dbe03a
Binary files /dev/null and b/device/sprd/roc1/ud710_2h10/youyou/dhcpcd differ
diff --git a/device/sprd/roc1/ud710_2h10/youyou/libreference-ril.so b/device/sprd/roc1/ud710_2h10/youyou/libreference-ril.so
new file mode 100755
index 0000000..afd0097
Binary files /dev/null and b/device/sprd/roc1/ud710_2h10/youyou/libreference-ril.so differ
diff --git a/frameworks/base/packages/SystemUI/res/values/config.xml b/frameworks/base/packages/SystemUI/res/values/config.xml
old mode 100644
new mode 100755
index a68ba9b..bfdef09
--- a/frameworks/base/packages/SystemUI/res/values/config.xml
+++ b/frameworks/base/packages/SystemUI/res/values/config.xml
@@ -118,12 +118,12 @@
 
     <!-- The default tiles to display in QuickSettings -->
     <string name="quick_settings_tiles_default" translatable="false">
-        wifi,bt,dnd,flashlight,rotation,battery,cell,airplane,cast
+        dnd,lte,lte2,flashlight,rotation,battery,cell,airplane,cast
     </string>
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        wifi,cell,battery,dnd,flashlight,rotation,bt,airplane,location,hotspot,inversion,saver,work,cast,night
+        cell,battery,dnd,lte,lte2,flashlight,rotation,bt,airplane,hotspot,inversion,saver,work,cast,night,longscreenshot
     </string>
 
     <!-- The tiles to display in QuickSettings -->
@@ -131,7 +131,7 @@
 
     <!-- The tiles to display in QuickSettings in retail mode -->
     <string name="quick_settings_tiles_retail_mode" translatable="false">
-        cell,battery,dnd,flashlight,rotation,location
+        cell,lte,lte2,battery,dnd,flashlight,rotation
     </string>
 
     <!-- Whether or not the RSSI tile is capitalized or not. -->
@@ -396,8 +396,9 @@
     <!-- Whether or the notifications can be shown and dismissed with a drag. -->
     <bool name="config_enableNotificationShadeDrag">true</bool>
 
-    <!-- Whether to show activity indicators in the status bar -->
-    <bool name="config_showActivity">false</bool>
+    <!-- Whether to show activity indicators in the status bar
+         UNISOC: add feature statusbar signal cluster view.-->
+    <bool name="config_showActivity">true</bool>
 
     <!-- Whether or not the button to clear all notifications will be shown. -->
     <bool name="config_enableNotificationsClearAll">true</bool>
diff --git a/frameworks/opt/net/wifi/libwifi_hal/Android.mk b/frameworks/opt/net/wifi/libwifi_hal/Android.mk
old mode 100644
new mode 100755
index 8d000d3..58e81ff
--- a/frameworks/opt/net/wifi/libwifi_hal/Android.mk
+++ b/frameworks/opt/net/wifi/libwifi_hal/Android.mk
@@ -101,9 +101,6 @@ else ifeq ($(BOARD_WLAN_DEVICE), MediaTek)
   LIB_WIFI_HAL := libwifi-hal-mt66xx
 else ifeq ($(BOARD_WLAN_DEVICE), emulator)
   LIB_WIFI_HAL := libwifi-hal-emu
-else ifeq ($(PRODUCT_WIFI_DEVICE), sprd)
-  LIB_WIFI_HAL := libwifi-hal-sprd
-  VENDOR_LOCAL_SHARED_LIBRARIES := libcld80211
 endif
 
 # The WiFi HAL that you should be linking.
diff --git a/hardware/ril/include/telephony/ril.h b/hardware/ril/include/telephony/ril.h
old mode 100644
new mode 100755
index 9b93498..2f0900c
--- a/hardware/ril/include/telephony/ril.h
+++ b/hardware/ril/include/telephony/ril.h
@@ -111,6 +111,7 @@ extern "C" {
 #define MAX_BANDS 8
 #define MAX_CHANNELS 32
 #define MAX_RADIO_ACCESS_NETWORKS 8
+#define MAX_BROADCAST_SMS_CONFIG_INFO 25
 
 
 typedef void * RIL_Token;
@@ -373,7 +374,8 @@ typedef enum {
     RADIO_TECH_GSM = 16, // Only supports voice
     RADIO_TECH_TD_SCDMA = 17,
     RADIO_TECH_IWLAN = 18,
-    RADIO_TECH_LTE_CA = 19
+    RADIO_TECH_LTE_CA = 19,
+    RADIO_TECH_LTE_NR = 20
 } RIL_RadioTechnology;
 
 typedef enum {
@@ -395,7 +397,8 @@ typedef enum {
     RAF_HSPAP = (1 << RADIO_TECH_HSPAP),
     RAF_GSM = (1 << RADIO_TECH_GSM),
     RAF_TD_SCDMA = (1 << RADIO_TECH_TD_SCDMA),
-    RAF_LTE_CA = (1 << RADIO_TECH_LTE_CA)
+    RAF_LTE_CA = (1 << RADIO_TECH_LTE_CA),
+    RAF_NR_LTE= (1 << RADIO_TECH_LTE_NR)
 } RIL_RadioAccessFamily;
 
 typedef enum {
@@ -494,7 +497,17 @@ typedef enum {
     PREF_NET_TYPE_TD_SCDMA_GSM_WCDMA_LTE   = 20, /* TD-SCDMA, GSM/WCDMA and LTE */
     PREF_NET_TYPE_TD_SCDMA_GSM_WCDMA_CDMA_EVDO_AUTO  = 21, /* TD-SCDMA, GSM/WCDMA, CDMA and EvDo */
     PREF_NET_TYPE_TD_SCDMA_LTE_CDMA_EVDO_GSM_WCDMA   = 22,  /* TD-SCDMA, LTE, CDMA, EvDo GSM/WCDMA */
-	
+	 PREF_NET_TYPE_NR_ONLY                            = 23, /* NR 5G only */
+    PREF_NET_TYPE_NR_LTE                             = 24, /* NR 5G, LTE */
+    PREF_NET_TYPE_NR_LTE_CDMA_EVDO                   = 25, /* NR 5G, LTE, GSM and WCDMA */
+    PREF_NET_TYPE_NR_LTE_GSM_WCDMA                   = 26,  /* NR 5G, LTE, GSM and WCDMA */
+    PREF_NET_TYPE_NR_LTE_CDMA_EVDO_GSM_WCDMA         = 27, /* NR 5G, LTE, CDMA, EvDo, GSM and WCDMA */
+    PREF_NET_TYPE_NR_LTE_WCDMA                       = 28, /* NR 5G, LTE and WCDMA */
+    PREF_NET_TYPE_NR_LTE_TDSCDMA                     = 29, /* NR 5G, LTE and TDSCDMA */
+    PREF_NET_TYPE_NR_LTE_TDSCDMA_GSM                 = 30, /* NR 5G, LTE, TD-SCDMA and GSM */
+    PREF_NET_TYPE_NR_LTE_TDSCDMA_WCDMA               = 31, /* NR 5G, LTE, TD-SCDMA, WCDMA */
+    PREF_NET_TYPE_NR_LTE_TDSCDMA_GSM_WCDMA           = 32, /* NR 5G, LTE, TD-SCDMA, GSM and WCDMA */
+    PREF_NET_TYPE_NR_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA = 33,  /* NR 5G, LTE, TD-SCDMA, CDMA, EVDO, GSM and WCDMA */
     PREF_NET_TYPE_4G_3G_2G                 = 101,/* 4G/3G/2G */
     PREF_NET_TYPE_3G_2G                    = 102 /* 3G/2G */
 } RIL_PreferredNetworkType;
diff --git a/hardware/ril/include/telephony/ril_mnc.h b/hardware/ril/include/telephony/ril_mnc.h
new file mode 100755
index 0000000..fcbae99
--- /dev/null
+++ b/hardware/ril/include/telephony/ril_mnc.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef RIL_MNC_H
+#define RIL_MNC_H
+
+#include <climits>
+#include <cstdio>
+#include <string>
+
+namespace ril {
+namespace util {
+namespace mnc {
+
+/**
+ * Decode an MNC with an optional length indicator provided in the most-significant nibble.
+ *
+ * @param mnc an encoded MNC value; if no encoding is provided, then the string is returned
+ *     as a minimum length string representing the provided integer.
+ *
+ * @return string representation of an encoded MNC or an empty string if the MNC is not a valid
+ *     MNC value.
+ */
+static inline std::string decode(int mnc) {
+    if (mnc == INT_MAX || mnc < 0) return "";
+    unsigned umnc = mnc;
+    char mncNumDigits = (umnc >> (sizeof(int) * 8 - 4)) & 0xF;
+
+    umnc = (umnc << 4) >> 4;
+    if (umnc > 999) return "";
+
+    char mncStr[4] = {0};
+    switch (mncNumDigits) {
+        case 0:
+            // Legacy MNC report hasn't set the number of digits; preserve current
+            // behavior and make a string of the minimum number of required digits.
+            return std::to_string(umnc);
+
+        case 2:
+            snprintf(mncStr, sizeof(mncStr), "%03.3u", umnc);
+            return mncStr + 1;
+
+        case 3:
+            snprintf(mncStr, sizeof(mncStr), "%03.3u", umnc);
+            return mncStr;
+
+        default:
+            // Error case
+            return "";
+    }
+
+}
+
+/**
+ * Encode an MNC of the given value and a given number of digits
+ *
+ * @param mnc an MNC value 0-999 or INT_MAX if unknown
+ * @param numDigits the number of MNC digits {2, 3} or 0 if unknown
+ *
+ * @return an encoded MNC with embedded length information
+ */
+static inline int encode(int mnc, int numDigits) {
+    if (mnc > 999 || mnc < 0) return INT_MAX;
+    switch (numDigits) {
+        case 0: // fall through
+        case 2: // fall through
+        case 3:
+            break;
+
+        default:
+            return INT_MAX;
+    };
+
+    return (numDigits << (sizeof(int) * 8 - 4)) | mnc;
+}
+
+/**
+ * Encode an MNC of the given value
+ *
+ * @param mnc the string representation of the MNC, with the length equal to the length of the
+ *     provided string.
+ *
+ * @return an encoded MNC with embedded length information
+ */
+static inline int encode(const std::string & mnc) {
+    return encode(std::stoi(mnc), mnc.length());
+}
+
+// echo -e "#include \"hardware/ril/include/telephony/ril_mnc.h\"\nint main()"\
+// "{ return ril::util::mnc::test(); }" > ril_test.cpp \
+// && g++ -o /tmp/ril_test -DTEST_RIL_MNC ril_test.cpp; \
+// rm ril_test.cpp; /tmp/ril_test && [ $? ] && echo "passed"
+#ifdef TEST_RIL_MNC
+static int test() {
+    const struct mnc_strings { const char * in; const char * out; } mncs[] = {
+        {"0001",""},
+        {"9999",""},
+        {"0",""},
+        {"9",""},
+        {"123","123"},
+        {"000","000"},
+        {"001","001"},
+        {"011","011"},
+        {"111","111"},
+        {"00","00"},
+        {"01","01"},
+        {"11","11"},
+        {"09","09"},
+        {"099","099"},
+        {"999", "999"}};
+
+    for (int i=0; i< sizeof(mncs) / sizeof(struct mnc_strings); i++) {
+        if (decode(encode(mncs[i].in)).compare(mncs[i].out)) return 1;
+    }
+
+    const struct mnc_ints { const int in; const char * out; } legacy_mncs[] = {
+        {INT_MAX, ""},
+        {1, "1"},
+        {11, "11"},
+        {111, "111"},
+        {0, "0"},
+        {9999, ""},
+    };
+
+    for (int i=0; i < sizeof(legacy_mncs) / sizeof(struct mnc_ints); i++) {
+        if (decode(legacy_mncs[i].in).compare(legacy_mncs[i].out)) return 1;
+    }
+
+    return 0;
+}
+#endif
+
+}
+}
+}
+#endif /* !defined(RIL_MNC_H) */
diff --git a/hardware/ril/leadcore-ril/Android.mk b/hardware/ril/leadcore-ril/Android.mk
deleted file mode 100755
index f162de5..0000000
--- a/hardware/ril/leadcore-ril/Android.mk
+++ /dev/null
@@ -1,115 +0,0 @@
-# Copyright 2006 The Android Open Source Project
-
-# XXX using libutils for simulator build only...
-#
-#ifeq ($(TARGET_PRODUCT), coral)
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-#added for VT feature begin
-#USE_VT := true
-#added for VT feature end
-
-LOCAL_VENDOR_MODULE := true
-
-LOCAL_C_INCLUDES := \
-        hardware/ril/include \
-	system/core/libnetutils/include
-
-LOCAL_SRC_FILES:= \
-    reference-ril.c \
-    atchannel_mch.c \
-    misc.c \
-    stk.c	\
-    at_tok.c \
-    ata-cfg.c \
-    ata-tok.c \
-    ril_timer.c \
-    config.c \
-
-ifeq ($(BUILD_L1813_MODEM),true)
-    LOCAL_SRC_FILES += ata-ps.c
-else
-    LOCAL_SRC_FILES += ata-ps-ip.c
-    LOCAL_SRC_FILES += ata-ps-util.c
-endif
-
-
-LOCAL_SHARED_LIBRARIES := \
-    liblog libcutils libutils libril librilutils
-
-# for asprinf
-LOCAL_CFLAGS := -DAT_CHANNEL_UDP -D_GNU_SOURCE -DOPT_LEADCORE_RIL -DOPT_4G -DTUNNEL_AT -DAT_CHANNEL_UDP \
-		-Wno-unused-parameter -Wno-unused-variable -Wno-unused-function -Wno-unused-comparison \
-		-Wno-unused-label -Wno-unused-value -Wno-format -Wno-incompatible-pointer-types-discards-qualifiers \
-		-Wno-incompatible-pointer-types -Wno-pointer-sign -Wno-uninitialized -Wno-tautological-pointer-compare \
-		-Wno-constant-conversion -Wno-sign-compare -Wno-int-conversion
-
-
-ifeq ($(BUILD_L1813_MODEM),true)
-LOCAL_CFLAGS += -DOPT_PS_PPP
-LOCAL_CFLAGS += -DOPT_MODEM_L1813
-else
-#LOCAL_CFLAGS += -DOPT_PS_IP
-LOCAL_CFLAGS += -DOPT_PS_PPP
-LOCAL_CFLAGS += -DOPT_MODEM_L1860
-endif
-
-
-
-#add [by chenshu 2012-12-11] for fix Req00000736
-ifeq ($(VOICE_SUPPORT_DOUBLE_MICS),true)
-    LOCAL_CFLAGS += -DDOUBLE_MICS
-endif
-#add [by chenshu 2012-12-11] end
-
-#added for VT feature begin
-ifeq ($(USE_VT),true)
-   LOCAL_CFLAGS += -DVT_ENABLE
-endif
-#added for VT feature end
-
-#modified by chenshu for MultiSim
-include $(LEADCORE_OPT_MULTISIM)
-
-#LOCAL_C_INCLUDES += $(KERNEL_HEADERS)
-
-ifeq (foo,foo)
-  #build shared library
-  LOCAL_SHARED_LIBRARIES += \
-      libcutils libutils libril
-#  LOCAL_LDLIBS += -lpthread
-  LOCAL_CFLAGS += -DRIL_SHLIB
-  LOCAL_CFLAGS += -DSUPPORT_CTA_TEST
-  LOCAL_MODULE:= libreference-ril
-  include $(BUILD_SHARED_LIBRARY)
-else
-  #build executable
-  LOCAL_SHARED_LIBRARIES += \
-      libril
-  LOCAL_MODULE:= reference-ril
-  LOCAL_MODULE_TAGS               := optional
-  include $(BUILD_EXECUTABLE)
-endif
-
-#chenchi add start
-#PRODUCT_COPY_FILES += $(LOCAL_PATH)/apns-conf.xml:system/etc/apns-conf.xml
-#PRODUCT_COPY_FILES += $(LOCAL_PATH)/pppd:system/xbin/pppd
-#PRODUCT_COPY_FILES += $(LOCAL_PATH)/CTA.apk:system/app/CTA.apk
-#PRODUCT_COPY_FILES += $(LOCAL_PATH)/rt_tables:system/etc/iproute2/rt_tables
-
-#Add by chenxiang. tmp version for test
-#PRODUCT_COPY_FILES += $(LOCAL_PATH)/vtlib/libmedia.so:system/lib/libmedia.so
-#PRODUCT_COPY_FILES += $(LOCAL_PATH)/vtlib/libmediaplayerservice.so:system/lib/libmediaplayerservice.so
-#PRODUCT_COPY_FILES += $(LOCAL_PATH)/vtlib/libvt_jni.so:system/lib/libvt_jni.so
-#PRODUCT_COPY_FILES += $(LOCAL_PATH)/vtlib/libopencore_2way.so:system/lib/libopencore_2way.so
-
-include $(CLEAR_VARS)
-LOCAL_SRC_FILES:= \
-             at-loop.c
-
-LOCAL_MODULE:= atloop
-LOCAL_MODULE_TAGS               := optional
-include $(BUILD_EXECUTABLE)
-
-#endif
diff --git a/hardware/ril/leadcore-ril/Android.mk.bak b/hardware/ril/leadcore-ril/Android.mk.bak
new file mode 100755
index 0000000..f162de5
--- /dev/null
+++ b/hardware/ril/leadcore-ril/Android.mk.bak
@@ -0,0 +1,115 @@
+# Copyright 2006 The Android Open Source Project
+
+# XXX using libutils for simulator build only...
+#
+#ifeq ($(TARGET_PRODUCT), coral)
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+#added for VT feature begin
+#USE_VT := true
+#added for VT feature end
+
+LOCAL_VENDOR_MODULE := true
+
+LOCAL_C_INCLUDES := \
+        hardware/ril/include \
+	system/core/libnetutils/include
+
+LOCAL_SRC_FILES:= \
+    reference-ril.c \
+    atchannel_mch.c \
+    misc.c \
+    stk.c	\
+    at_tok.c \
+    ata-cfg.c \
+    ata-tok.c \
+    ril_timer.c \
+    config.c \
+
+ifeq ($(BUILD_L1813_MODEM),true)
+    LOCAL_SRC_FILES += ata-ps.c
+else
+    LOCAL_SRC_FILES += ata-ps-ip.c
+    LOCAL_SRC_FILES += ata-ps-util.c
+endif
+
+
+LOCAL_SHARED_LIBRARIES := \
+    liblog libcutils libutils libril librilutils
+
+# for asprinf
+LOCAL_CFLAGS := -DAT_CHANNEL_UDP -D_GNU_SOURCE -DOPT_LEADCORE_RIL -DOPT_4G -DTUNNEL_AT -DAT_CHANNEL_UDP \
+		-Wno-unused-parameter -Wno-unused-variable -Wno-unused-function -Wno-unused-comparison \
+		-Wno-unused-label -Wno-unused-value -Wno-format -Wno-incompatible-pointer-types-discards-qualifiers \
+		-Wno-incompatible-pointer-types -Wno-pointer-sign -Wno-uninitialized -Wno-tautological-pointer-compare \
+		-Wno-constant-conversion -Wno-sign-compare -Wno-int-conversion
+
+
+ifeq ($(BUILD_L1813_MODEM),true)
+LOCAL_CFLAGS += -DOPT_PS_PPP
+LOCAL_CFLAGS += -DOPT_MODEM_L1813
+else
+#LOCAL_CFLAGS += -DOPT_PS_IP
+LOCAL_CFLAGS += -DOPT_PS_PPP
+LOCAL_CFLAGS += -DOPT_MODEM_L1860
+endif
+
+
+
+#add [by chenshu 2012-12-11] for fix Req00000736
+ifeq ($(VOICE_SUPPORT_DOUBLE_MICS),true)
+    LOCAL_CFLAGS += -DDOUBLE_MICS
+endif
+#add [by chenshu 2012-12-11] end
+
+#added for VT feature begin
+ifeq ($(USE_VT),true)
+   LOCAL_CFLAGS += -DVT_ENABLE
+endif
+#added for VT feature end
+
+#modified by chenshu for MultiSim
+include $(LEADCORE_OPT_MULTISIM)
+
+#LOCAL_C_INCLUDES += $(KERNEL_HEADERS)
+
+ifeq (foo,foo)
+  #build shared library
+  LOCAL_SHARED_LIBRARIES += \
+      libcutils libutils libril
+#  LOCAL_LDLIBS += -lpthread
+  LOCAL_CFLAGS += -DRIL_SHLIB
+  LOCAL_CFLAGS += -DSUPPORT_CTA_TEST
+  LOCAL_MODULE:= libreference-ril
+  include $(BUILD_SHARED_LIBRARY)
+else
+  #build executable
+  LOCAL_SHARED_LIBRARIES += \
+      libril
+  LOCAL_MODULE:= reference-ril
+  LOCAL_MODULE_TAGS               := optional
+  include $(BUILD_EXECUTABLE)
+endif
+
+#chenchi add start
+#PRODUCT_COPY_FILES += $(LOCAL_PATH)/apns-conf.xml:system/etc/apns-conf.xml
+#PRODUCT_COPY_FILES += $(LOCAL_PATH)/pppd:system/xbin/pppd
+#PRODUCT_COPY_FILES += $(LOCAL_PATH)/CTA.apk:system/app/CTA.apk
+#PRODUCT_COPY_FILES += $(LOCAL_PATH)/rt_tables:system/etc/iproute2/rt_tables
+
+#Add by chenxiang. tmp version for test
+#PRODUCT_COPY_FILES += $(LOCAL_PATH)/vtlib/libmedia.so:system/lib/libmedia.so
+#PRODUCT_COPY_FILES += $(LOCAL_PATH)/vtlib/libmediaplayerservice.so:system/lib/libmediaplayerservice.so
+#PRODUCT_COPY_FILES += $(LOCAL_PATH)/vtlib/libvt_jni.so:system/lib/libvt_jni.so
+#PRODUCT_COPY_FILES += $(LOCAL_PATH)/vtlib/libopencore_2way.so:system/lib/libopencore_2way.so
+
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:= \
+             at-loop.c
+
+LOCAL_MODULE:= atloop
+LOCAL_MODULE_TAGS               := optional
+include $(BUILD_EXECUTABLE)
+
+#endif
diff --git a/hardware/ril/rild/rild.c b/hardware/ril/rild/rild.c
old mode 100644
new mode 100755
index f32768f..c554a9f
--- a/hardware/ril/rild/rild.c
+++ b/hardware/ril/rild/rild.c
@@ -25,7 +25,6 @@
 #include <errno.h>
 
 #include <telephony/ril.h>
-#include <telephony/multichannel.h>
 #define LOG_TAG "RILD"
 #include <log/log.h>
 #include <cutils/properties.h>
@@ -44,24 +43,6 @@
 #define LIB_ARGS_PROPERTY   "rild.libargs"
 #endif
 #define MAX_LIB_ARGS        16
-// #define MAX_CAP_NUM         (CAP_TO_INDEX(CAP_LAST_CAP) + 1)
-#define RESET_PROCESS_SIGNAL                    12
-
-/*add by yuanhaobo for L1860 @ 2013-12-11 begin*/
-#define RILD_MSMS_SIM_COUNT_PROPERTY            "ro.leadcore.sim.count"
-#define RILD_MSMS_STANDBY_COUNT_PROPERTY        "ro.leadcore.standby.count"
-#define RILD_MSMS_COMMUNICATION_COUNT_PROPERTY  "ro.leadcore.communication.count"
-/*add by yuanhaobo for L1860 @ 2013-12-11 end*/
-
-//Apr 12, 2017, added by lvfei
-#define PROPERTY_PERSIST_SYS_XT_MODEM_TYPE      "sys.xt.modem.type"
-#define PROPERTY_DEFAULT_VALUE_XT_MODEM_TYPE          "0"
-static int g_modemtype = 0;
-//end
-
-static int g_rilId = 0;
-
-static void (*shutdownLmiDevices)(int);
 
 static void usage(const char *argv0) {
     fprintf(stderr, "Usage: %s -l <ril impl library> [-- <args for impl library>]\n", argv0);
@@ -72,7 +53,6 @@ extern char ril_service_name_base[MAX_SERVICE_NAME_LENGTH];
 extern char ril_service_name[MAX_SERVICE_NAME_LENGTH];
 
 extern void RIL_register (const RIL_RadioFunctions *callbacks);
-extern void RIL_register_ex (const RIL_RadioFunctions *callbacks, int rilID);
 extern void rilc_thread_pool ();
 
 extern void RIL_register_socket (const RIL_RadioFunctions *(*rilUimInit)
@@ -103,7 +83,6 @@ static struct RIL_Env s_rilEnv = {
 };
 
 extern void RIL_startEventLoop();
-extern void RIL_startEventLoop_ex(int rilID);
 
 static int make_argv(char * args, char ** argv) {
     // Note: reserve argv[0]
@@ -119,30 +98,6 @@ static int make_argv(char * args, char ** argv) {
     return count;
 }
 
-static void signal_treatment(int param)
-{
-    static int is_signal_running = 0;
-
-    RLOGD("Trigger signal_treatment, is_signal_running = %d, g_rilId = %d", is_signal_running, g_rilId);
-    if(is_signal_running)
-    {
-        return;
-    }
-
-    is_signal_running = 1;
-    RLOGD("Trigger signal_treatment, param = %d", param);
-    if(RESET_PROCESS_SIGNAL == param)
-    {
-        if (NULL != shutdownLmiDevices) {
-            shutdownLmiDevices(g_rilId);
-        } else {
-            RLOGD("Trigger signal_treatment, shutdownLmiDevices = 0x%p", shutdownLmiDevices);
-        }
-        sleep(2);
-        exit(0);
-    }
-}
-
 int main(int argc, char **argv) {
     // vendor ril lib path either passed in as -l parameter, or read from rild.libpath property
     const char *rilLibPath = NULL;
@@ -159,12 +114,9 @@ int main(int argc, char **argv) {
     // functions returned by ril init function in vendor ril
     const RIL_RadioFunctions *funcs;
     // lib path from rild.libpath property (if it's read)
-#ifndef OPT_LEADCORE_RIL
-    char libPath[PROPERTY_VALUE_MAX] = {0};
-#endif
+    char libPath[PROPERTY_VALUE_MAX];
     // flat to indicate if -- parameters are present
     unsigned char hasLibArgs = 0;
-    int rilID = -1;
 
     int i;
     // ril/socket id received as -c parameter, otherwise set to 0
@@ -174,12 +126,6 @@ int main(int argc, char **argv) {
     RLOGD("**RILd param count=%d**", argc);
 
     umask(S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH);
-    RLOGD("[rild main]: argc = %d", argc);
-
-    for (i = 0; i < argc; i++) {
-        RLOGD("[rild main]: argv[%d] = %s", i, argv[i]);
-    }
-
     for (i = 1; i < argc ;) {
         if (0 == strcmp(argv[i], "-l") && (argc - i > 1)) {
             rilLibPath = argv[i + 1];
@@ -191,33 +137,6 @@ int main(int argc, char **argv) {
         } else if (0 == strcmp(argv[i], "-c") &&  (argc - i > 1)) {
             clientId = argv[i+1];
             i += 2;
-        } else if (0 == strcmp(argv[i], "-s")) {
-            int index = 0;
-            char *configString = argv[i+1];
-            int len = strlen(configString);
-            RLOGD("[rild main]: configString = %s", configString);
-
-            for (index = 0; index < len; index++) {
-                char ch = configString[index];
-                RLOGD("[rild main]: configString[%d] = %d", index, atoi(&ch));
-                switch (index) {
-                    case 0:
-                        property_set(RILD_MSMS_SIM_COUNT_PROPERTY, &ch);
-                        break;
-
-                    case 1:
-                        property_set(RILD_MSMS_STANDBY_COUNT_PROPERTY, &ch);
-                        break;
-
-                    case 2:
-                        property_set(RILD_MSMS_COMMUNICATION_COUNT_PROPERTY, &ch);
-                        break;
-                }
-            }
-            i += 2;
-        } else if (0 == strcmp(argv[i], "-n")) {
-            rilID = atoi(argv[i+1]);
-            i += 2;
         } else {
             usage(argv[0]);
         }
@@ -234,22 +153,6 @@ int main(int argc, char **argv) {
                  clientId);
     }
 
-    //Apr 12, 2017, add start by lvfei
-    RLOGD("XT--->Ready to get Phone Type (0:LTE, 1:Satellite.)");
-    //char property_value_a[92] = {0};
-    char property_value_a[92] = {1};//modify by wyy22/06/08
-    if(property_get(PROPERTY_PERSIST_SYS_XT_MODEM_TYPE, property_value_a, NULL))    {
-        g_modemtype = property_value_a[0] - '0';
-    } else {
-        RLOGD("XT--->Read PROPERTY_PERSIST_SYS_XT_MODEM_TYPE Fail.");
-    }
-    RLOGD("XT--->[ Phone Type is [ %d ](0:LTE, 1:Satellite.)", g_modemtype);
-    //add end
-    
-    RLOGD("[ Ril Daemon V7.01.09 Multichannel ]RILD[ %d ]", rilID);
-    g_rilId = rilID; 
-
-#ifndef OPT_LEADCORE_RIL
     if (rilLibPath == NULL) {
         if ( 0 == property_get(LIB_PATH_PROPERTY, libPath, NULL)) {
             // No lib sepcified on the command line, and nothing set in props.
@@ -259,34 +162,6 @@ int main(int argc, char **argv) {
             rilLibPath = libPath;
         }
     }
-#else /*OPT_LEADCORE_RIL*/
-    {
-        static char*  arg_overrides[3]; 
-        char dev_a_1[50] = {RILD0_FIRST_DEV_CHANNEL};
-        char dev_a_2[50] = {RILD1_FIRST_DEV_CHANNEL};
-        char index[8] = {0};
-
-
-        sprintf(index, "%d", rilID);
-        arg_overrides[0] = index;
-       /* arg_overrides[1] = "-d";*/
-       arg_overrides[1]="-s";
-        arg_overrides[2] = (rilID == 0)?dev_a_1:dev_a_2;
-        argv = arg_overrides;
-        argc = 3;
-        i    = 1;
-        hasLibArgs = 1;
-
-#ifdef __aarch64__
-        rilLibPath = "/vendor/lib64/libreference-ril.so";
-#else
-        rilLibPath = "/vendor/lib/libreference-ril.so";
-#endif
-
-        RLOGD( "%s - %s() - L%d - ""overriding with %s %s",
-              __FILE__, __func__, __LINE__, arg_overrides[1], arg_overrides[2] );
-    }
-#endif /*OPT_LEADCORE_RIL*/
 
     dlHandle = dlopen(rilLibPath, RTLD_NOW);
 
@@ -296,7 +171,6 @@ int main(int argc, char **argv) {
     }
 
     RIL_startEventLoop();
-    // RIL_startEventLoop_ex(rilID);
 
     rilInit =
         (const RIL_RadioFunctions *(*)(const struct RIL_Env *, int, char **))
@@ -318,12 +192,6 @@ int main(int argc, char **argv) {
         RLOGW("RIL_SAP_Init defined as null in %s. SAP Not usable\n", rilLibPath);
     }
 
-    shutdownLmiDevices = (void (*)(int))dlsym(dlHandle, "ata_ps_close_lmi_in_shutdown");
-    RLOGD("shutdownLmiDevices = 0x%p", shutdownLmiDevices);
-    if (NULL == shutdownLmiDevices) {
-        RLOGE("ata_ps_close_lmi_in_shutdown() not defined or exported in %s\n", rilLibPath);
-    }
-
     if (hasLibArgs) {
         rilArgv = argv + i - 1;
         argc = argc -i + 1;
@@ -346,8 +214,6 @@ int main(int argc, char **argv) {
     RLOGD("RIL_Init rilInit completed");
 
     RIL_register(funcs);
-    signal(RESET_PROCESS_SIGNAL, signal_treatment);/*Fixed Enh00001076, by chenchi 2011-08-09 */
-    // RIL_register_ex(funcs, rilID);
 
     RLOGD("RIL_Init RIL_register completed");
 
@@ -357,9 +223,9 @@ int main(int argc, char **argv) {
     }
 
     RLOGD("RIL_register_socket completed");
-#ifndef OPT_LEADCORE_RIL
+
 done:
-#endif
+
     rilc_thread_pool();
 
     RLOGD("RIL_Init starting sleep loop");
diff --git a/hardware/ril/rild/rild.legacy.rc b/hardware/ril/rild/rild.legacy.rc
old mode 100644
new mode 100755
index b27e1da..8750653
--- a/hardware/ril/rild/rild.legacy.rc
+++ b/hardware/ril/rild/rild.legacy.rc
@@ -1,5 +1,5 @@
-service ril-daemon /vendor/bin/hw/rild
+service ril-daemon /vendor/bin/hw/rild -l /vendor/lib64/libreference-ril.so -- -w 1
     class main
-    user radio
-    group radio cache inet misc audio log readproc wakelock
+    user root
+    group radio vpn cache inet misc audio log readproc wakelock
     capabilities BLOCK_SUSPEND NET_ADMIN NET_RAW
diff --git a/hardware/ril/rild/rild.rc b/hardware/ril/rild/rild.rc
old mode 100644
new mode 100755
index ff4f0c3..da685d7
--- a/hardware/ril/rild/rild.rc
+++ b/hardware/ril/rild/rild.rc
@@ -1,5 +1,5 @@
-service vendor.ril-daemon /vendor/bin/hw/rild -n 0
-    class main
-    user radio
-    group radio cache inet misc audio log readproc wakelock
-    capabilities BLOCK_SUSPEND NET_ADMIN NET_RAW
+service ril-daemon /vendor/bin/hw/rild -l /vendor/lib64/libreference-ril.so -- -w 1
+	class main
+	user root
+	group radio vpn cache inet misc audio log readproc wakelock
+	capabilities BLOCK_SUSPEND NET_ADMIN
diff --git a/hardware/ril/youyou_ril/Android.mk b/hardware/ril/youyou_ril/Android.mk
new file mode 100755
index 0000000..a96468f
--- /dev/null
+++ b/hardware/ril/youyou_ril/Android.mk
@@ -0,0 +1,150 @@
+# Copyright 2006 The Android Open Source Project
+
+# XXX using libutils for simulator build only...
+#
+#ifeq ($(BOARD_HAVE_MODEM),true)
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+
+LOCAL_SRC_FILES:= $(call all-c-files-under)
+
+
+LOCAL_SHARED_LIBRARIES := \
+    libcutils \
+    libutils \
+    libril \
+    libnetutils \
+    liblog \
+    librilutils 
+
+# for asprinf
+LOCAL_CFLAGS :=  -D_GNU_SOURCE
+LOCAL_CFLAGS +=  -Wno-unused-result \
+                 -Wno-unused-variable \
+                 -Wno-sign-compare \
+                 -Wno-pointer-sign \
+                 -Wno-unused-function \
+                 -Wno-unused-parameter \
+                 -Wno-unused-variable \
+                 -Wno-implicit-function-declaration \
+                 -Wno-unused-result \
+                 -Wno-comment \
+                 -Wno-unused-value \
+                 -Wno-incompatible-pointer-types \
+                 -Wno-format  \
+                 -Wno-for-loop-analysis \
+                 -Wno-sometimes-uninitialized \
+                 -Wno-parentheses-equality \
+                 -Wno-uninitialized \
+                 -Wno-return-stack-address \
+                 -Wno-self-assign \
+                 -Wno-unused-label \
+                 -Wno-enum-conversion \
+
+#LOCAL_C_INCLUDES := $(KERNEL_HEADERS)
+
+LOCAL_CFLAGS += -DHAVE_DATA_DEVICE
+
+LOCAL_CFLAGS += -DSIGNAL_MODEM
+
+ifeq ($(TARGET_DEVICE),sooner)
+  LOCAL_CFLAGS += -DOMAP_CSMI_POWER_CONTROL -DUSE_TI_COMMANDS
+endif
+
+ifeq ($(TARGET_DEVICE),surf)
+  LOCAL_CFLAGS += -DPOLL_CALL_STATE -DUSE_QMI
+endif
+
+ifeq ($(TARGET_DEVICE),dream)
+  LOCAL_CFLAGS += -DPOLL_CALL_STATE -DUSE_QMI
+endif
+
+LOCAL_VENDOR_MODULE:= true
+
+ifeq (foo,foo)
+  #build shared library
+  LOCAL_SHARED_LIBRARIES += \
+      libcutils libutils
+
+#<!-- build 32/64 by caogang@20171025
+$(warning   TARGET_ARCH=$(TARGET_ARCH))
+$(warning   PLATFORM_VERSION_CODENAME=$(PLATFORM_VERSION_CODENAME))
+$(warning   PLATFORM_VERSION=$(PLATFORM_VERSION))
+MAJOR_VERSION :=$(shell echo $(PLATFORM_VERSION) | cut -f1 -d.)
+MINOR_VERSION :=$(shell echo $(PLATFORM_VERSION) | cut -f2 -d.)
+
+ifeq (1, 2)
+$(warning   MAJOR_VERSION=$(MAJOR_VERSION))
+$(warning   MINOR_VERSION=$(MINOR_VERSION))
+
+ifeq ($(MAJOR_VERSION),11)
+ LOCAL_CFLAGS += -DGHT_FEATURE_ANDROID11X
+ LOCAL_CFLAGS += -DGHT_FEATURE_ANDROID10X
+endif
+ifeq ($(MAJOR_VERSION),10)
+ LOCAL_CFLAGS += -DGHT_FEATURE_ANDROID10X
+endif
+ifeq ($(MAJOR_VERSION),9)
+ LOCAL_CFLAGS += -DGHT_FEATURE_ANDROID9X
+endif
+#added by lisf 20181212
+ifeq ($(MAJOR_VERSION),8)
+ LOCAL_CFLAGS += -DGHT_FEATURE_ANDROID8X
+endif
+ifeq ($(MAJOR_VERSION),7)
+ LOCAL_CFLAGS += -DGHT_FEATURE_ANDROID7X
+endif
+ifeq ($(MAJOR_VERSION),6)
+ LOCAL_CFLAGS += -DGHT_FEATURE_ANDROID6X
+endif
+ifeq ($(MAJOR_VERSION),5)
+ LOCAL_CFLAGS += -DGHT_FEATURE_ANDROID5X
+endif
+
+#<---end
+#added by eric.li 20190115
+ifeq ($(MAJOR_VERSION),4)
+ LOCAL_CFLAGS += -DGHT_FEATURE_ANDROID4X
+endif
+#end
+VERSION_JB :=$(shell test $(MAJOR_VERSION) -gt 4 && echo true)
+ifeq ($(VERSION_JB),true)
+#  LOCAL_LDLIBS += -lpthread
+$(warning   #############no lpthread##########)
+else
+  LOCAL_LDLIBS += -lpthread
+$(warning   #############lpthread##########)
+endif
+
+ifeq ($(MAJOR_VERSION),10)
+ LOCAL_CFLAGS += -DODM_ARM64
+endif
+
+else
+$(warning   We do not need Android version)
+#LOCAL_LDLIBS += -lpthread
+endif
+ifeq ($(TARGET_ARCH), arm64)
+  LOCAL_CFLAGS += -DODM_ARM64
+endif
+#end -->
+
+#<!-- add dial mode by caogang@20171026
+#0 ras
+#1 ecm -- no support
+#2 ndis
+  LOCAL_CFLAGS += -DODM_DEVMODE=0
+#end -->
+
+  LOCAL_CFLAGS += -DRIL_SHLIB
+  LOCAL_MODULE:= libreference-ril
+  include $(BUILD_SHARED_LIBRARY)
+else
+  #build executable
+  LOCAL_SHARED_LIBRARIES += \
+      libril
+  LOCAL_MODULE:= reference-ril
+  include $(BUILD_EXECUTABLE)
+endif
+#endif
diff --git a/hardware/ril/youyou_ril/MODULE_LICENSE_APACHE2 b/hardware/ril/youyou_ril/MODULE_LICENSE_APACHE2
new file mode 100755
index 0000000..e69de29
diff --git a/hardware/ril/youyou_ril/NOTICE b/hardware/ril/youyou_ril/NOTICE
new file mode 100755
index 0000000..c5b1efa
--- /dev/null
+++ b/hardware/ril/youyou_ril/NOTICE
@@ -0,0 +1,190 @@
+
+   Copyright (c) 2005-2008, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/hardware/ril/youyou_ril/at_tok.c b/hardware/ril/youyou_ril/at_tok.c
new file mode 100755
index 0000000..859d8e9
--- /dev/null
+++ b/hardware/ril/youyou_ril/at_tok.c
@@ -0,0 +1,192 @@
+/* //device/system/reference-ril/at_tok.c
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+/*when who why modified*/
+
+#include "at_tok.h"
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+
+/**
+ * Starts tokenizing an AT response string
+ * returns -1 if this is not a valid response string, 0 on success.
+ * updates *p_cur with current position
+ */
+int at_tok_start(char **p_cur)
+{
+    if (*p_cur == NULL) {
+        return -1;
+    }
+
+    // skip prefix
+    // consume "^[^:]:"
+
+    *p_cur = strchr(*p_cur, ':');
+
+    if (*p_cur == NULL) {
+        return -1;
+    }
+
+    (*p_cur)++;
+
+    return 0;
+}
+
+static void skipWhiteSpace(char **p_cur)
+{
+    if (*p_cur == NULL) return;
+
+    while (**p_cur != '\0' && isspace(**p_cur)) {
+        (*p_cur)++;
+    }
+}
+
+static void skipNextComma(char **p_cur)
+{
+    if (*p_cur == NULL) return;
+
+    while (**p_cur != '\0' && **p_cur != ',') {
+        (*p_cur)++;
+    }
+
+    if (**p_cur == ',') {
+        (*p_cur)++;
+    }
+}
+
+static char * nextTok(char **p_cur)
+{
+    char *ret = NULL;
+
+    skipWhiteSpace(p_cur);
+
+    if (*p_cur == NULL) {
+        ret = NULL;
+    } else if (**p_cur == '"') {
+        (*p_cur)++;
+        ret = strsep(p_cur, "\"");
+        skipNextComma(p_cur);
+    } else {
+        ret = strsep(p_cur, ",");
+    }
+
+    return ret;
+}
+
+
+/**
+ * Parses the next integer in the AT response line and places it in *p_out
+ * returns 0 on success and -1 on fail
+ * updates *p_cur
+ * "base" is the same as the base param in strtol
+ */
+
+static int at_tok_nextint_base(char **p_cur, int *p_out, int base, int  uns)
+{
+    char *ret;
+
+    if (*p_cur == NULL) {
+        return -1;
+    }
+
+    ret = nextTok(p_cur);
+
+    if (ret == NULL) {
+        return -1;
+    } else {
+        long l;
+        char *end;
+
+        if (uns)
+            l = strtoul(ret, &end, base);
+        else
+            l = strtol(ret, &end, base);
+
+        *p_out = (int)l;
+
+        if (end == ret) {
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * Parses the next base 10 integer in the AT response line
+ * and places it in *p_out
+ * returns 0 on success and -1 on fail
+ * updates *p_cur
+ */
+int at_tok_nextint(char **p_cur, int *p_out)
+{
+    return at_tok_nextint_base(p_cur, p_out, 10, 0);
+}
+
+/**
+ * Parses the next base 16 integer in the AT response line
+ * and places it in *p_out
+ * returns 0 on success and -1 on fail
+ * updates *p_cur
+ */
+int at_tok_nexthexint(char **p_cur, int *p_out)
+{
+    return at_tok_nextint_base(p_cur, p_out, 16, 1);
+}
+
+int at_tok_nextbool(char **p_cur, char *p_out)
+{
+    int ret;
+    int result;
+
+    ret = at_tok_nextint(p_cur, &result);
+
+    if (ret < 0) {
+        return -1;
+    }
+
+    // booleans should be 0 or 1
+    if (!(result == 0 || result == 1)) {
+        return -1;
+    }
+
+    if (p_out != NULL) {
+        *p_out = (char)result;
+    }
+
+    return ret;
+}
+
+int at_tok_nextstr(char **p_cur, char **p_out)
+{
+    if (*p_cur == NULL) {
+        return -1;
+    }
+
+    *p_out = nextTok(p_cur);
+
+    return 0;
+}
+
+/** returns 1 on "has more tokens" and 0 if no */
+int at_tok_hasmore(char **p_cur)
+{
+    return ! (*p_cur == NULL || **p_cur == '\0');
+}
+
+
diff --git a/hardware/ril/youyou_ril/at_tok.h b/hardware/ril/youyou_ril/at_tok.h
new file mode 100755
index 0000000..d829104
--- /dev/null
+++ b/hardware/ril/youyou_ril/at_tok.h
@@ -0,0 +1,31 @@
+/* //device/system/reference-ril/at_tok.h
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+/*when who why modified*/
+
+#ifndef AT_TOK_H
+#define AT_TOK_H 1
+
+int at_tok_start(char **p_cur);
+int at_tok_nextint(char **p_cur, int *p_out);
+int at_tok_nexthexint(char **p_cur, int *p_out);
+
+int at_tok_nextbool(char **p_cur, char *p_out);
+int at_tok_nextstr(char **p_cur, char **out);
+
+int at_tok_hasmore(char **p_cur);
+
+#endif /*AT_TOK_H */
diff --git a/hardware/ril/youyou_ril/atchannel.c b/hardware/ril/youyou_ril/atchannel.c
new file mode 100755
index 0000000..4da6d6e
--- /dev/null
+++ b/hardware/ril/youyou_ril/atchannel.c
@@ -0,0 +1,1329 @@
+/* //device/system/reference-ril/atchannel.c
+ **
+ ** Copyright 2006, The Android Open Source Project
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/*when who why modified*/
+/*2011.10.21 modified by chenkai for no prefix reply of some AT command, such as CGMR */
+
+#include "atchannel.h"
+#include "at_tok.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/time.h>
+#include <time.h>
+#include <unistd.h>
+
+#define LOG_NDEBUG 0
+#define LOG_TAG GHT_AT
+#include <utils/Log.h>
+
+#define HAVE_ANDROID_OS 1
+
+#ifdef HAVE_ANDROID_OS
+#undef HAVE_ANDROID_OS
+#endif //HAVE_ANDROID_OS
+
+
+#ifdef HAVE_ANDROID_OS
+/* for IOCTL's */
+#include <linux/omap_csmi.h>
+#endif /*HAVE_ANDROID_OS*/
+
+#include "misc.h"
+#include "ril_common.h"
+
+#ifdef HAVE_ANDROID_OS
+//#define USE_NP 1
+#define USE_NP 0
+#endif /* HAVE_ANDROID_OS */
+
+
+#define NUM_ELEMS(x) (sizeof(x)/sizeof(x[0]))
+
+#define MAX_AT_RESPONSE (8 * 1024)
+#define HANDSHAKE_RETRY_COUNT 8
+/* BEGIN: Modified by eric.li, 2018/10/10   PN:debug RIL_register failed */
+// <!--[ODM]wangmengying@2019.8.16 [SN-20190712001,SN-20190608001]optimization ppp time
+#if 1
+#define HANDSHAKE_TIMEOUT_MSEC 10000
+// end-->
+#else
+#define HANDSHAKE_TIMEOUT_MSEC 10000
+#endif
+/* END:   Modified by eric.li, 2018/10/10   PN:debug RIL_register failed */
+
+static pthread_t s_tid_reader;
+int s_fd = -1;    /* fd of the AT channel */
+static ATUnsolHandler s_unsolHandler;
+
+/* for input buffering */
+
+char s_ATBuffer[MAX_AT_RESPONSE+1];
+char *s_ATBufferCur = s_ATBuffer;
+
+//static int s_ackPowerIoctl; /* true if TTY has android byte-count handshake for low power*/
+static int s_readCount = 0;
+
+extern char atchannel[15];
+extern char datachannel[15];
+
+extern char cur_atchannel[15];
+extern char cur_datachannel[15];
+
+
+#if AT_DEBUG
+void  AT_DUMP(const char*  prefix, const char*  buff, int  len)
+{
+    if (len < 0)
+        len = strlen(buff);
+    RLOGD("%.*s", len, buff);
+}
+#endif
+
+/*
+ * for current pending command
+ * these are protected by s_commandmutex
+ */
+
+static pthread_mutex_t s_commandmutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t s_commandcond = PTHREAD_COND_INITIALIZER;
+
+
+//added by zhengjianrong for mutex exception 20190525 begin
+static pthread_mutex_t s_again_commandmutex = PTHREAD_MUTEX_INITIALIZER;
+//added by zhengjianrong for mutex exception 20190525 end
+
+static ATCommandType s_type;
+static const char *s_responsePrefix = NULL;
+static const char *s_smsPDU = NULL;
+static ATResponse *sp_response = NULL;
+
+static void (*s_onTimeout)(void) = NULL;
+static void (*s_onReaderClosed)(void) = NULL;
+static int s_readerClosed;
+
+static void onReaderClosed();
+static int writeCtrlZ (const char *s);
+static int writeline (const char *s);
+
+#ifndef USE_NP
+static void setTimespecRelative(struct timespec *p_ts, long long msec)
+{
+    struct timeval tv;
+
+    gettimeofday(&tv, (struct timezone *) NULL);
+
+    /* what's really funny about this is that I know
+       pthread_cond_timedwait just turns around and makes this
+       a relative time again */
+    p_ts->tv_sec = tv.tv_sec + (msec / 1000);
+    p_ts->tv_nsec = (tv.tv_usec + (msec % 1000) * 1000L ) * 1000L;
+}
+#endif /*USE_NP*/
+
+static void sleepMsec(long long msec)
+{
+    struct timespec ts;
+    int err;
+
+    ts.tv_sec = (msec / 1000);
+    ts.tv_nsec = (msec % 1000) * 1000 * 1000;
+
+    do
+    {
+        err = nanosleep (&ts, &ts);
+    }
+    while (err < 0 && errno == EINTR);
+}
+
+
+
+/** add an intermediate response to sp_response*/
+static void addIntermediate(const char *line)
+{
+    ATLine *p_new;
+
+    p_new = (ATLine  *) malloc(sizeof(ATLine));
+
+    p_new->line = strdup(line);
+
+    /* note: this adds to the head of the list, so the list
+       will be in reverse order of lines received. the order is flipped
+       again before passing on to the command issuer */
+    p_new->p_next = sp_response->p_intermediates;
+    sp_response->p_intermediates = p_new;
+}
+
+
+/**
+ * returns 1 if line is a final response indicating error
+ * See 27.007 annex B
+ * WARNING: NO CARRIER and others are sometimes unsolicited
+ */
+static const char * s_finalResponsesError[] =
+{
+    "ERROR",
+    "+CMS ERROR:",
+    "+CME ERROR:",
+    "NO CARRIER", /* sometimes! */
+    "NO ANSWER",
+    "NO DIALTONE",
+};
+static int isFinalResponseError(const char *line)
+{
+    size_t i;
+
+    for (i = 0 ; i < NUM_ELEMS(s_finalResponsesError) ; i++)
+    {
+        if (strStartsWith(line, s_finalResponsesError[i]))
+        {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * returns 1 if line is a final response indicating success
+ * See 27.007 annex B
+ * WARNING: NO CARRIER and others are sometimes unsolicited
+ */
+static const char * s_finalResponsesSuccess[] =
+{
+    "OK",
+    "CONNECT"       /* some stacks start up data on another channel */
+};
+static int isFinalResponseSuccess(const char *line)
+{
+    size_t i;
+
+    for (i = 0 ; i < NUM_ELEMS(s_finalResponsesSuccess) ; i++)
+    {
+        if (strStartsWith(line, s_finalResponsesSuccess[i]))
+        {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * returns 1 if line is a final response, either  error or success
+ * See 27.007 annex B
+ * WARNING: NO CARRIER and others are sometimes unsolicited
+ */
+ #if 0
+static int isFinalResponse(const char *line)
+{
+    return isFinalResponseSuccess(line) || isFinalResponseError(line);
+}
+#endif
+
+
+/**
+ * returns 1 if line is the first line in (what will be) a two-line
+ * SMS unsolicited response
+ */
+//add by nodecom-aron
+static const char * s_smsUnsoliciteds[] =
+{
+    //"+CMTI:",
+    "+CDSI:",
+    "+CMT:",
+    "+CDS:",
+    "+CBM:",
+    "+CMGR:",
+};
+static int isSMSUnsolicited(const char *line)
+{
+    size_t i;
+
+    for (i = 0 ; i < NUM_ELEMS(s_smsUnsoliciteds) ; i++)
+    {
+        if (strStartsWith(line, s_smsUnsoliciteds[i]))
+        {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+
+/** assumes s_commandmutex is held */
+static void handleFinalResponse(const char *line)
+{
+    int i = 0; //added by lisf for debug 20181208
+    sp_response->finalResponse = strdup(line);
+    for (i = 0 ; i < 3 ; i++ )
+    {
+    	pthread_cond_signal(&s_commandcond);
+    }
+}
+
+static void handleUnsolicited(const char *line)
+{
+    if (s_unsolHandler != NULL)
+    {
+        s_unsolHandler(line, NULL);
+    }
+}
+
+//modified by nodecom aron 2011.10.21 begin
+/*
+ * For some AT command (such as  +CGMR ...) in some modems ,there is no Prefix in the response value. Thus we have to
+ * judge whether the response value of these AT command have a prefix at first, so that  method processline can handle  it accurately.
+ */
+ #if 0
+static int havaPrex(const char * response)
+{
+
+    if (strStartsWith (response,"+") )
+    {
+        return 1;
+    }
+    return 0;
+}
+
+static const char *  at_response_noPrefix[] =
+{
+    "+CGMR:",
+};
+
+
+static int isNoPrefixAT(const char * line)
+{
+    size_t j;
+    for (j = 0 ; j < NUM_ELEMS(at_response_noPrefix) ; j++)
+    {
+        if(0==strcmp(s_responsePrefix,at_response_noPrefix[j]))
+        {
+            if(havaPrex(line))
+            {
+                break;
+            }
+            return 1;
+        }
+    }
+    return 0;
+}
+#endif
+
+static void processLine(const char *line)
+{
+    pthread_mutex_lock(&s_commandmutex);
+
+    if (sp_response == NULL)
+    {
+        /* no command pending */
+        handleUnsolicited(line);
+    }
+    else if (isFinalResponseSuccess(line))
+    {
+         RLOGD("isFinalResponseSuccess %s\n", line);
+        sp_response->success = 1;
+        handleFinalResponse(line);
+    }
+    else if (isFinalResponseError(line))
+    {
+        sp_response->success = 0;
+        handleFinalResponse(line);
+    }
+    else if (s_smsPDU != NULL && (0 == strcmp(line, "> ") || 0 == strcmp(line, ">")))
+    {
+        // See eg. TS 27.005 4.3
+        // Commands like AT+CMGS have a "> " prompt
+        writeCtrlZ(s_smsPDU);
+        s_smsPDU = NULL;
+    }
+    else switch (s_type)
+    {
+        case NO_RESULT:
+            handleUnsolicited(line);
+            break;
+        case NUMERIC:
+            if (sp_response->p_intermediates == NULL
+                    && isdigit(line[0]))
+            {
+                addIntermediate(line);
+            }
+            else
+            {
+                /* either we already have an intermediate response or
+                   the line doesn't begin with a digit */
+                handleUnsolicited(line);
+            }
+            break;
+        case SINGLELINE:
+            if (sp_response->p_intermediates == NULL
+                    && strStartsWith (line, s_responsePrefix))
+            {
+                addIntermediate(line);
+            }
+            else
+            {
+                /* we already have an intermediate response */
+                handleUnsolicited(line);
+            }
+            break;
+        case MULTILINE:
+            if (strStartsWith (line, s_responsePrefix))
+            {
+                addIntermediate(line);
+            }
+            else
+            {
+                handleUnsolicited(line);
+            }
+            break;
+
+        default: /* this should never be reached */
+            RLOGD("Unsupported AT command type %d\n", s_type);
+            handleUnsolicited(line);
+            break;
+    }
+
+    pthread_mutex_unlock(&s_commandmutex);
+}
+
+
+/**
+ * Returns a pointer to the end of the next line
+ * special-cases the "> " SMS prompt
+ *
+ * returns NULL if there is no complete line
+ */
+static char * findNextEOL(char *cur)
+{
+    if (cur[0] == '>' && cur[1] == ' ' && cur[2] == '\0')
+    {
+        /* SMS prompt character...not \r terminated */
+        return cur+2;
+    }
+
+    // Find next newline
+    while (*cur != '\0' && *cur != '\r' && *cur != '\n') cur++;
+
+    return *cur == '\0' ? NULL : cur;
+}
+
+
+/**
+ * Reads a line from the AT channel, returns NULL on timeout.
+ * Assumes it has exclusive read access to the FD
+ *
+ * This line is valid only until the next call to readline
+ *
+ * This function exists because as of writing, android libc does not
+ * have buffered stdio.
+ */
+
+static const char *readline()
+{
+    ssize_t count;
+
+    char *p_read = NULL;
+    char *p_eol = NULL;
+    char *ret;
+
+    /* this is a little odd. I use *s_ATBufferCur == 0 to
+     * mean "buffer consumed completely". If it points to a character, than
+     * the buffer continues until a \0
+     */
+    if (*s_ATBufferCur == '\0')
+    {
+        /* empty buffer */
+        s_ATBufferCur = s_ATBuffer;
+        *s_ATBufferCur = '\0';
+        p_read = s_ATBuffer;
+    }
+    else       /* *s_ATBufferCur != '\0' */
+    {
+        /* there's data in the buffer from the last read */
+
+        // skip over leading newlines
+        while (*s_ATBufferCur == '\r' || *s_ATBufferCur == '\n')
+            s_ATBufferCur++;
+
+        p_eol = findNextEOL(s_ATBufferCur);
+
+        if (p_eol == NULL)
+        {
+            /* a partial line. move it up and prepare to read more */
+            size_t len;
+
+            len = strlen(s_ATBufferCur);
+
+            memmove(s_ATBuffer, s_ATBufferCur, len + 1);
+            p_read = s_ATBuffer + len;
+            s_ATBufferCur = s_ATBuffer;
+        }
+        /* Otherwise, (p_eol !- NULL) there is a complete line  */
+        /* that will be returned the while () loop below        */
+    }
+
+    while (p_eol == NULL)
+    {
+        if (0 == MAX_AT_RESPONSE - (p_read - s_ATBuffer))
+        {
+            RLOGD("ERROR: Input line exceeded buffer\n");
+            /* ditch buffer and start over again */
+            s_ATBufferCur = s_ATBuffer;
+            *s_ATBufferCur = '\0';
+            p_read = s_ATBuffer;
+        }
+        do {
+            count = read(s_fd, p_read,
+                    MAX_AT_RESPONSE - (p_read - s_ATBuffer));
+        } while (count < 0 && errno == EINTR);
+
+        if (count > 0)
+        {
+            AT_DUMP( "<< ", p_read, count );
+            s_readCount += count;
+
+            p_read[count] = '\0';
+
+            // skip over leading newlines
+            while (*s_ATBufferCur == '\r' || *s_ATBufferCur == '\n')
+                s_ATBufferCur++;
+
+            p_eol = findNextEOL(s_ATBufferCur);
+            p_read += count;
+        }
+        else if (count <= 0)
+        {
+            /* read error encountered or EOF reached */
+            if(count == 0)
+            {
+                RLOGD("atchannel: EOF reached");
+            }
+            else
+            {
+                RLOGD("atchannel: read error %s", strerror(errno));
+            }
+            return NULL;
+        }
+    }
+
+    /* a full line in the buffer. Place a \0 over the \r and return */
+
+    ret = s_ATBufferCur;
+    *p_eol = '\0';
+    s_ATBufferCur = p_eol + 1; /* this will always be <= p_read,    */
+#if 0
+    if(*ret == '>') {
+        *s_ATBufferCur = 'K';
+    }
+#endif
+    /* and there will be a \0 at *p_read */
+    RLOGD("AT< %s\n", ret);
+    return ret;
+}
+
+
+static void onReaderClosed()
+{
+    if (s_onReaderClosed != NULL && s_readerClosed == 0)
+    {
+
+        pthread_mutex_lock(&s_commandmutex);
+
+        s_readerClosed = 1;
+
+        pthread_cond_signal(&s_commandcond);
+
+        pthread_mutex_unlock(&s_commandmutex);
+
+        s_onReaderClosed();
+    }
+}
+
+
+static void *readerLoop(void *arg __unused)
+{
+    for (;;)
+    {
+        const char * line;
+
+        line = readline();
+
+        if (line == NULL)
+        {
+            break;
+        }
+
+        if(isSMSUnsolicited(line))
+        {
+            char *line1;
+            const char *line2;
+
+            // The scope of string returned by 'readline()' is valid only
+            // till next call to 'readline()' hence making a copy of line
+            // before calling readline again.
+            line1 = strdup(line);
+            line2 = readline();
+
+            if (line2 == NULL)
+            {
+                break;
+            }
+
+            if (s_unsolHandler != NULL)
+            {
+                s_unsolHandler (line1, line2);
+            }
+            free(line1);
+        }
+        else
+        {
+            processLine(line);
+        }
+
+#if   0
+        if (s_ackPowerIoctl > 0)
+        {
+            /* acknowledge that bytes have been read and processed */
+            ioctl(s_fd, OMAP_CSMI_TTY_ACK, &s_readCount);
+            s_readCount = 0;
+        }
+#endif /*HAVE_ANDROID_OS*/
+    }
+
+    onReaderClosed();
+
+    return NULL;
+}
+
+static int writedialline(int fd, const char * s)
+{
+    size_t cur = 0;
+    size_t len = strlen(s);
+    ssize_t written;
+
+    if (fd < 0 ) {
+        return AT_ERROR_CHANNEL_CLOSED;
+    }
+
+    /* the main string */
+    while (cur < len) {
+        do {
+            written = write (fd, s + cur, len - cur);
+        } while (written < 0 && errno == EINTR);
+
+        if (written < 0) {
+            return AT_ERROR_GENERIC;
+        }
+        cur += written;
+    }
+
+    /* the \r  */
+    do {
+        written = write (fd, "\r" , 1);
+    } while (written < 0 && errno == EINTR);
+
+    if (written < 0) {
+        return AT_ERROR_GENERIC;
+    }
+
+    return 0;
+}
+
+int at_send_command_dial(int fd, const char * command)
+{
+    int err;
+    if (0 != pthread_equal(s_tid_reader, pthread_self())) {
+        /* cannot be called from reader thread */
+        return AT_ERROR_INVALID_THREAD;
+    }
+    pthread_mutex_lock(&s_commandmutex);
+
+    err = writedialline(fd, command);
+
+    pthread_mutex_unlock(&s_commandmutex);
+    return err;
+}
+
+
+
+
+/**
+ * Sends string s to the radio with a \r appended.
+ * Returns AT_ERROR_* on error, 0 on success
+ *
+ * This function exists because as of writing, android libc does not
+ * have buffered stdio.
+ */
+static int writeline (const char *s)
+{
+    size_t cur = 0;
+    size_t len = strlen(s);
+    ssize_t written;
+
+    if (s_fd < 0 || s_readerClosed > 0)
+    {
+        return AT_ERROR_CHANNEL_CLOSED;
+    }
+
+    RLOGD("AT> %s\n", s);
+
+    AT_DUMP( ">> ", s, strlen(s) );
+
+    /* the main string */
+    while (cur < len)
+    {
+        do
+        {
+            written = write (s_fd, s + cur, len - cur);
+        }
+        while (written < 0 && errno == EINTR);
+        if (written < 0)
+        {
+            return AT_ERROR_GENERIC;
+        }
+
+        cur += written;
+    }
+
+    /* the \r  */
+
+    do
+    {
+        written = write (s_fd, "\r\n" , 2);
+    }
+    while ((written < 0 && errno == EINTR) || (written == 0));
+
+    if (written < 0)
+    {
+        return AT_ERROR_GENERIC;
+    }
+
+    return 0;
+}
+static int writeCtrlZ (const char *s)
+{
+    size_t cur = 0;
+    size_t len = strlen(s);
+    ssize_t written;
+
+    if (s_fd < 0 || s_readerClosed > 0)
+    {
+        return AT_ERROR_CHANNEL_CLOSED;
+    }
+
+    RLOGD("AT> %s^Z\n", s);
+
+    AT_DUMP( ">* ", s, strlen(s) );
+
+    /* the main string */
+    while (cur < len)
+    {
+        do
+        {
+            written = write (s_fd, s + cur, len - cur);
+        }
+        while (written < 0 && errno == EINTR);
+
+        if (written < 0)
+        {
+            return AT_ERROR_GENERIC;
+        }
+
+        cur += written;
+    }
+
+    /* the ^Z  */
+
+    do
+    {
+        written = write (s_fd, "\032" , 1);
+    }
+    while ((written < 0 && errno == EINTR) || (written == 0));
+
+    if (written < 0)
+    {
+        return AT_ERROR_GENERIC;
+    }
+
+    return 0;
+}
+
+static void clearPendingCommand()
+{
+    if (sp_response != NULL)
+    {
+        at_response_free(sp_response);
+    }
+
+    sp_response = NULL;
+    s_responsePrefix = NULL;
+    s_smsPDU = NULL;
+}
+
+
+/**
+ * Starts AT handler on stream "fd'
+ * returns 0 on success, -1 on error
+ */
+int at_open(int fd, ATUnsolHandler h)
+{
+    int ret;
+    //pthread_t tid;
+    pthread_attr_t attr;
+
+    s_fd = fd;
+    s_unsolHandler = h;
+    s_readerClosed = 0;
+
+    s_responsePrefix = NULL;
+    s_smsPDU = NULL;
+    sp_response = NULL;
+
+    /* Android power control ioctl */
+#ifdef HAVE_ANDROID_OS
+#ifdef OMAP_CSMI_POWER_CONTROL
+    ret = ioctl(fd, OMAP_CSMI_TTY_ENABLE_ACK);
+    if(ret == 0)
+    {
+        int ack_count;
+        int read_count;
+        int old_flags;
+        char sync_buf[256];
+        old_flags = fcntl(fd, F_GETFL, 0);
+        fcntl(fd, F_SETFL, old_flags | O_NONBLOCK);
+        do
+        {
+            ioctl(fd, OMAP_CSMI_TTY_READ_UNACKED, &ack_count);
+            read_count = 0;
+            do
+            {
+                ret = read(fd, sync_buf, sizeof(sync_buf));
+                if(ret > 0)
+                    read_count += ret;
+            }
+            while(ret > 0 || (ret < 0 && errno == EINTR));
+            ioctl(fd, OMAP_CSMI_TTY_ACK, &ack_count);
+        }
+        while(ack_count > 0 || read_count > 0);
+        fcntl(fd, F_SETFL, old_flags);
+        s_readCount = 0;
+        //s_ackPowerIoctl = 1;
+    }
+    else
+        //s_ackPowerIoctl = 0;
+
+#else // OMAP_CSMI_POWER_CONTROL
+   // s_ackPowerIoctl = 0;
+
+#endif // OMAP_CSMI_POWER_CONTROL
+#endif /*HAVE_ANDROID_OS*/
+
+    pthread_attr_init (&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+
+    ret = pthread_create(&s_tid_reader, &attr, readerLoop, &attr);
+
+    if (ret < 0)
+    {
+        perror ("pthread_create");
+        return -1;
+    }
+
+
+    return 0;
+}
+
+/* FIXME is it ok to call this from the reader and the command thread? */
+void at_close()
+{
+    if (s_fd >= 0)
+    {
+        close(s_fd);
+    }
+    s_fd = -1;
+
+    pthread_mutex_lock(&s_commandmutex);
+
+    s_readerClosed = 1;
+
+    pthread_cond_signal(&s_commandcond);
+
+    pthread_mutex_unlock(&s_commandmutex);
+
+    /* the reader thread should eventually die */
+}
+
+static ATResponse * at_response_new()
+{
+    return (ATResponse *) calloc(1, sizeof(ATResponse));
+}
+
+void at_response_free(ATResponse *p_response)
+{
+    ATLine *p_line;
+
+    if (p_response == NULL) return;
+
+    p_line = p_response->p_intermediates;
+
+    while (p_line != NULL)
+    {
+        ATLine *p_toFree;
+
+        p_toFree = p_line;
+        p_line = p_line->p_next;
+
+        free(p_toFree->line);
+        free(p_toFree);
+    }
+
+    free (p_response->finalResponse);
+    free (p_response);
+}
+
+/**
+ * The line reader places the intermediate responses in reverse order
+ * here we flip them back
+ */
+static void reverseIntermediates(ATResponse *p_response)
+{
+    ATLine *pcur,*pnext;
+
+    pcur = p_response->p_intermediates;
+    p_response->p_intermediates = NULL;
+
+    while (pcur != NULL)
+    {
+        pnext = pcur->p_next;
+        pcur->p_next = p_response->p_intermediates;
+        p_response->p_intermediates = pcur;
+        pcur = pnext;
+    }
+}
+
+/**
+ * Internal send_command implementation
+ * Doesn't lock or call the timeout callback
+ *
+ * timeoutMsec == 0 means infinite timeout
+ */
+
+static int at_send_command_full_nolock (const char *command, ATCommandType type,
+        const char *responsePrefix, const char *smspdu,
+        long long timeoutMsec, ATResponse **pp_outResponse)
+{
+    int err = 0, count = 0;
+	int resend_count = 3;
+#ifndef USE_NP
+    struct timespec ts;
+#endif /*USE_NP*/
+    RLOGD("Enter at_send_command_full_nolock: timeoutMsec=%lld\n",timeoutMsec);
+    if(sp_response != NULL)
+    {
+        err = AT_ERROR_COMMAND_PENDING;
+        goto error;
+    }
+retry:
+    err = writeline (command);
+
+    if (err < 0)
+    {
+        goto error;
+    }
+
+    s_type = type;
+    s_responsePrefix = responsePrefix;
+    s_smsPDU = smspdu;
+    sp_response = at_response_new();
+
+#ifndef USE_NP
+    if (timeoutMsec != 0)
+    {
+        setTimespecRelative(&ts, timeoutMsec);
+    }
+#endif /*USE_NP*/
+
+    while (sp_response->finalResponse == NULL && s_readerClosed == 0)
+    {
+        if (timeoutMsec != 0)
+        {
+#ifdef USE_NP
+            err = pthread_cond_timeout_np(&s_commandcond, &s_commandmutex, timeoutMsec);
+#else
+            err = pthread_cond_timedwait(&s_commandcond, &s_commandmutex, &ts);
+#endif /*USE_NP*/
+        }
+        else
+        {
+            err = pthread_cond_wait(&s_commandcond, &s_commandmutex);
+        }
+
+        if (err == ETIMEDOUT)
+        {
+            while(count < resend_count)
+            {
+                err = AT_ERROR_TIMEOUT;
+				RLOGE("send AT command timeout,resending...:%s",command);
+				count++;
+				goto retry;
+            }
+            RLOGD("at_send_command_full_nolock,TIMEOUT:%d\n",strerror(err));
+            err = AT_ERROR_TIMEOUT;
+			//at_send_command("AT+CFUN=15",NULL);
+			//at_close();
+            goto error;
+        }
+    }
+
+    if (pp_outResponse == NULL)
+    {
+        at_response_free(sp_response);
+    }
+    else
+    {
+        /* line reader stores intermediate responses in reverse order */
+        reverseIntermediates(sp_response);
+        *pp_outResponse = sp_response;
+    }
+
+    sp_response = NULL;
+
+    if(s_readerClosed > 0)
+    {
+        err = AT_ERROR_CHANNEL_CLOSED;
+        goto error;
+    }
+
+    err = 0;
+error:
+    clearPendingCommand();
+
+    return err;
+}
+
+/**
+ * Internal send_command implementation
+ *
+ * timeoutMsec == 0 means infinite timeout
+ */
+static int at_send_command_full (const char *command, ATCommandType type,
+        const char *responsePrefix, const char *smspdu,
+        long long timeoutMsec, ATResponse **pp_outResponse)
+{
+    int err;
+
+    if (0 != pthread_equal(s_tid_reader, pthread_self()))
+    {
+        /* cannot be called from reader thread */
+        return AT_ERROR_INVALID_THREAD;
+    }
+
+    //added by zhengjianrong for mutex exception 20190525 begin
+    pthread_mutex_lock(&s_again_commandmutex);
+    //added by zhengjianrong for mutex exception 20190525 begin
+    pthread_mutex_lock(&s_commandmutex);
+
+    err = at_send_command_full_nolock(command, type,
+            responsePrefix, smspdu,
+            timeoutMsec, pp_outResponse);
+
+    pthread_mutex_unlock(&s_commandmutex);
+    //added by zhengjianrong for mutex exception 20190525 begin
+    pthread_mutex_unlock(&s_again_commandmutex);
+    //added by zhengjianrong for mutex exception 20190525 end
+
+    if (err == AT_ERROR_TIMEOUT && s_onTimeout != NULL)
+    {
+        RLOGD("at_send_command_full,===========timeout command:%s\n",command); //added by lisf for debug 20181207
+        s_onTimeout();
+    }
+
+    return err;
+}
+
+
+/**
+ * Issue a single normal AT command with no intermediate response expected
+ *
+ * "command" should not include \r
+ * pp_outResponse can be NULL
+ *
+ * if non-NULL, the resulting ATResponse * must be eventually freed with
+ * at_response_free
+ */
+int at_send_command (const char *command, ATResponse **pp_outResponse)
+{
+    int err;
+    //sleep(1);
+    err = at_send_command_full (command, NO_RESULT, NULL,
+            NULL, ATSEND_TIMEOUT_MSEC, pp_outResponse);
+
+    return err;
+}
+
+// <!--added by wangmengying@2017.12.13 for function declaration
+int at_send_command_timeout (const char *command, ATResponse **pp_outResponse, long long timeout)
+{
+    int err;
+    err = at_send_command_full (command, NO_RESULT, NULL,
+                                    NULL, timeout, pp_outResponse);//NULL, 0, pp_outResponse);
+    return err;
+}
+// end-->
+
+int at_send_command_singleline (const char *command,
+        const char *responsePrefix,
+        ATResponse **pp_outResponse)
+{
+    int err;
+    //sleep(1);
+    err = at_send_command_full (command, SINGLELINE, responsePrefix,
+            NULL, ATSEND_TIMEOUT_MSEC, pp_outResponse);
+
+    if (err == 0 && pp_outResponse != NULL
+            && (*pp_outResponse)->success > 0
+            && (*pp_outResponse)->p_intermediates == NULL
+       )
+    {
+        /* successful command must have an intermediate response */
+        at_response_free(*pp_outResponse);
+        *pp_outResponse = NULL;
+        return AT_ERROR_INVALID_RESPONSE;
+    }
+
+    return err;
+}
+
+
+int at_send_command_numeric (const char *command,
+        ATResponse **pp_outResponse)
+{
+    int err;
+
+    err = at_send_command_full (command, NUMERIC, NULL,
+            NULL, NUMERIC_AT_TIMEOUT_MSEC, pp_outResponse);
+
+    if (err == 0 && pp_outResponse != NULL
+            && (*pp_outResponse)->success > 0
+            && (*pp_outResponse)->p_intermediates == NULL
+       )
+    {
+        /* successful command must have an intermediate response */
+        at_response_free(*pp_outResponse);
+        *pp_outResponse = NULL;
+        return AT_ERROR_INVALID_RESPONSE;
+    }
+
+    return err;
+}
+// <!--[ODM]lindong@2017.11.24 for manual select network
+int at_send_command_singleline_timeout (const char *command,
+        const char *responsePrefix, long long timeoutMsec,
+        ATResponse **pp_outResponse)
+{
+    int err;
+
+    err = at_send_command_full (command, SINGLELINE, responsePrefix,
+            NULL, timeoutMsec, pp_outResponse);
+
+    if (err == 0 && pp_outResponse != NULL
+            && (*pp_outResponse)->success > 0
+            && (*pp_outResponse)->p_intermediates == NULL
+       )
+    {
+        /* successful command must have an intermediate response */
+        at_response_free(*pp_outResponse);
+        *pp_outResponse = NULL;
+        return AT_ERROR_INVALID_RESPONSE;
+    }
+
+    return err;
+}
+// end-->
+
+int at_send_command_sms (const char *command,
+        const char *pdu,
+        const char *responsePrefix,
+        ATResponse **pp_outResponse)
+{
+    int err;
+// <!--[ODM]wangmengying@2019.8.31 [bug29064]send SMS at command timeout
+    err = at_send_command_full (command, SINGLELINE, responsePrefix,
+            pdu, SMS_AT_TIMEOUT_MSEC, pp_outResponse);
+// end-->
+
+    if (err == 0 && pp_outResponse != NULL
+            && (*pp_outResponse)->success > 0
+            && (*pp_outResponse)->p_intermediates == NULL
+       )
+    {
+        /* successful command must have an intermediate response */
+        at_response_free(*pp_outResponse);
+        *pp_outResponse = NULL;
+        return AT_ERROR_INVALID_RESPONSE;
+    }
+
+    return err;
+}
+
+
+int at_send_command_multiline (const char *command,
+        const char *responsePrefix,
+        ATResponse **pp_outResponse)
+{
+    int err;
+
+    err = at_send_command_full (command, MULTILINE, responsePrefix,
+            NULL, ATSEND_TIMEOUT_MSEC, pp_outResponse);
+
+    return err;
+}
+
+int at_send_command_multiline_timeout (const char *command,
+        const char *responsePrefix, long long timeoutMsec,
+        ATResponse **pp_outResponse)
+{
+    int err;
+
+    err = at_send_command_full (command, MULTILINE, responsePrefix,
+            NULL, timeoutMsec, pp_outResponse);
+
+    return err;
+}
+
+
+/** This callback is invoked on the command thread */
+void at_set_on_timeout(void (*onTimeout)(void))
+{
+    s_onTimeout = onTimeout;
+}
+
+/**
+ *  This callback is invoked on the reader thread (like ATUnsolHandler)
+ *  when the input stream closes before you call at_close
+ *  (not when you call at_close())
+ *  You should still call at_close()
+ */
+
+void at_set_on_reader_closed(void (*onClose)(void))
+{
+    s_onReaderClosed = onClose;
+}
+
+#define HANDSHAKE_SLEEP_MSEC 3000
+/**
+ * Periodically issue an AT command and wait for a response.
+ * Used to ensure channel has start up and is active
+ */
+
+int at_handshake()
+{
+    int i;
+    int err = 0;
+
+    ENTER_FUNC;
+    if (0 != pthread_equal(s_tid_reader, pthread_self()))
+    {
+        /* cannot be called from reader thread */
+        return AT_ERROR_INVALID_THREAD;
+    }
+    //<!--Added by Wujiabao in 2022/04/20 to protect write
+    pthread_mutex_lock(&s_again_commandmutex);
+    //!---->
+
+    pthread_mutex_lock(&s_commandmutex);
+
+    for (i = 0 ; i < HANDSHAKE_RETRY_COUNT ; i++)
+    {
+        /* some stacks start with verbose off */
+
+        err = at_send_command_full_nolock ("ATE0Q0V1", SINGLELINE,
+                "ATE0Q0V1", NULL, HANDSHAKE_TIMEOUT_MSEC, NULL);
+
+
+        if (err == 0)
+        {
+            break;
+        }
+    }
+
+    if (err == 0)
+    {
+        /* pause for a bit to let the input buffer drain any unmatched OK's
+           (they will appear as extraneous unsolicited responses) */
+        RLOGD("Start sleep for %d seconds.", HANDSHAKE_SLEEP_MSEC / 1000);
+        sleepMsec(HANDSHAKE_SLEEP_MSEC);
+        RLOGD("End sleep for %d seconds.", HANDSHAKE_SLEEP_MSEC / 1000);
+    }
+
+    pthread_mutex_unlock(&s_commandmutex);
+
+    //<!--Added by Wujiabao in 2022/04/20 to protect write
+    pthread_mutex_unlock(&s_again_commandmutex);
+    //!---->
+
+    LEAVE_FUNC;
+    return err;
+}
+
+/**
+ * Returns error code from response
+ * Assumes AT+CMEE=1 (numeric) mode
+ */
+AT_CME_Error at_get_cme_error(const ATResponse *p_response)
+{
+    int ret;
+    int err;
+    char *p_cur;
+
+    if (p_response->success > 0)
+    {
+        return CME_SUCCESS;
+    }
+
+    if (p_response->finalResponse == NULL
+            || !strStartsWith(p_response->finalResponse, "+CME ERROR:")
+       )
+    {
+        return CME_ERROR_NON_CME;
+    }
+
+    p_cur = p_response->finalResponse;
+    err = at_tok_start(&p_cur);
+
+    if (err < 0)
+    {
+        return CME_ERROR_NON_CME;
+    }
+
+    err = at_tok_nextint(&p_cur, &ret);
+
+    if (err < 0)
+    {
+        return CME_ERROR_NON_CME;
+    }
+
+    return (AT_CME_Error) ret;
+}
+
diff --git a/hardware/ril/youyou_ril/atchannel.h b/hardware/ril/youyou_ril/atchannel.h
new file mode 100755
index 0000000..f766390
--- /dev/null
+++ b/hardware/ril/youyou_ril/atchannel.h
@@ -0,0 +1,154 @@
+/* //device/system/reference-ril/atchannel.h
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+/*when who why modified*/
+
+#ifndef ATCHANNEL_H
+#define ATCHANNEL_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* define AT_DEBUG to send AT traffic to /tmp/radio-at.log" */
+#define AT_DEBUG  0
+
+#if AT_DEBUG
+extern void  AT_DUMP(const char* prefix, const char*  buff, int  len);
+#else
+#define  AT_DUMP(prefix,buff,len)  do{}while(0)
+#endif
+
+#define AT_ERROR_GENERIC -1
+#define AT_ERROR_COMMAND_PENDING -2
+#define AT_ERROR_CHANNEL_CLOSED -3
+#define AT_ERROR_TIMEOUT -4
+#define AT_ERROR_INVALID_THREAD -5 /* AT commands may not be issued from
+                                       reader thread (or unsolicited response
+                                       callback */
+#define AT_ERROR_INVALID_RESPONSE -6 /* eg an at_send_command_singleline that
+                                        did not get back an intermediate
+                                        response */
+// <!--added by wangmengying@2018.8.1 for at send command timeout
+#define ATSEND_TIMEOUT_MSEC 10000
+// end--!>
+// <!--[ODM]lindong@2017.11.24 for manual select network
+#define QUERY_NETWORK_TIMEOUT 300000
+// --!>
+// <!--[ODM]wangmengying@2019.8.31 [bug29064]send SMS at command timeout
+#define SMS_AT_TIMEOUT_MSEC 30000
+// end-->
+
+/*BEGIN: Added by wujiabao in 2022/05/31, and used to set at_send_command_numeric() function timeout to non-0 to prevent RIL dump*/
+#define NUMERIC_AT_TIMEOUT_MSEC 3000
+/*END:   Added by wujiabao in 2022/05/31, and used to set at_send_command_numeric() function timeout to non-0 to prevent RIL dump*/
+
+
+typedef enum {
+    NO_RESULT,   /* no intermediate response expected */
+    NUMERIC,     /* a single intermediate response starting with a 0-9 */
+    SINGLELINE,  /* a single intermediate response starting with a prefix */
+    MULTILINE    /* multiple line intermediate response
+                    starting with a prefix */
+} ATCommandType;
+
+/** a singly-lined list of intermediate responses */
+typedef struct ATLine  {
+    struct ATLine *p_next;
+    char *line;
+} ATLine;
+
+/** Free this with at_response_free() */
+typedef struct {
+    int success;              /* true if final response indicates
+                                    success (eg "OK") */
+    char *finalResponse;      /* eg OK, ERROR */
+    ATLine  *p_intermediates; /* any intermediate responses */
+} ATResponse;
+
+/**
+ * a user-provided unsolicited response handler function
+ * this will be called from the reader thread, so do not block
+ * "s" is the line, and "sms_pdu" is either NULL or the PDU response
+ * for multi-line TS 27.005 SMS PDU responses (eg +CMT:)
+ */
+typedef void (*ATUnsolHandler)(const char *s, const char *sms_pdu);
+
+int at_open(int fd, ATUnsolHandler h);
+void at_close();
+
+/* This callback is invoked on the command thread.
+   You should reset or handshake here to avoid getting out of sync */
+void at_set_on_timeout(void (*onTimeout)(void));
+/* This callback is invoked on the reader thread (like ATUnsolHandler)
+   when the input stream closes before you call at_close
+   (not when you call at_close())
+   You should still call at_close()
+   It may also be invoked immediately from the current thread if the read
+   channel is already closed */
+void at_set_on_reader_closed(void (*onClose)(void));
+
+int at_send_command_singleline (const char *command,
+                                const char *responsePrefix,
+                                 ATResponse **pp_outResponse);
+
+// <!--[ODM]lindong@2017.11.24 for manual select network
+int at_send_command_singleline_timeout (const char *command,
+                                        const char *responsePrefix,
+                                        long long timeoutMsec,
+                                        ATResponse **pp_outResponse);
+// --!>
+
+int at_send_command_numeric (const char *command,
+                                 ATResponse **pp_outResponse);
+
+int at_send_command_multiline (const char *command,
+                                const char *responsePrefix,
+                                 ATResponse **pp_outResponse);
+
+int at_send_command_multiline_timeout (const char *command,
+        const char *responsePrefix, long long timeoutMsec,
+        ATResponse **pp_outResponse);
+
+
+
+int at_handshake();
+
+int at_send_command (const char *command, ATResponse **pp_outResponse);
+// <!--added by wangmengying@2017.12.13 for function declaration
+int at_send_command_timeout (const char *command, ATResponse **pp_outResponse, long long timeout);
+// end-->
+int at_send_command_sms (const char *command, const char *pdu,
+                            const char *responsePrefix,
+                            ATResponse **pp_outResponse);
+
+void at_response_free(ATResponse *p_response);
+
+typedef enum {
+    CME_ERROR_NON_CME = -1,
+    CME_SUCCESS = 0,
+    CME_SIM_NOT_INSERTED = 10,
+    SIGNAL_QCDATACARD_SIM_NOT_INSERTED=13
+} AT_CME_Error;
+
+AT_CME_Error at_get_cme_error(const ATResponse *p_response);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*ATCHANNEL_H*/
diff --git a/hardware/ril/youyou_ril/fibo_ping.c b/hardware/ril/youyou_ril/fibo_ping.c
new file mode 100755
index 0000000..a920ed7
--- /dev/null
+++ b/hardware/ril/youyou_ril/fibo_ping.c
@@ -0,0 +1,231 @@
+/*************************************************************************
+    Copyright (C)2015-2017 Fibocom Wireless Inc. All rights reserved
+     File Name: pingtimer.c
+     Author: LiuQiFeng
+     Mail: liuqf@fibocom.com
+     Created Time: Thu 25 Jan 2018 09:29:46 PM
+     History:
+     Date        Author       Comment:
+     --------------------------------------------------------------------
+                 LiuQiFeng
+ ************************************************************************/
+
+#include<stdio.h>
+#include<errno.h>
+#include "fibo_ping.h"
+
+int go_ping()
+{
+        int i = 0;
+        while(i < ping_retry)
+        {
+                pid_t pid;
+                if ((pid = vfork()) < 0)
+                {
+                        RLOGD("vfork error");
+                        exit(1);
+                }
+                else if (pid == 0)
+                {
+                        if ( execlp("ping", "ping", ping_args , ping_url, (char*)0) < 0)
+                        {
+                                RLOGD("execlp error\n");
+                                exit(1);
+                        }
+                }
+
+                int stat;
+                waitpid(pid, &stat, 0);
+
+                if (stat == 0)
+                {
+                        return 0;
+                }
+                sleep(3);
+                i++;
+        }
+        return -1;
+}
+
+static char *get_from_shell(char *shell_cmd)
+{
+    FILE *fstream=NULL;
+    char buff[1024];
+    static char cmd[1024];
+    int i = 0;
+    int j = 0;
+    memset(buff,0,sizeof(buff));
+    memset(cmd,0,sizeof(cmd));
+
+    if(NULL==(fstream=popen(shell_cmd,"r")))
+    {
+        RLOGD("execute command failed: %s",strerror(errno));
+        return NULL;
+    }
+
+    if(NULL!=fgets(buff, sizeof(buff), fstream))
+    {
+        // printf("%s",buff);
+    }
+    else
+    {
+        pclose(fstream);
+        return NULL;
+    }
+
+    pclose(fstream);
+    for (i = 0; i <= strlen(buff); i++)
+    {
+        if ('\n' == buff[i])
+        {
+            break;
+        }
+        else
+        {
+            if ('\t' == buff[i])
+            {
+                return cmd;
+            }
+            cmd[j] = buff[i];
+            j++;
+        }
+    }
+    return cmd;
+}
+
+void g_on_timer(int sig)
+{
+    int ret ;
+    char *date = NULL;
+    char *cmd = NULL;
+
+    date = get_from_shell("date +%Y_%m_%d_%H_%M_%S");
+    RLOGD("[fibo_ping] try to ping %s...", ping_url);
+    ret = go_ping();
+    if (ret == 0)
+    {
+        fibocom_pingcounter = 0;
+        RLOGD("[fibo_ping] ping %s success! date:%s, and set counter to 0!", ping_url, date);
+    }
+    else if (ret == -1)
+    {
+        //TODO: Added commands for querying information about CPIN, COPS, CSQ, CGDCONT, and GTRNDIS
+        fibocom_pingcounter ++;
+        RLOGD("[fibo_ping] ping %s failed! date:%s, failure_counter:%d/%d", ping_url, date, fibocom_pingcounter, RESTART_THRESHOLD);
+        if (fibocom_pingcounter == RESTART_THRESHOLD)
+        {
+            #if 1
+            RLOGD("[fibo_ping] The number of failures has reached %d. The module will be restarted!", RESTART_THRESHOLD);
+
+            at_send_command("AT+CFUN=15", NULL);
+            fibocom_pingflag = 0;
+            fibocom_pingcounter = 0;
+
+            #else
+            asprintf(&cmd, "echo \"%s\" >> /data/pingfile", date);
+            fibocom_pingcounter = 0;
+            system("/system/bin/reboot");
+            system(cmd);
+            free(cmd);
+            #endif
+        }
+        else
+        {
+            #if 0
+            system("/system/bin/svc data disable");
+            asprintf(&cmd, "echo \"%s\"+%d >> /data/pingfile", date,fibocom_pingcounter);
+            system(cmd);
+            free(cmd);
+            RLOGD("[%d] fibocom_data disable\r\n",__func__);
+            #endif
+        }
+    }
+    return;
+}
+
+void get_ping_args()
+{
+    int ret;
+    char *ping_str = NULL;
+
+    ping_str = (char *)malloc(sizeof(char) * KEYVALLEN);
+    ret = getProfileString("PING", "PINGARGS", ping_str, "-c 1 -W 10 -s 4");
+
+    if(!strncmp(ping_str, "ping", strlen("ping")))
+    {
+        RLOGD("ping_str start with 'ping', so remove 'ping'!");
+        ping_str += 4;
+    }
+    l_trim(ping_args, ping_str);
+
+    ret = getProfileString("PING", "PINGURL", ping_url, "www.fibocom.com");
+
+    RLOGD("ping_args:%s", ping_args);
+    RLOGD("ping_url:%s",  ping_url);
+}
+
+void pingLoop()
+{
+    RLOGD("[%s,%d] E", __FUNCTION__, __LINE__);
+    static int round = 0;
+
+    ping_retry    = getProfileInt32("PING", "PINGRETRY", 1);
+    ping_interval = getProfileInt32("PING", "PINGINTERVAL", 60);
+    RLOGD("[%s,%d] ping_interval:%d, ping_retry:%d", __FUNCTION__, __LINE__, ping_interval, ping_retry);
+
+    get_ping_args();
+
+    for(;;)
+    {
+        RLOGD("[fibo_ping] [%s,%d] fibocom_pingflag:%d", __FUNCTION__, __LINE__, fibocom_pingflag);
+        if(fibocom_pingflag)
+        {
+            RLOGD("[fibo_ping] Round %d", round++);
+            g_on_timer(0);
+        }
+
+        sleep(ping_interval);
+    }
+
+    RLOGD("[%s,%d] X", __FUNCTION__, __LINE__);
+}
+
+void fibocom_start_timer()
+{
+    if (fibocom_pingflag == 0)
+    {
+        signal(SIGALRM, g_on_timer);
+#if 0
+        g_tmval.it_value.tv_sec = TIMER10*60;
+#else
+        g_tmval.it_value.tv_sec = TIMER5*30;
+#endif
+        g_tmval.it_value.tv_usec = 0;
+        g_tmval.it_interval = g_tmval.it_value;
+        setitimer(ITIMER_REAL, &g_tmval, NULL);
+        fibocom_pingflag = 1;
+        RLOGD("%s: start first timer after fiveMinutes will reboot ended[%d]####",__func__,fibocom_pingflag);
+    }
+}
+
+void fibocom_new_timer(int tv_sec)
+{
+    g_tmval.it_value.tv_sec = tv_sec*60;
+    g_tmval.it_value.tv_usec = 0;
+    g_tmval.it_interval = g_tmval.it_value;
+    setitimer(ITIMER_REAL, &g_tmval, NULL);
+    fibocom_pingflag = 0;
+    fibocom_pingcounter = 0;
+    RLOGD("%s: create a new timer!####",__func__);
+}
+
+void fibocom_stop_timer()
+{
+    g_tmval.it_value.tv_sec = 0;
+    g_tmval.it_value.tv_usec = 0;
+    g_tmval.it_interval = g_tmval.it_value;
+    setitimer(ITIMER_REAL, &g_tmval, NULL);
+    fibocom_pingflag = 0;
+    fibocom_pingcounter = 0;
+    RLOGD("%s: stop all timers[%d]####",__func__,fibocom_pingflag);
+}
diff --git a/hardware/ril/youyou_ril/fibo_ping.h b/hardware/ril/youyou_ril/fibo_ping.h
new file mode 100755
index 0000000..4f298a7
--- /dev/null
+++ b/hardware/ril/youyou_ril/fibo_ping.h
@@ -0,0 +1,35 @@
+/*************************************************************************
+    Copyright (C)2015-2017 Fibocom Wireless Inc. All rights reserved
+     File Name: pingtimer.h
+     Author: LiuQiFeng
+     Mail: liuqf@fibocom.com
+     Created Time: Thu 25 Jan 2018 09:40:41 PM
+     History:
+     Date        Author       Comment:
+     --------------------------------------------------------------------
+                 LiuQiFeng
+ ************************************************************************/
+#define LOG_TAG GHT_RIL
+#include <utils/Log.h>
+#include "ril_common.h"
+#include "other_function.h"
+
+struct itimerval g_tmval;
+int fibocom_pingcounter = 0;
+int fibocom_pingflag = 0;
+#define TIMER5    2
+#define TIMER10  10
+#define TIMER20  20
+#define TIMER40  40
+#define TIMER60  60
+
+int ping_retry = 1;
+int ping_interval = 60;
+char ping_args[KEYVALLEN] = {0};
+char ping_url[KEYVALLEN]  = {0};
+
+#define RESTART_THRESHOLD 3
+void fibocom_start_timer();
+void fibocom_new_timer(int tv_sec);
+void fibocom_stop_timer();
+
diff --git a/hardware/ril/youyou_ril/getdevinfo.c b/hardware/ril/youyou_ril/getdevinfo.c
new file mode 100755
index 0000000..fdeff87
--- /dev/null
+++ b/hardware/ril/youyou_ril/getdevinfo.c
@@ -0,0 +1,601 @@
+/******************************************************************************
+  Copyright (C), 2019, Shenzhen G&T Industrial Development Co., Ltd
+
+  File:      getdevinof.c
+
+  Author:  Fibocom-diego
+  Version: 1.0
+  Date:  2019.04
+
+  Description:   getdevinfo APIs
+
+** History:
+**Author (core ID)                Date          Number     Description of Changes
+**-----------------------------------------------------------------------------
+** NODECOM-Aron                30-10-2018         **   init version getdevinfo detect_usb_device
+** FIBOCOM-diego               14-04-2019         **   add General Function getUsbPortInfo
+** -----------------------------------------------------------------------------
+******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <fcntl.h>
+
+#define LOG_TAG GHT_RIL
+#include <utils/Log.h>
+
+#include<sys/types.h>
+#include <unistd.h>
+#include <ril_common.h>
+
+#include "getdevinfo.h"
+#include <sys/stat.h>
+#include <cutils/properties.h>
+
+#define TTY_NAME "ttyUSB"
+#define SYS_USB_ROOT_DIR "/sys/bus/usb/devices/"
+#define IDPRODUCT_FILE "idProduct"
+#define AL_PID 0x1001
+//added for NL678
+#define AL_PID_NL678 0x0104
+//added for NL678-E-00
+//add by zhengjianrong for MA510 Ril begin
+#define AL_PID_MA510 0x0106
+//add by zhengjianrong for MA510 Ril end
+#define AL_PID_L610 0x4d10
+
+#define AL_PID_FG621 0x0a04
+
+extern product_model mode_flag;
+static int readfile(char *pathname, char* buffer,  int size);
+static int getfirstinterfacename(char*dir,char*ifname);
+static int readinterfaceinfo(char *pathname,char *class, char *subclass, char *protocol);
+static int reversefind(const char *str, char ch);
+static int get_net_mode();
+static int get_channels(char *atchannel, char *datachannel);
+static int get_devinfo(char *dir,char *vid);
+extern int detect_usb_device(char *atchannel, char *datachannel);
+
+char interface_name[256];
+
+
+struct interfaceinfo
+{
+    char ifclass[4];
+    char ifsubclass[4];
+    char ifprotocol[4];
+};
+
+struct deviceinfo
+{
+    char vid[6];
+    char pid[6];
+    char atchannel[15];
+    char datachannel[15];
+    int mode;
+};
+
+//<!-- build 32/64 by caogang@20171025
+struct deviceinfo deviceinfotable[]=
+{
+    {"1508", "1001", "/dev/ttyUSB1", "/dev/ttyUSB2", 0},
+  //added for NL678		
+    {"2cb7", "0104", "/dev/ttyUSB1", "/dev/ttyUSB2", 0},		
+//    {NULL, NULL, NULL, NULL, 0}
+    {"\0", "\0", "\0", "\0", 0}
+};
+
+//struct deviceinfo mydevinfo = {0};
+struct deviceinfo mydevinfo = {"\0", "\0", "\0", "\0", 0};
+//end -->
+
+static int readfile(char *pathname, char* buffer, int size)
+{
+    int fd;
+    int count=0;
+
+    if(buffer==NULL)
+    {
+        return 0;
+    }
+    if(pathname==NULL)
+        return 0;
+    if((fd=open(pathname,O_RDONLY))==-1)
+    {
+        return 0;
+    }
+    count=read(fd,buffer,size);
+    close(fd);
+    return 1;
+}
+
+static int getfirstinterfacename(char*dir, char*ifname)
+{
+    DIR* dp=NULL;
+    struct dirent *filename;
+    char subdir[10];
+    int index;
+
+    dp = opendir(dir);
+    if(dp == NULL)
+    {
+        RLOGD("Opendir %s failed!", dir);
+        return 0;
+    }
+    index = reversefind(dir, '/');
+    memcpy(subdir, dir+index+1, strlen(dir)-index);
+    //RLOGD("subdir = %s\n", subdir);
+
+    while((filename=readdir(dp))!=NULL)
+    {
+        //RLOGD("filename:%s\n",filename->d_name);
+        if(strstr(filename->d_name, subdir) != NULL)
+        {
+            memcpy(ifname, filename->d_name, strlen(filename->d_name)+1);
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static int readinterfaceinfo(char *pathname,char *class, char *subclass, char *protocol)
+{
+    char filename[256];
+    char tmp[20];
+
+    memset(filename, 0, 256);
+    strcat(filename, pathname);
+    strcat(filename, "/bInterfaceClass");
+    readfile(filename, tmp, 2);
+    tmp[2] = 0;
+    memcpy(class, tmp, 3);
+
+    memset(filename, 0, 256);
+    strcat(filename, pathname);
+    strcat(filename, "/bInterfaceSubClass");
+    readfile(filename, tmp, 2);
+    tmp[2] = 0;
+    memcpy(subclass, tmp, 3);
+
+    memset(filename, 0, 256);
+    strcat(filename, pathname);
+    strcat(filename, "/bInterfaceProtocol");
+    readfile(filename, tmp, 2);
+    tmp[2] = 0;
+    memcpy(protocol, tmp, 3);
+
+    return 0;
+}
+
+static int reversefind(const char *str, char ch)
+{
+    int i, len;
+
+    len = strlen(str);
+    for(i=len-1; i>=0; i--)
+    {
+        if(str[i] == ch)
+        {
+            return i;
+        }
+    }
+
+    return -1;
+}
+
+int getdevinfors(char *vid, char *pid, char *atchannel, char *datachannel, int *mode)
+{
+    char dir[] = "/sys/bus/usb/devices";
+    int ret;
+    vid;
+    *mode = 0;
+    //modify for NL678
+    if (mode_flag <GHT_NL678_E)
+    {
+    	   sprintf(pid, "1001");
+    }
+    else if(mode_flag == GHT_NL678_E)
+    {
+     	   sprintf(pid, "0104");
+    }
+    detect_usb_device(atchannel,datachannel);
+
+    return 1;
+}
+
+int detect_usb_device(char *atchannel, char *datachannel)
+{
+    DIR *dp=NULL,*dp2=NULL,*dp3=NULL;
+    int fd;
+    struct dirent *root_entry;
+    struct dirent *sec_entry;
+    struct dirent *third_entry;
+    char buf[256];
+    char tty_at_name[16];
+    char tty_modem_name[16];
+    char cur_atchannel[15];
+    char cur_datachannel[15];
+    int tty_number;
+    int product_id = 0;
+    char *current_dir_ptr = NULL;
+    char current_dir[128];
+
+    dp = opendir(SYS_USB_ROOT_DIR);
+    if(!dp)
+    {
+        RLOGD("open sys dir fail");
+        return 0;
+    }
+    chdir(SYS_USB_ROOT_DIR);
+    current_dir_ptr = getcwd(current_dir,128);
+    while((root_entry = readdir(dp)) != NULL)
+    {
+        if((strcmp(".",root_entry->d_name) == 0) ||
+                (strcmp("..",root_entry->d_name) == 0))
+        {
+            continue;
+        }
+        chdir(root_entry->d_name);
+        if(access(IDPRODUCT_FILE,F_OK) == 0)
+        {
+            fd = open(IDPRODUCT_FILE,O_RDONLY);
+            memset(buf,0,sizeof(buf));
+            read(fd,buf,4);
+            close(fd);
+            product_id = strtol(buf,NULL,16);
+            RLOGD("Read result:buf->%s,product_id=0x%04x",buf,product_id);
+            if(AL_PID == product_id || product_id == AL_PID_NL678 || product_id == AL_PID_MA510 
+                    || product_id == AL_PID_L610 || product_id == AL_PID_FG621)
+            {
+                sprintf(tty_at_name,"%s:1.2",root_entry->d_name);
+                sprintf(tty_modem_name,"%s:1.1",root_entry->d_name);
+                chdir(tty_at_name);
+                current_dir_ptr = getcwd(current_dir,128);
+                dp2 = opendir(current_dir);
+                if(!dp2)
+                {
+                    RLOGD("open sys dir fail");
+                    if(dp)
+                        closedir(dp);
+                    return 0;
+                }
+                while((sec_entry = readdir(dp2)) != NULL)
+                {
+                    if(strncmp(sec_entry->d_name,TTY_NAME,6) == 0)
+                    {
+                        memcpy(cur_atchannel,sec_entry->d_name,14);
+                        sprintf(atchannel,"/dev/%s",cur_atchannel);
+                    }
+                }
+                chdir(SYS_USB_ROOT_DIR);
+                chdir(root_entry->d_name);
+                chdir(tty_modem_name);
+                current_dir_ptr = getcwd(current_dir,128);
+                dp3 = opendir(current_dir);
+                if(!dp3)
+                {
+                    RLOGD("open sys dir fail");
+                    if(dp)
+                        closedir(dp);
+                    if(dp2)
+                        closedir(dp2);
+                    return 0;
+                }
+                while((third_entry = readdir(dp3)) != NULL)
+                {
+                    if(strncmp(third_entry->d_name,TTY_NAME,6) == 0)
+                    {
+                        memcpy(cur_datachannel,third_entry->d_name,14);
+                        sprintf(datachannel,"/dev/%s",cur_datachannel);
+                    }
+                }
+
+            }
+            else
+            {
+                //added for NL678-E-00
+                if (mode_flag <GHT_NL678_E)
+   		 {
+               RLOGD("pid is not 0x1001");
+              }
+		 else if(mode_flag == GHT_NL678_E)
+		 {
+		       RLOGD("pid is not 0x0104");
+		 }
+		 else if(mode_flag == GHT_MA510_GL)
+		 {
+		       RLOGD("pid is not 0x0106");
+		 }
+                chdir(SYS_USB_ROOT_DIR);
+                continue;
+            }
+        }
+        chdir(SYS_USB_ROOT_DIR);
+    }
+    if(dp)
+        closedir(dp);
+    if(dp2)
+        closedir(dp2);
+    if(dp3)
+        closedir(dp3);
+    RLOGD("atchannel=%s,datachannel=%s",atchannel,datachannel);
+    return 1;
+
+}
+
+
+/*
+ *  diego add for fuctions campaticability M910
+ *
+ */
+static const struct fibo_module_info * fibo_get_module_info(char *idVendor, char *idProduct){
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(fibo_module_info_table); i++){
+        if (!strncasecmp(fibo_module_info_table[i].idVendor, idVendor, USBID_LEN) \
+            && !strncasecmp(fibo_module_info_table[i].idProduct, idProduct, USBID_LEN))
+        {
+            return &fibo_module_info_table[i];
+        }
+    }
+    return NULL;
+}
+
+static int fibo_get_usb_device_info(struct fibo_usb_device_info *device_info)
+{
+    int fd;
+    int ret = -1;
+    DIR *pDir = NULL;
+    struct dirent *ent;
+    struct stat statbuf;
+    const char *dir = "/sys/bus/usb/devices";
+    char filename[MAX_PATH] ={0};
+    struct fibo_usb_device_info usb_device_info;
+    struct fibo_module_info *module_info = NULL;
+
+    if ((pDir = opendir(dir)) == NULL){
+        RLOGE("Cannot open directory:%s/", dir);
+        goto done;
+    }
+
+    memset(&usb_device_info,0,sizeof(struct fibo_usb_device_info));
+
+    while((ent = readdir(pDir)) != NULL){
+        sprintf(filename, "%s/%s",dir,ent->d_name);
+        //RLOGD("fibo_get_usb_device_info file path:%s ",filename);
+        lstat(filename, &statbuf);
+        if (S_ISLNK(statbuf.st_mode)) {
+            char idVendor[USBID_LEN+1] = {0};
+            char idProduct[USBID_LEN+1] = {0};
+
+            sprintf(filename, "%s/%s/idVendor", dir, ent->d_name);
+            //RLOGD("fibo_get_usb_device_info idVendor file path:%s ",filename);
+            fd = open(filename, O_RDONLY);
+            if (fd > 0) {
+                read(fd, idVendor, USBID_LEN);
+                //RLOGD("found idVendor in : %s  idVendor : %s",filename,idVendor);
+                close(fd);
+            }
+            sprintf(filename, "%s/%s/idProduct", dir, ent->d_name);
+            //RLOGD("fibo_get_usb_device_info idProduct file path:%s ",filename);
+            fd = open(filename, O_RDONLY);
+            if (fd > 0) {
+                read(fd, idProduct, USBID_LEN);
+                //RLOGD("found idProduct in : %s  idProduct : %s",filename,idProduct);
+                close(fd);
+            }
+            module_info = fibo_get_module_info(idVendor,idProduct);
+            if(module_info == NULL){
+                continue;
+            }
+            ret = 0;
+            RLOGD("find fibocom module idVendor:[%s] idProduct:[%s]",idVendor,idProduct);
+            usb_device_info.module_info = module_info;
+            snprintf(usb_device_info.usbdevice_pah, sizeof(usb_device_info.usbdevice_pah), "%s/%s", dir, ent->d_name);
+            RLOGD("usb_device_info.usbdevice_path:[%s]",usb_device_info.usbdevice_pah);
+            memcpy(device_info, &usb_device_info, sizeof(struct fibo_usb_device_info));
+
+            break;        //The program exits the loop as soon as it finds our module
+        }
+    }
+
+done:
+    closedir(pDir);
+    return ret;
+}
+
+static int fibo_find_ttyname(int usb_interface, const char *usbdevice_pah, char *out_ttyname, char *ttyname)
+{
+    int ret = -1, current_usbmode;
+    DIR *pDir;
+    struct dirent* ent = NULL;
+    char dir[MAX_PATH]={0};
+    char property_name[PROPERTY_VALUE_MAX]  = {0};
+    char property_value[PROPERTY_VALUE_MAX] = {0};
+    char *property_tty = NULL, *property_usbmode = NULL, *s = NULL;
+    char target_dir[MAX_PATH] = {"/dev/"};
+
+    snprintf(property_name, sizeof(property_name), "ril.fibocom.%s", ttyname);
+    ret = property_get(property_name, property_value, "");
+    if(ret > 0)
+    {
+        RLOGD("[%s,%d] get ttyname from property %s: %s", __FUNCTION__, __LINE__, property_name, property_value);
+
+        s = property_value;
+        property_tty = strsep(&s, ",");
+        if(property_tty != NULL)
+        {
+            RLOGD("[%s,%d]property_tty:%s", __FUNCTION__, __LINE__, property_tty);
+        }
+        else
+        {
+            RLOGD("property_tty is NULL");
+        }
+
+        property_usbmode = strsep(&s, ",");
+        if(property_usbmode != NULL)
+        {
+            RLOGD("[%s,%d]property_usbmode:%s", __FUNCTION__, __LINE__, property_usbmode);
+            current_usbmode = property_get_int32(PROPERTY_CURRENT_USBMODE, 0);
+            RLOGD("[%s,%d]current_usbmode:%d", __FUNCTION__, __LINE__, current_usbmode);
+            if(atoi(property_usbmode) != current_usbmode)
+            {
+                goto USB_INTERFACE;      //If the expected USBMODE is not equal to the current USBMODE, the property is ignored
+            }
+        }
+        else
+        {
+            RLOGD("property_usbmode is NULL");
+        }
+
+        strncat(target_dir, property_tty, MAX_TTYNAME_LEN);
+
+        ret = access(target_dir, F_OK);
+        if(RET_SUCCESS == ret)
+        {
+            RLOGD("Path %s exists, success!!!", target_dir);
+            strcpy(out_ttyname, property_tty);
+            goto done;
+        }
+        else
+        {
+            RLOGD("Path %s does not exist: %s", target_dir, strerror(ret));
+        }
+    }
+    else
+    {
+        RLOGD("Property %s not set, so try to get ttyname via USB.", property_name);
+    }
+
+USB_INTERFACE:
+    ret = -1;
+
+    if(usb_interface < 0) {
+        goto done;
+    }
+
+    snprintf(dir, sizeof(dir), "%s:1.%d", usbdevice_pah, usb_interface);
+
+    if((pDir = opendir(dir)) == NULL){
+        RLOGE("Cannot open directory:%s/", dir);
+        ret = -2;
+        goto done;
+    }
+
+    while((ent = readdir(pDir)) != NULL){
+        if (strncmp(ent->d_name, "tty", 3) == 0) {
+            RLOGD("find %s/%s", dir, ent->d_name);
+            strcpy(out_ttyname, ent->d_name);
+            ret = 0;//sucesss
+            break;
+        }
+    }
+
+    closedir(pDir);
+done:
+    return ret;
+}
+static void installDriver(char *vid,char *pid)
+{
+    char *cmd;
+    if (access("/sys/bus/usb-serial/drivers/option1/new_id", W_OK) == 0) {
+        RLOGD("find usb serial option driver, but do not cantain fibocom vid&pid");
+        asprintf(&cmd, "echo %s %s > /sys/bus/usb-serial/drivers/option1/new_id",vid,pid);
+        system(cmd);
+        free(cmd);
+        sleep(1); //wait usb driver load  
+    }
+    else {
+        RLOGE("can not find usb serial option driver");
+    }
+}
+static int fibo_find_port(USBPortDevice *portDevice)
+{
+    int ret = 0;
+    struct fibo_usb_device_info usb_device_info;
+    struct fibo_module_info *module_info = NULL;
+    USBPortDevice device;
+    char prefix[] = "/dev/";
+
+    memset(&usb_device_info,0,sizeof(struct fibo_usb_device_info));
+    memset(&device,0,sizeof(USBPortDevice));
+
+    ret = fibo_get_usb_device_info(&usb_device_info);
+    if(ret){
+        goto done;
+    }
+    else{
+        //ensure option driver match
+        if (access("/dev/ttyUSB0", R_OK)){
+           installDriver(usb_device_info.module_info->idVendor,usb_device_info.module_info->idProduct);
+        }
+        else{
+           RLOGD("usb serial option driver match success");
+        }
+    }
+
+    module_info = (struct fibo_module_info *)usb_device_info.module_info;
+
+    ret = fibo_find_ttyname(module_info->diag_inf,usb_device_info.usbdevice_pah,usb_device_info.ttyDM, TTYNAME_DIAG);
+    if(ret)
+    {
+        RLOGD("Failed to find %s, it is recommended to specify it via the ril.fibocom.%s property", TTYNAME_DIAG, TTYNAME_DIAG);
+        goto done;
+    }
+
+    ret = fibo_find_ttyname(module_info->modem_inf,usb_device_info.usbdevice_pah,usb_device_info.ttyModem, TTYNAME_MODEM);
+    if(ret)
+    {
+        RLOGD("Failed to find %s, it is recommended to specify it via the ril.fibocom.%s property", TTYNAME_MODEM, TTYNAME_MODEM);
+        goto done;
+    }
+
+    ret = fibo_find_ttyname(module_info->at_inf,usb_device_info.usbdevice_pah,usb_device_info.ttyAT, TTYNAME_AT);
+    if(ret)
+    {
+        RLOGD("Failed to find %s, it is recommended to specify it via the ril.fibocom.%s property", TTYNAME_AT, TTYNAME_AT);
+        goto done;
+    }
+
+
+    RLOGD("ttyDiag  = [%s]", usb_device_info.ttyDM);
+    RLOGD("ttyModem = [%s]", usb_device_info.ttyModem);
+    RLOGD("ttyAT    = [%s]", usb_device_info.ttyAT);
+
+    strcpy(device.diagchannel,prefix);
+    strcpy(device.atchannel,prefix);
+    strcpy(device.datachannel,prefix);
+    strncat(device.diagchannel,usb_device_info.ttyDM,strlen(usb_device_info.ttyDM));
+    strncat(device.atchannel,usb_device_info.ttyAT,strlen(usb_device_info.ttyAT));
+    strncat(device.datachannel,usb_device_info.ttyModem,strlen(usb_device_info.ttyModem));
+
+    memcpy(portDevice,&device,sizeof(USBPortDevice));
+done:
+    return ret;
+}
+
+int getUsbPortInfo(USBPortDevice *usbPortDevice)
+{
+    int ret = 0;
+    USBPortDevice portDevice;
+
+    memset(&portDevice,0,sizeof(portDevice));
+    ret = fibo_find_port(&portDevice);
+    if(ret){
+        RLOGE("getUsbPortInfo error errnum:[%d]",ret);
+        goto done;
+    }
+
+    strcpy(usbPortDevice->atchannel, portDevice.atchannel);
+    strcpy(usbPortDevice->datachannel, portDevice.datachannel);
+    strcpy(usbPortDevice->diagchannel, portDevice.diagchannel);
+
+    RLOGD("getUsbPortInfo diagchannel   :[%s]",usbPortDevice->diagchannel);
+    RLOGD("getUsbPortInfo atchannel   :[%s]",usbPortDevice->atchannel);
+    RLOGD("getUsbPortInfo datachannel :[%s]",usbPortDevice->datachannel);
+
+done:
+    return ret;
+}
diff --git a/hardware/ril/youyou_ril/getdevinfo.h b/hardware/ril/youyou_ril/getdevinfo.h
new file mode 100755
index 0000000..6f33adf
--- /dev/null
+++ b/hardware/ril/youyou_ril/getdevinfo.h
@@ -0,0 +1,89 @@
+#ifndef _GETDEVINFO_H_
+#define _GETDEVINFO_H_
+
+/*duanshitao add to get usb device information PID and interface class*/
+/*to decide the net mode and at channel and data channel*/
+int getdevinfors(char *vid, char *pid, char *atchannel, char *datachannel, int *mode);
+int detect_usb_device(char *atchannel, char *datachannel);
+
+/*
+ *  diego add for campaticability M910 or other module match vid pid info
+ *
+ */
+#define MAXLEN  15  // /dev/ttyUSB0
+#define MAX_PATH 256
+#define USBID_LEN 4
+#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
+
+#define MAX_TTYNAME_LEN 7
+#define TTYNAME_DIAG   "ttyDiag"
+#define TTYNAME_MODEM  "ttyModem"
+#define TTYNAME_AT     "ttyAT"
+
+typedef struct USBPORT{
+    char atchannel[MAXLEN];
+    char datachannel[MAXLEN];
+    char diagchannel[MAXLEN];
+}USBPortDevice;
+
+struct fibo_module_info {
+    const char idVendor[USBID_LEN+1];
+    const char idProduct[USBID_LEN+1];
+    char diag_inf;
+    char modem_inf;
+    char at_inf;
+    char gps_inf;
+    const char *id;
+};
+
+struct fibo_usb_device_info {
+    const struct fibo_module_info *module_info;
+    char usbdevice_pah[MAX_PATH];
+    char ttyDM[16];
+    char ttyAT[16];
+    char ttyModem[16];
+    char ttyGPS[16];
+};
+
+USBPortDevice s_usbPortDevice;
+
+/*
+ *  fibo support +gtusb mode static table
+ */
+static const struct fibo_module_info fibo_module_info_table[] = {
+    {"1508", "1001", 0, 1, 2, -1, "NL668"}, //NL668
+    {"2cb7", "0104", 0, 1, 2, -1, "NL678"}, //NL678
+    {"2cb7", "0103", 0, 3, 2, 1, "M910"}, //M910
+    {"2cb7", "0001", 5, 3, 4, -1, "L71x"}, //L716
+    {"2cb7", "0106", 0, 1, 2, -1, "MA510"}, //MA510
+    {"1782", "4D10", 5, 0, 6, -1, "L610"}, //L610, USBMODE:31,    PPP
+    {"1782", "4D11", 7, 8, 2, -1, "L610"}, //L610, USBMODE:32,33, ECM
+    {"1782", "4D30", 2, 0, 0, -1, "MC669"}, //MC669
+    {"1782", "4D17", 2, 0, 4, -1, "MC669"}, //MC669, USBMODE:31, DEPRECATED
+    {"1782", "4D13", 4, 2, 6, -1, "MC669"}, //MC669, USBMODE:32, DEPRECATED
+    {"2cb7", "0c01", 4, 3, 4, -1, "MC919"}, //MC919, USBMODE:70, ECM
+    {"2cb7", "0c02", 2, 4, 6, -1, "MC919"}, //MC919, USBMODE:71, RNDIS
+    {"2cb7", "0c03", 2, 4, 3, -1, "MC919"}, //MC919, USBMODE:72, PPP
+    {"2cb7", "0a0a", 1, 0, 3, -1, "MC669"}, //MC669, USBMODE:73, PPP
+    {"2cb7", "0a0b", 3, 2, 5, -1, "MC669"}, //MC669, USBMODE:74, ECM
+    {"2cb7", "0a0c", 3, 2, 5, -1, "MC669"}, //MC669, USBMODE:75, RNDIS
+    {"2cb7", "0a01", 5, 0, 6, -1, "L610"}, //L610 PPP
+    {"2cb7", "0a02", 7, 8, 2, -1, "L610"}, //L610 ECM
+    {"2cb7", "0a03", 7, 8, 2, -1, "L610"}, //L610 RNDIS
+
+    {"2cb7", "0a04", 3, 4, 2, -1, "FG621"}, //FG621-EA
+    {"2cb7", "0a05", 3, 4, 2, -1, "FG621"}, //FG621-EA
+    {"2cb7", "0a06", 3, 4, 2, -1, "FG621"}, //FG621-EA
+
+    {"2cb7", "0a08", 1, 2, 0, -1, "H330S"}  //H330S
+};
+
+/*
+ *  function: get usb device node path
+ *  paras:    save find fibocom usb port device path 
+ *  return:   0 success  others failure
+ */
+int getUsbPortInfo(USBPortDevice *usbPortDevice);
+
+#endif/*_GETDEVINFO_H_*/
+
diff --git a/hardware/ril/youyou_ril/misc.c b/hardware/ril/youyou_ril/misc.c
new file mode 100755
index 0000000..e4b8d72
--- /dev/null
+++ b/hardware/ril/youyou_ril/misc.c
@@ -0,0 +1,29 @@
+/* //device/system/reference-ril/misc.c
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+/** returns 1 if line starts with prefix, 0 if it does not */
+int strStartsWith(const char *line, const char *prefix)
+{
+    for ( ; *line != '\0' && *prefix != '\0' ; line++, prefix++) {
+        if (*line != *prefix) {
+            return 0;
+        }
+    }
+
+    return *prefix == '\0';
+}
+
diff --git a/hardware/ril/youyou_ril/misc.h b/hardware/ril/youyou_ril/misc.h
new file mode 100755
index 0000000..7044a07
--- /dev/null
+++ b/hardware/ril/youyou_ril/misc.h
@@ -0,0 +1,19 @@
+/* //device/system/reference-ril/misc.h
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+/** returns 1 if line starts with prefix, 0 if it does not */
+int strStartsWith(const char *line, const char *prefix);
diff --git a/hardware/ril/youyou_ril/network.c b/hardware/ril/youyou_ril/network.c
new file mode 100755
index 0000000..94b6774
--- /dev/null
+++ b/hardware/ril/youyou_ril/network.c
@@ -0,0 +1,10941 @@
+/******************************************************************************
+  Copyright (C), 2019, Shenzhen G&T Industrial Development Co., Ltd
+
+  File:      network.c
+
+  Author:  Fibocom-diego
+  Version: 1.0
+  Date:  2019.04
+
+  Description:   networks APIs
+
+** History:
+**Author (core ID)                Date          Number     Description of Changes
+**-----------------------------------------------------------------------------
+** NODECOM-Aron                30-10-2018         **   init version 
+** FIBOCOM-diego               10-01-2019         **   add requestDeviceIdentity support Androdi8.1
+** FIBOCOM-diego               15-04-2019         **   add ****M910 function for M910
+** -----------------------------------------------------------------------------
+******************************************************************************/
+#include <telephony/ril.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <alloca.h>
+#include "atchannel.h"
+#include "at_tok.h"
+#include "misc.h"
+#include <getopt.h>
+#include <sys/socket.h>
+#include <cutils/sockets.h>
+#include <cutils/properties.h>
+#include <termios.h>
+#include <arpa/inet.h>
+#include <dirent.h>
+#include<sys/wait.h>
+
+#include "ril_common.h"
+#include "network.h"
+
+#define LOG_TAG GHT_RIL
+#include <utils/Log.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+
+#define LINUX_ROUTE "/proc/net/route"
+
+/*begin:added by dengzq for ndis dial 20181208*/
+#include <net/if.h>
+#include <linux/sockios.h>
+/*end:added by dengzq for ndis dial 20181208*/
+/* BEGIN: Added by eric.li, 2019/1/22   PN:check dns if legal for issue 0015665 */
+#include <regex.h>
+#define ODM_DNS_SIZE 20
+/* END:   Added by eric.li, 2019/1/22   PN:check dns if legal for issue 0015665 */
+/* BEGIN: Added by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+#include <ctype.h>
+/* END:   Added by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+/* pathname returned from RIL_REQUEST_SETUP_DATA_CALL / RIL_REQUEST_SETUP_DEFAULT_PDP */
+#define PPP_TTY_PATH "ppp0"
+#define NDIS_TTY_PATH "usb0"
+#define ECM_TTY_PATH "eth1"
+
+#define PPP_OPERSTATE_PATH "/sys/class/net/ppp0/operstate"
+#define NDIS_OPERSTATE_PATH "/sys/class/net/usb0/operstate"
+#define NDIS_MTU_PATH "/sys/class/net/usb0/mtu"
+#define ECM_OPERSTATE_PATH "/sys/class/net/eth1/operstate"
+
+#define SERVICE_PPPD_GPRS "pppd_gprs"
+#define SERVICE_DHCPCD_ECM "dhcpcd_ecm"
+
+#define PROPERTY_PPPD_EXIT_CODE "net.gprs.ppp-exit"
+#define POLL_PPP_SYSFS_SECONDS    3
+#define POLL_PPP_SYSFS_RETRY    5
+
+#define POLL_NDIS_SYSFS_SECONDS    3
+#define POLL_NDIS_SYSFS_RETRY    5
+
+#ifdef PROP_NAME_MAX
+#undef PROP_NAME_MAX
+#endif //PROP_NAME_MAX
+#define PROP_NAME_MAX 1000
+
+#ifdef PROP_VALUE_MAX
+#undef PROP_VALUE_MAX
+#endif //PROP_VALUE_MAX
+#define PROP_VALUE_MAX 1000
+
+#ifdef SIGNAL_MODEM
+// flag for pppd status. 1: started; 0: stoped
+int pppd = 0;
+#endif
+//added for NL678-E-00
+#define QUERY_NETWORK_TIMEOUT 300000
+// --!>
+/* BEGIN: Added by eric.li, 2019/1/3   PN:for ndis dial MTU size */
+#define ODM_MTU_SIZE  1500
+/* END:   Added by eric.li, 2019/1/3   PN:for ndis dial MTU size */
+/* BEGIN: Added by eric.li, 2019/1/11   PN:0014445 ndis dail timeout */
+#define ODM_RMNET_CALL_TIME_OUT     180000
+/* END:   Added by eric.li, 2019/1/11   PN:0014445 ndis dail timeout */
+extern dial_mode dialmode;
+extern product_model mode_flag;
+extern int eth1_interface;
+static int isNBCard = 0;
+bool ipv4_dial_flag = false;
+bool ipv6_dial_flag = false;
+
+//<--!Start:Added by Wujiabao:Variables associated with the "ril.fibocom.NetifName" property.
+char cus_netifName[PROPERTY_VALUE_MAX]  = {0};   //Netif name specified by the customer
+char cus_gw[100]         = {0};
+char cus_local_ip[100]   = {0};
+char cus_dns1[100]       = {0};
+char cus_dns2[100]       = {0};
+char cus_operstate[100]  = {0};
+int  cus_netifName_flag  = 0;
+//!-----End: Added by Wujiabao:Variables associated with the "ril.fibocom.NetifName" property.>
+
+//<--!Start: Added by Wujiabao:Variables associated with the "ril.fibocom.cid" property.
+int cus_cid = 1;
+//!-----End: Added by Wujiabao:Variables associated with the "ril.fibocom.cid" property.>
+
+//<--!Start: Added by Wujiabao:Variables associated with the "ril.fibocom.cgdcont0" property.
+int cus_cgdcont0 = 0;
+//!-----End: Added by Wujiabao:Variables associated with the "ril.fibocom.cgdcont0" property.>
+
+//<--!Start: Added by Wujiabao:Variables associated with the "ril.fibocom.usbmode" property.
+int cus_usbmode = NO_CUS_USBMODE;
+//!-----End: Added by Wujiabao:Variables associated with the "ril.fibocom.usbmode" property.>
+
+
+//<---!added by Wujiabao in 2022/2/28:Add global variables(flags) that indicate whether certain functionality is supported or not
+int Voice_Support_Flag = 1;             //Whether voice calls are supported
+int SMS_Support_Flag = 1;              //Whether SMS is supported
+int GTRAT_Support_Flag = 1;            //Whether AT+GTRAT=XX is supported
+int Net_3G_Support_Flag = 1;               //Whether to support 3G network
+//!---->
+
+//<!---Used only by ECM dials
+char *ECM_NetifName = NULL;
+char *ECM_local_ip  = NULL;
+char *ECM_dns1      = NULL;
+char *ECM_dns2      = NULL;
+char *ECM_operstate = NULL;
+//-----Used only by ECM dials--!>
+
+int  ppp_fd = -1;
+int  ndis_fd = -1;
+int format_ip = 0;
+extern int cur_oper;
+extern int handover_flag;
+extern int voice_handover_flag;
+extern int script_type;
+static int supportedTechs = -1;
+//added for NL678-E-00
+static int g_cops_lte = -1;
+
+// <!--added by wangmengying@2017.12.13 for register network failed still need to send cops=0
+static int g_SetNetworkSelectionManual = 0;
+// end-->
+
+// <!--added by wangmengying@2017.12.13 for  cops=0 need long timeout
+#define TIME_OUT_COPS 300000
+// end-->
+
+/* BEGIN: Added by eric.li, 2018/12/28   PN:create a pid to trace the pppd */
+int gPid_pppd_died = -1;
+int gPid_pppd_live = -1;
+/* END:   Added by eric.li, 2018/12/28   PN:create a pid to trace the pppd */
+
+//#diego add for replace syscall for ndis all 20181208 
+
+/* BEGIN: Modified by wujiabao in 2022/05/20 PN: Record the current APN information*/
+//modify by zhengjianrong for IPV4V6 switch to IPV6 issue 20190528 begin
+#define MAX_APN_NAME_LEN 20
+#define DEFAULT_APN_CID  0
+char Cur_Pdp_Type[8] = {0};                    //Current PDP type
+char Cur_APN_Name[MAX_APN_NAME_LEN] = {0};     //Current APN name
+int Get_Default_APN_Flag = 0;
+//modify by zhengjianrong for IPV4V6 switch to IPV6 issue 20190528 end
+/* END:  Modified by wujiabao in 2022/05/20 PN: Record the current APN information*/
+
+static int g_mcc = 0xffff;
+static int g_mnc = 0xffff;
+static int g_lac = 0xffff;
+static int g_cid = 0xffff;
+static int g_pci = 0xffff;
+
+extern int ifc_init();
+extern int ifc_up(const char *name);
+extern int do_dhcp(char*);
+extern void ifc_close();
+#define DEFAULTIP "0:0:0:0"
+int fibo_get_ip(const char *interface, char *ip);
+int fibo_bring_up_interface_do_dhcp(const char * iname);
+static pthread_mutex_t s_ndismutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t s_ndiscond = PTHREAD_COND_INITIALIZER;
+//diego add end 20181208 
+/* BEGIN: Added by eric.li, 2019/1/28   PN:add interface for mark apn pdp type */
+#define ODM_PDP_TYPE_SIZE 10
+typedef enum{
+    PDP_IPV4 = 0,
+    PDP_IPV4V6 = 1,
+    PDP_IPV6 = 2,
+    PDP_IPUNKOWN = 3 ,
+}RIL_Pdptype;
+
+RIL_Pdptype g_apn_pdptype = PDP_IPV4;
+
+typedef struct IPV6{
+    char ipv6addr[256];
+    char ipv6gateway[256];
+    char ipv6dns1[256];
+    char ipv6dns2[256];
+}RIL_IPv6;
+
+
+
+
+
+/* BEGIN: Modified by eric.li, 2018/12/29   PN:modify this function for ndis dial */
+void get_gateway(char ** strGW)
+{
+        char *gw = NULL;
+        FILE *input;
+        char *a;
+        struct in_addr * in = malloc(sizeof(struct in_addr));
+        unsigned int num;
+
+        gw = (char *)malloc(64);
+        memset(gw, 0, 64);
+        input = fopen(LINUX_ROUTE, "r");
+        while(!feof(input) && fgetc(input) != '\n');
+        fscanf(input, "%*s %*s %s %*s\n", gw);
+        fclose(input);
+
+        sscanf(gw, "%x", &num);
+        free(gw);
+        in->s_addr = num;
+        a = (char *)inet_ntoa(*in);
+        free(in);
+        RLOGD("[%s,%d],a[%s] \r",__FUNCTION__, __LINE__, a);
+
+        if (!(strcmp(a, "")) || !(strcmp(a, "0.0.0.0")) || getProfileBool("NETWORK", "GWFIX", false))
+        {
+            RLOGE("Fix the gateway...");
+            odm_fix_gw(a);
+            RLOGD("fixed a[%s]!", a);
+        }
+
+        strcpy(strGW[0], a);
+
+        return ;
+}
+/* END:   Modified by eric.li, 2018/12/29   PN:modify this function for ndis dial */
+
+void setIPv6(RIL_IPv6 ril_IPv6)
+{
+    if(dialmode == DIAL_RAS_MOD){
+        property_set("net.ppp0.local-ip", ril_IPv6.ipv6addr);
+        property_set("net.ppp0.gw", ril_IPv6.ipv6gateway);
+        property_set("net.ppp0.dns1", ril_IPv6.ipv6dns1);
+        property_set("net.ppp0.dns2", ril_IPv6.ipv6dns2);
+    }
+    else if(cus_netifName_flag)
+    {
+        property_set(cus_local_ip, ril_IPv6.ipv6addr);
+        property_set(cus_gw, ril_IPv6.ipv6gateway);
+        property_set(cus_dns1, ril_IPv6.ipv6dns1);
+        property_set(cus_dns2, ril_IPv6.ipv6dns2);
+    }
+    else if(eth1_interface == 1){
+        property_set("net.eth1.local-ip", ril_IPv6.ipv6addr);
+        property_set("net.eth1.gw", ril_IPv6.ipv6gateway);
+        property_set("net.eth1.dns1", ril_IPv6.ipv6dns1);
+        property_set("net.eth1.dns2", ril_IPv6.ipv6dns2);
+    }
+    else{
+    // <!--added by wangmengying@2020.2.24 fix bug41458,bug40979,bug41449,ECM dial support IPV6
+        property_set("net.usb0.local-ip", ril_IPv6.ipv6addr);
+        property_set("net.usb0.gw", ril_IPv6.ipv6gateway);
+        property_set("net.usb0.dns1", ril_IPv6.ipv6dns1);
+        property_set("net.usb0.dns2", ril_IPv6.ipv6dns2);
+    // end-->
+    }
+    return;
+}
+void ConvertIPv6fomat(char *dest,char *src)
+{
+    int i =0;
+    int index = 1;
+    char *str = src;
+    char delims[] = ".";
+    char buf[10] = {0};
+    char ipbuf[256] = {0};
+   
+    char *result = NULL;
+    result = strtok(str,delims);
+    while( result != NULL ) {
+        i = atoi(result);
+        sprintf(buf, "%02x", i);
+        strcat(ipbuf,buf);
+        if(index %2 == 0 && (index < 16)){
+            strcat(ipbuf,":");
+        }
+        result = strtok(NULL,delims);
+        index +=1;
+    }
+    //RLOGD("result ipbuf is [%s]",ipbuf);
+    strcpy(dest,ipbuf);
+}
+
+/*
+"192.168.1.3.255.1.1.1"  -> "192.168.1.1"
+"36.14.0.191.212.4.167.175.0.1.0.2.28.142.36.126.255.255.255.255.255.255.255.255.0.0.0.0.0.0.0.0" -> "36.14.0.191.212.4.167.175.0.1.0.2.28.142.36.126"
+
+*/
+void split_subnet_mask(char *dest,char *str,bool is_ipv6)
+{
+    int i,j;
+    for(i=0,j=0;str[i] != '\0';++i)
+    {
+        if('.' == str[i])
+            ++j;
+        if(j == 4 && !is_ipv6)
+        {
+            strncpy(dest,str,i);
+            break;
+        }
+        if(j == 16 && is_ipv6)
+        {
+            strncpy(dest,str,i);
+            break;
+        }
+    }
+    return;
+}
+
+int get_global_ipv6addr(struct in6_addr *addr6, char *iface)
+{
+    #define IF_INET6 "/proc/net/if_inet6"
+    #define IPV6_ADDR_GLOGBAL 0x0000U
+
+    char str[128], address[64];
+    char *addr, *index, *prefix, *scope, *flags, *name;
+    char *delim = " \t\n", *p, *q;
+    FILE *fp;
+    int count, found_addr_flag = RET_FAIL;
+    
+    if (!addr6 || !iface)
+    {
+        RLOGE("addr6 and iface can't be NULL!");
+        return RET_FAIL;
+    }
+    
+    if (NULL == (fp = fopen(IF_INET6, "r")))
+    {
+        RLOGE("fopen %s error", IF_INET6);
+        return RET_FAIL;
+    }
+
+    while (fgets(str, sizeof(str), fp))
+    {
+        RLOGD("str:%s", str);
+        addr = strtok(str, delim);
+        index = strtok(NULL, delim);
+        prefix = strtok(NULL, delim);
+        scope = strtok(NULL, delim);
+        flags = strtok(NULL, delim);
+        name = strtok(NULL, delim);
+        RLOGD("addr:%s, index:0x%s, prefix:0x%s, scope:0x%s, flags:0x%s, name:%s",
+        addr, index, prefix, scope, flags, name);
+
+        if (strcmp(name, iface))
+            continue;
+
+        /* Just get IPv6 global address */
+        if (IPV6_ADDR_GLOGBAL != (unsigned int)strtoul(scope, NULL, 16))
+            continue;
+
+        memset(address, 0x00, sizeof(address));
+        p = addr;
+        q = address;
+        count = 0;
+        while (*p != '\0') {
+            if (count == 4) {
+                *q++ = ':';
+                count = 0;
+            }
+            *q++ = *p++;
+            count++;
+        }
+
+        RLOGD("find out %s's global IPv6 address: %s\n", iface, address);
+        inet_pton(AF_INET6, address, addr6);
+        found_addr_flag = RET_SUCCESS;
+        break;
+    }
+    fclose(fp);
+
+    return found_addr_flag;
+}
+int getIPv6addr(char *dest)
+{
+    struct in6_addr addr6;
+    char *ifname = "ppp0";
+    if (dialmode == DIAL_RAS_MOD)
+    {
+        ifname = "ppp0";
+    }
+    else
+    {
+        ifname = "usb0";
+    }
+    char address[128];
+
+    if (get_global_ipv6addr(&addr6, ifname)) {
+        RLOGD("Get IPv6 global address of %s failed \n", ifname);
+        return -1;
+    }
+    if (inet_ntop(AF_INET6, &addr6, address, sizeof(address)))
+        RLOGD("IPv6 global address of %s is %s \n", ifname, address);
+
+    strncpy(dest,address,strlen(address));
+    return 0;
+}
+
+int getIPv6DefaultGateWay(char *dest)
+{
+   char defaultgw[] = "fe80::1";
+   strcpy(dest,defaultgw);
+   return 0;
+}
+
+int getIPv6GetDns(char *dest1,char *dest2)
+{
+    int err =0 ;
+    ATResponse *p_response = NULL;
+    char *line;
+    int cid;
+    char *pdns = NULL;
+    char *sdns = NULL;
+    char pdnsbuf[256] = {0};
+    char sdnsbuf[256] = {0};
+    char hexbuf[256] ={0};
+
+    err = at_send_command_singleline("AT+GTDNS?", "+GTDNS:", &p_response);
+    /*
+     *+GTDNS: 1, "36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8", "36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+     *<cid>    : 1
+     *<dns1> : "36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8"
+     *<dns2> : "36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+     */
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &cid);
+        if (err < 0) goto error;
+        RLOGD("+GTDNS:<cid>[%d]", cid);
+        err = at_tok_nextstr(&line, &pdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &sdns);
+        if (err < 0) goto error;
+        strncpy(pdnsbuf,pdns,strlen(pdns));
+        strncpy(sdnsbuf,sdns,strlen(sdns));
+        RLOGD("+GTDNS:<pdnsAddress>[%s]",pdnsbuf);
+        RLOGD("+GTDNS:<sdnsAddress>[%s]",sdnsbuf);
+    }
+    //wangmengying@2020.2.12 add IPV6
+    if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || 1 == format_ip || GHT_MC66x == mode_flag)
+    {
+        strncpy(dest1,pdnsbuf,strlen(pdnsbuf));
+        strncpy(dest2,sdnsbuf,strlen(sdnsbuf));
+    }
+    else
+    //end-->
+    {
+        ConvertIPv6fomat(hexbuf,pdnsbuf);
+        RLOGD("getIPv6GetDns:<pdns>[%s]",hexbuf);
+        strncpy(dest1,hexbuf,strlen(hexbuf));
+        memset(hexbuf,0,sizeof(hexbuf));
+        ConvertIPv6fomat(hexbuf,sdnsbuf);
+        RLOGD("getIPv6GetDns:<sdns>[%s]",hexbuf);
+        strncpy(dest2,hexbuf,strlen(hexbuf));
+    }
+error:
+    at_response_free(p_response);
+    p_response = NULL;
+    return err;
+
+}
+// <!--added by wangmengying@2020.2.24 fix bug41458,bug40979,bug41449,ECM dial support IPV6
+int getRndisInfo(char *addr,char *gateway,char *dest1,char *dest2)
+{
+    int err =0 ;
+    ATResponse *p_response = NULL;
+    char *line;
+    int cid;
+    int state;
+    char *ip = NULL;
+    char *pdns = NULL;
+    char *sdns = NULL;
+    char *dnsbuf;
+    char *ipv4addr = NULL;
+    char *ipv6addr = NULL;
+    char gw4_addr[PROPERTY_VALUE_MAX]={0};
+    char defaultgw_v6[] = "fe80::1";
+    char *ipv4pdns = NULL;
+    char *ipv6pdns = NULL;
+    char *ipv4sdns = NULL;
+    char *ipv6sdns = NULL;
+    char buf[256] = {0};
+    struct in6_addr addr6;
+    char address[128] = {0};
+    char *ifname = "usb0";
+    char local_ip[PROPERTY_VALUE_MAX]={0};
+
+    memset(buf,0,sizeof(buf));
+
+    err = at_send_command_singleline("AT+GTRNDIS?", "+GTRNDIS:", &p_response);
+    /*
+     *+GTRNDIS: 1,1,"ip","pdns","sdns"
+     *<state> : 1
+     *<cid>   : 1
+     *<ip>    : "ipv4,ipv6"
+     *<pdns>  : "pdns_v4,pdns_v6"
+     *<sdns>  : "sdns_v4,sdns_v6"
+     */
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &state);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &cid);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ip);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &pdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &sdns);
+        if (err < 0) goto error;
+    }
+    else
+    {
+        goto error;
+    }
+
+    if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+    {
+        sleep(1);
+
+        if (get_global_ipv6addr(&addr6, ECM_NetifName)) {
+            RLOGD("Get IPv6 global address of %s failed, and we continue to try to get the IPV6 address from GTRNDIS command!", ECM_NetifName);
+        }
+        else
+        {
+            if (inet_ntop(AF_INET6, &addr6, address, sizeof(address)))
+                RLOGD("IPv6 global address of %s is %s \n", ECM_NetifName, address);
+        }
+    }
+
+    if (PDP_IPV6 == g_apn_pdptype)
+    {
+        //strncpy(dest,address,strlen(address));
+        if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+        {
+            strcpy(addr,address);
+        }
+        else
+        {
+            strcpy(addr,ip);
+        }
+        strcpy(gateway,defaultgw_v6);
+        strcpy(dest1,pdns);
+        strcpy(dest2,sdns);
+    }
+    else
+    {
+        ipv4addr = strtok(ip, ",");
+        //RLOGD("ipv4addr:%s", ipv4addr);
+        if (GHT_FG621 == mode_flag || GHT_FG650 == mode_flag)
+        {
+            property_get("net.usb0.local-ip", local_ip, "");
+            strcpy(buf,local_ip);
+        }
+        else
+        {
+            strcpy(buf,ipv4addr);
+        }
+        //RLOGD("ipv4 buf:%s", buf);
+        //RLOGD("mode_flag:%d, strlen(address):%d, sizeof(address):%d", mode_flag, strlen(address), sizeof(address));
+
+
+        if ((GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag) && (0 != strlen(address)))
+        {
+            RLOGD("address:%s", address);
+            strcat(buf," ");
+            strcat(buf,address);
+            strcpy(addr,buf);
+        }
+        else
+        {
+            ipv6addr = strtok(NULL, ",");
+            if (NULL != ipv6addr)
+            {
+                //RLOGD("ipv6addr:%s", ipv6addr);
+                strcat(buf," ");
+                strcat(buf,ipv6addr);
+                strcpy(addr,buf);
+            }
+            else
+            {
+                //RLOGD("ipv6addr is null");
+                strcpy(addr,buf);
+            }
+        }
+        //RLOGD("ipv4v6 addr:%s", addr);
+        memset(buf,0,sizeof(buf));
+
+        strcpy(gateway,defaultgw_v6);     //Why is the default ipv6 gateway set to fe80::1 ?
+        memset(buf,0,sizeof(buf));
+
+        ipv4pdns = strtok(pdns, ",");
+        strcpy(buf,ipv4pdns);
+        ipv6pdns = strtok(NULL, ",");
+        if (NULL != ipv6pdns)
+        {
+            strcat(buf," ");
+            strcat(buf,ipv6pdns);
+            strcpy(dest1,buf);
+        }
+        else
+        {
+            strcpy(dest1,buf);
+        }
+        memset(buf,0,sizeof(buf));
+
+        ipv4sdns = strtok(sdns, ",");
+        strcpy(buf,ipv4sdns);
+        ipv6sdns = strtok(NULL, ",");
+        if (NULL != ipv6sdns)
+        {
+            strcat(buf," ");
+            strcat(buf,ipv6sdns);
+            strcpy(dest2,buf);
+        }
+        else
+        {
+            strcpy(dest2,buf);
+        }
+        memset(buf,0,sizeof(buf));
+    }
+error:
+    at_response_free(p_response);
+    p_response = NULL;
+    return err;
+
+}
+// end-->
+int getIPV6Info(RIL_IPv6 *riL_IPv6)
+{
+    int err =0;
+// <!--added by wangmengying@2020.2.24 fix bug41458,bug40979,bug41449,ECM dial support IPV6
+    if (1 == dialmode)
+    {
+        err = getRndisInfo(riL_IPv6->ipv6addr,riL_IPv6->ipv6gateway,riL_IPv6->ipv6dns1,riL_IPv6->ipv6dns2);
+    }
+    else
+    {
+        err = getIPv6addr(riL_IPv6->ipv6addr);
+        err = getIPv6DefaultGateWay(riL_IPv6->ipv6gateway);
+        err = getIPv6GetDns(riL_IPv6->ipv6dns1,riL_IPv6->ipv6dns2);
+    }
+
+    return err;
+}
+
+int getIPV4V6Info_new(RIL_IPv6 * riL_IPv6)
+{
+    int err =0;
+    ATResponse *p_response = NULL;
+    char *line;
+    char *line_ipv6 = NULL;
+    int cid;
+    int bearer_id;
+    char *apn = NULL;
+    char *ipv4addr = NULL;
+    char *ipv6addr = NULL;
+    char *gw4_addr1 = (char *)calloc(PROPERTY_VALUE_MAX, sizeof(char));
+    char  gw4_addr[PROPERTY_VALUE_MAX]={0};
+    char *gw6_addr = NULL;
+    char *ipv4pdns = NULL;
+    char *ipv6pdns = NULL;
+    char *ipv4sdns = NULL;
+    char *ipv6sdns = NULL;
+    char buf[256] = {0};
+    char ipv4_subnet_buf[256] = {0};
+    char ipv6_subnet_buf[256] = {0};
+    char hexbuf[256] ={0};
+    char *ptr = NULL;
+    ATLine  *p_cur;
+    struct in6_addr addr6;
+    char address[128];
+    char *ifname = "ppp0";
+    err = at_send_command_multiline("AT+CGCONTRDP=1", "+CGCONTRDP:", &p_response);
+/*
+     //new AT+CGCONTRDP format as show
+
+    AT+CGCONTRDP=1
+    +CGCONTRDP: 1,5,"ctnet","10.122.197.109.255.0.0.0","0.0.0.0","61.134.1.6","218.30.19.40","0.0.0.0","0.0.0.0"
+    +CGCONTRDP: 1,5,"ctnet","36.14.0.191.212.4.167.175.0.1.0.2.28.142.36.126.255.255.255.255.255.255.255.255.0.0.0.0.0.0.0.0","254.128.0.0.0.0.0.0.0.0.0.0.0.0.0.5","36.14.0.15.0.10.0.0.0.0.0.0.0.0.0.8","0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0","0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0","0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0"
+      *<cid>         : 1,
+      *<bearer_id>   : 5,
+      *<apn>         : cmnet,
+      *<ipv6addr and subnet_mask>:"36.14.0.191.212.4.167.175.0.1.0.2.28.142.36.126.255.255.255.255.255.255.255.255.0.0.0.0.0.0.0.0",
+      *<gw6_addr>:"254.128.0.0.0.0.0.0.0.0.0.0.0.0.0.5"
+      *<ipv6pdns>:"36.14.0.15.0.10.0.0.0.0.0.0.0.0.0.8"
+      *<ipv6sdns>:"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0"
+      *<ipv6P-CSCF_prim_addr>:"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0"
+      *<ipv64P-CSCF_sec_addr>:"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0"
+*/
+
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        // Split IPV6 strings 
+        p_cur = p_response->p_intermediates;
+        p_cur = p_cur->p_next;
+        line_ipv6 = p_cur->line;
+
+        RLOGD("**********line_ipv4: [%s] \n",line);
+
+        //ipv4 info
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &cid);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &bearer_id);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &apn);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4addr);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &gw4_addr);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4pdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4sdns);
+        if (err < 0) goto error;
+
+        //ipv6 info
+        if(line_ipv6 != NULL)
+        {
+            RLOGD("**********line_ipv6: [%s] \n",line_ipv6);
+
+            err = at_tok_start(&line_ipv6);
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line_ipv6, &cid);
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line_ipv6, &bearer_id);
+            if (err < 0) goto error;
+            err = at_tok_nextstr(&line_ipv6, &apn);
+            if (err < 0) goto error;
+            err = at_tok_nextstr(&line_ipv6, &ipv6addr);
+            if (err < 0) goto error;
+            err = at_tok_nextstr(&line_ipv6, &gw6_addr);
+            RLOGD("**********gw6_addr: [%s]",gw6_addr);
+            if (err < 0) goto error;
+            err = at_tok_nextstr(&line_ipv6, &ipv6pdns);
+            if (err < 0) goto error;
+            err = at_tok_nextstr(&line_ipv6, &ipv6sdns);
+            if (err < 0) goto error;
+        }
+        else
+        {
+           RLOGD("Split IPV6 info error \n");
+        }
+    }
+
+    if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+    {
+        if (get_global_ipv6addr(&addr6, ifname)) {
+            RLOGD("Get IPv6 global address of %s failed \n", ifname);
+            return -1;
+        }
+        if (inet_ntop(AF_INET6, &addr6, address, sizeof(address)))
+            RLOGD("IPv6 global address of %s is %s \n", ifname, address);
+    }
+
+    //split ipv4 subnet mask
+    split_subnet_mask(ipv4_subnet_buf,ipv4addr,0);
+    strncpy(buf,ipv4_subnet_buf,strlen(ipv4_subnet_buf));
+    strcat(buf," ");
+
+    if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+    {
+        strcat(buf,address);
+    }
+    else
+    {
+        //split ipv6 subnet mask
+        split_subnet_mask(ipv6_subnet_buf,ipv6addr,1);
+        RLOGD("split ipv6 subnet mask =%s\n",ipv6_subnet_buf);
+        ConvertIPv6fomat(hexbuf,ipv6_subnet_buf);
+        strcat(buf,hexbuf);
+    }
+    strncpy(riL_IPv6->ipv6addr,buf,strlen(buf));
+    memset(buf,0,sizeof(buf));
+    memset(hexbuf,0,sizeof(hexbuf));
+
+    property_get("net.ppp0.remote-ip", gw4_addr, "");
+    RLOGD("gw4_addr [%s]", gw4_addr);
+    strncpy(buf,gw4_addr,strlen(gw4_addr));
+    strcat(buf," ");
+    ConvertIPv6fomat(hexbuf,gw6_addr);
+    strcat(buf,hexbuf);
+    RLOGD("*********gw4-gw6-buf: [%s]",buf);
+    strncpy(riL_IPv6->ipv6gateway,buf,strlen(buf));
+    memset(buf,0,sizeof(buf));
+    memset(hexbuf,0,sizeof(hexbuf));
+
+    strncpy(buf,ipv4pdns,strlen(ipv4pdns));
+    strcat(buf," ");
+    ConvertIPv6fomat(hexbuf,ipv6pdns);
+    strcat(buf,hexbuf);
+    strncpy(riL_IPv6->ipv6dns1,buf,strlen(buf));
+    memset(buf,0,sizeof(buf));
+    memset(hexbuf,0,sizeof(hexbuf));
+
+    strncpy(buf,ipv4sdns,strlen(ipv4sdns));
+    strcat(buf," ");
+    ConvertIPv6fomat(hexbuf,ipv6sdns);
+    strcat(buf,hexbuf);
+    strncpy(riL_IPv6->ipv6dns2,buf,strlen(buf));
+    memset(buf,0,sizeof(buf));
+    memset(hexbuf,0,sizeof(hexbuf));
+error:
+    at_response_free(p_response);
+    p_response = NULL;
+    return err;
+}
+
+
+int getIPV4V6Info_GTRNDIS(RIL_IPv6 * riL_IPv6)
+{
+    int err =0;
+    ATResponse *p_response = NULL;
+    char *line;
+    int cid;
+    int state;
+    char *apn = NULL;
+    char *ipv4v6addr = NULL;
+    char *ipv6addr = NULL;
+    char gw4_addr[PROPERTY_VALUE_MAX]={0};
+    char *gw6_addr = NULL;
+    char *ipv4v6pdns = NULL;
+    char *ipv6pdns = NULL;
+    char *ipv4v6sdns = NULL;
+    char *ipv6sdns = NULL;
+    char buf[256] = {0};
+    char hexbuf[256] ={0};
+    char *ptr = NULL;
+    err = at_send_command_singleline("AT+GTRNDIS?", "+GTRNDIS:", &p_response);
+    /*
+     *+GTRNDIS: 1,1,"10.124.228.66,2408:84fb:1221:e985:0000:0000:0000:0001","221.11.1.67,2408:8888:0000:0000:0000:0000:0000:0008","221.11.1.68,2408:8899:0000:0000:0000:0000:0000:0008"
+     *<state>         : 1,
+     *<cid>   : 1,
+     *<ipv4addr>:"10.124.228.66",
+     *<ipv6addr>:"2408:84fb:1221:e985:0000:0000:0000:0001",
+     *<ipv4pdns> : "221.11.1.67"
+     *<ipv6pdns> : "2408:8888:0000:0000:0000:0000:0000:0008",
+     *<ipv4sdns> : "221.11.1.68,"
+     *<ipv6sdns> : "2408:8899:0000:0000:0000:0000:0000:0008"
+     */
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &state);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &cid);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4v6addr);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4v6pdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4v6sdns);
+        if (err < 0) goto error;
+        
+    }
+    else
+    {
+        RLOGD("getIPV4V6Info:<err>[%d]",err);
+        goto error;
+    }
+   
+    
+error:
+    at_response_free(p_response);
+    p_response = NULL;
+    return err;
+}
+
+
+int getIPV4V6Info(RIL_IPv6 *riL_IPv6)
+{
+    int err =0;
+    ATResponse *p_response = NULL;
+    char *line;
+    int cid;
+    int bearer_id;
+    char *apn = NULL;
+    char *ipv4addr = NULL;
+    char *ipv6addr = NULL;
+    char gw4_addr[PROPERTY_VALUE_MAX]={0};
+    char *gw6_addr = NULL;
+    char *ipv4pdns = NULL;
+    char *ipv6pdns = NULL;
+    char *ipv4sdns = NULL;
+    char *ipv6sdns = NULL;
+    char buf[256] = {0};
+    char hexbuf[256] ={0};
+    char *ptr = NULL;
+    err = at_send_command_singleline("AT+CGCONTRDP=1", "+CGCONTRDP:", &p_response);
+    /*
+     *+CGCONTRDP: 1,5,"cmnet",
+     *  "10.118.223.168","36.9.137.84.48.84.49.23.125.103.123.85.198.141.4.208",
+     *  "254.128.0.0.0.0.0.0.0.0.0.0.0.0.0.1",
+     *  "120.196.165.7" "36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8",
+     *  "221.179.38.7" "36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+     *<cid>         : 1,
+     *<bearer_id>   : 5,
+     *<apn>         : cmnet,     
+     *<ipv4addr>:"10.118.223.168",
+     *<ipv6addr>:"36.9.137.84.48.84.49.23.125.103.123.85.198.141.4.208",
+     *<gw6_addr>     : 254.128.0.0.0.0.0.0.0.0.0.0.0.0.0.1,
+     *<ipv4pdns> : "120.196.165.7"
+     *<ipv6pdns> : "36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8",
+     *<ipv4sdns> : "120.196.165.7"
+     *<ipv6sdns> : "36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+     */
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &cid);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &bearer_id);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &apn);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4addr);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv6addr);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &gw6_addr);
+        if (err < 0) goto error;
+        /*
+         * handle Null char instead of ','
+         *"120.196.165.7" "36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8","120.196.165.7" "36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+         *"120.196.165.7","36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8","120.196.165.7","36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+         */
+        ptr = line;
+        while(*ptr != '\0'){
+            if(*ptr == ' '){
+                *ptr = ',';
+            }
+            ptr++;
+        }
+        err = at_tok_nextstr(&line, &ipv4pdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv6pdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4sdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv6sdns);
+        if (err < 0) goto error;
+    }
+    // <!--[ODM]wangmengying@2019.12.20 fix bug36697,switch network,RIL reset,dial-up failed
+    else
+    {
+        RLOGD("getIPV4V6Info:<err>[%d]",err);
+        goto error;
+    }
+    // end--!>
+
+    if (1 == format_ip)
+    {
+        strncpy(buf,ipv4addr,strlen(ipv4addr));
+        strcat(buf," ");
+        strcat(buf,ipv6addr);
+        strncpy(riL_IPv6->ipv6addr,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+
+        property_get("net.ppp0.remote-ip", gw4_addr, "");
+        strncpy(buf,gw4_addr,strlen(gw4_addr));
+        strcat(buf," ");
+        strcat(buf,gw6_addr);
+        strncpy(riL_IPv6->ipv6gateway,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+
+        strncpy(buf,ipv4pdns,strlen(ipv4pdns));
+        strcat(buf," ");
+        strcat(buf,ipv6pdns);
+        strncpy(riL_IPv6->ipv6dns1,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+
+        strncpy(buf,ipv4sdns,strlen(ipv4sdns));
+        strcat(buf," ");
+        strcat(buf,ipv6sdns);
+        strncpy(riL_IPv6->ipv6dns2,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+    }
+    else
+    {
+        strncpy(buf,ipv4addr,strlen(ipv4addr));
+        strcat(buf," ");
+        ConvertIPv6fomat(hexbuf,ipv6addr);
+        strcat(buf,hexbuf);
+        strncpy(riL_IPv6->ipv6addr,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+        memset(hexbuf,0,sizeof(hexbuf));
+
+        property_get("net.ppp0.remote-ip", gw4_addr, "");
+        strncpy(buf,gw4_addr,strlen(gw4_addr));
+        strcat(buf," ");
+        ConvertIPv6fomat(hexbuf,gw6_addr);
+        strcat(buf,hexbuf);
+        strncpy(riL_IPv6->ipv6gateway,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+        memset(hexbuf,0,sizeof(hexbuf));
+
+        strncpy(buf,ipv4pdns,strlen(ipv4pdns));
+        strcat(buf," ");
+        ConvertIPv6fomat(hexbuf,ipv6pdns);
+        strcat(buf,hexbuf);
+        strncpy(riL_IPv6->ipv6dns1,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+        memset(hexbuf,0,sizeof(hexbuf));
+
+        strncpy(buf,ipv4sdns,strlen(ipv4sdns));
+        strcat(buf," ");
+        ConvertIPv6fomat(hexbuf,ipv6sdns);
+        strcat(buf,hexbuf);
+        strncpy(riL_IPv6->ipv6dns2,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+        memset(hexbuf,0,sizeof(hexbuf));
+    }
+error:
+    at_response_free(p_response);
+    p_response = NULL;
+    return err;
+
+}
+int getIPV4V6InfoL716(RIL_IPv6 *riL_IPv6)
+{
+    int err =0;
+    ATResponse *p_response = NULL;
+    char *line;
+    int cid;
+    int bearer_id;
+    char *apn = NULL;
+    char *ipv4addr = NULL;
+    char *ipv6addr = NULL;
+    char gw4_addr[PROPERTY_VALUE_MAX]={0};
+    char *gw6_addr = NULL;
+    char *ipv4pdns = NULL;
+    char *ipv6pdns = NULL;
+    char *ipv4sdns = NULL;
+    char *ipv6sdns = NULL;
+    char buf[256] = {0};
+    char hexbuf[256] ={0};
+    char *ptr = NULL;
+    err = at_send_command_singleline("AT+CGCONTRDP=1", "+CGCONTRDP:", &p_response);
+    /*
+     *+CGCONTRDP: 1,5,"cmnet",
+     *  "10.118.223.168","36.9.137.84.48.84.49.23.125.103.123.85.198.141.4.208",
+     *  "254.128.0.0.0.0.0.0.0.0.0.0.0.0.0.1",
+     *  "120.196.165.7" "36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8",
+     *  "221.179.38.7" "36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+     *<cid>         : 1,
+     *<bearer_id>   : 5,
+     *<apn>         : cmnet,     
+     *<ipv4addr>:"10.118.223.168",
+     *<ipv6addr>:"36.9.137.84.48.84.49.23.125.103.123.85.198.141.4.208",
+     *<gw6_addr>     : 254.128.0.0.0.0.0.0.0.0.0.0.0.0.0.1,
+     *<ipv4pdns> : "120.196.165.7"
+     *<ipv6pdns> : "36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8",
+     *<ipv4sdns> : "120.196.165.7"
+     *<ipv6sdns> : "36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+     */
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &cid);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &bearer_id);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &apn);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4addr);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv6addr);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &gw6_addr);
+        if (err < 0) goto error;
+        /*
+         * handle Null char instead of ','
+         *"120.196.165.7" "36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8","120.196.165.7" "36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+         *"120.196.165.7","36.9.128.87.32.0.0.0.0.0.0.0.0.0.0.8","120.196.165.7","36.9.128.87.32.0.0.4.0.0.0.0.0.0.0.8"
+         */
+        ptr = line;
+        while(*ptr != '\0'){
+            if(*ptr == ' '){
+                *ptr = ',';
+            }
+            ptr++;
+        }
+        err = at_tok_nextstr(&line, &ipv4pdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv6pdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv4sdns);
+        if (err < 0) goto error;
+        err = at_tok_nextstr(&line, &ipv6sdns);
+        if (err < 0) goto error;
+    }
+    // <!--[ODM]wangmengying@2019.12.20 fix bug36697,switch network,RIL reset,dial-up failed
+    else
+    {
+        RLOGD("getIPV4V6Info:<err>[%d]",err);
+        goto error;
+    }
+    // end--!>
+
+    if (1 == format_ip)
+    {
+        strncpy(buf,ipv4addr,strlen(ipv4addr));
+        strcat(buf," ");
+        strcat(buf,ipv6addr);
+        strncpy(riL_IPv6->ipv6addr,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+
+        property_get("net.ppp0.remote-ip", gw4_addr, "");
+        strncpy(buf,gw4_addr,strlen(gw4_addr));
+        strcat(buf," ");
+        strcat(buf,gw6_addr);
+        strncpy(riL_IPv6->ipv6gateway,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+
+        strncpy(buf,ipv4pdns,strlen(ipv4pdns));
+        strcat(buf," ");
+        strcat(buf,ipv6pdns);
+        strncpy(riL_IPv6->ipv6dns1,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+
+        strncpy(buf,ipv4sdns,strlen(ipv4sdns));
+        strcat(buf," ");
+        strcat(buf,ipv6sdns);
+        strncpy(riL_IPv6->ipv6dns2,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+    }
+    else
+    {
+        strncpy(buf,ipv4addr,strlen(ipv4addr));
+        strcat(buf," ");
+        ConvertIPv6fomat(hexbuf,ipv6addr);
+        strcat(buf,hexbuf);
+        strncpy(riL_IPv6->ipv6addr,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+        memset(hexbuf,0,sizeof(hexbuf));
+
+        property_get("net.ppp0.remote-ip", gw4_addr, "");
+        strncpy(buf,gw4_addr,strlen(gw4_addr));
+        strcat(buf," ");
+        ConvertIPv6fomat(hexbuf,gw6_addr);
+        strcat(buf,hexbuf);
+        strncpy(riL_IPv6->ipv6gateway,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+        memset(hexbuf,0,sizeof(hexbuf));
+
+        strncpy(buf,ipv4pdns,strlen(ipv4pdns));
+        strcat(buf," ");
+        ConvertIPv6fomat(hexbuf,ipv6pdns);
+        strcat(buf,hexbuf);
+        strncpy(riL_IPv6->ipv6dns1,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+        memset(hexbuf,0,sizeof(hexbuf));
+
+        strncpy(buf,ipv4sdns,strlen(ipv4sdns));
+        strcat(buf," ");
+        ConvertIPv6fomat(hexbuf,ipv6sdns);
+        strcat(buf,hexbuf);
+        strncpy(riL_IPv6->ipv6dns2,buf,strlen(buf));
+        memset(buf,0,sizeof(buf));
+        memset(hexbuf,0,sizeof(hexbuf));
+    }
+error:
+    at_response_free(p_response);
+    p_response = NULL;
+    return err;
+
+}
+
+int rilInitIPV6(void)
+{
+    ENTER_FUNC;
+    int ret = 0;
+    RIL_IPv6 ril_IPv6;
+
+    memset(&ril_IPv6,0,sizeof(RIL_IPv6));
+
+    if (PDP_IPV6 == g_apn_pdptype)
+    {
+        ret = getIPV6Info(&ril_IPv6);
+    }
+    else
+    {
+        if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+        {
+            //ret = getIPV4V6Info_new(&ril_IPv6);
+            goto done;
+        }
+        else if(GHT_FG621 == mode_flag || (GHT_FG650==mode_flag ))
+        {
+            ret = getIPV4V6Info_GTRNDIS(&ril_IPv6);
+        }
+        else if(GHT_L716 == mode_flag)
+        {
+            ret = getIPV4V6Info(&ril_IPv6);
+        }
+        else
+        {
+            ret = getIPV4V6Info(&ril_IPv6);
+        }
+    }
+    if(ret){
+        RLOGE("getIPv6 fail");
+        goto done;
+    }
+    RLOGD("RIL IPV6 ipv6addr: [%s]",ril_IPv6.ipv6addr);
+    RLOGD("RIL IPV6 ipv6gateway: [%s]",ril_IPv6.ipv6gateway);
+    RLOGD("RIL IPV6 ipv6dns1: [%s]",ril_IPv6.ipv6dns1);
+    RLOGD("RIL IPV6 ipv6dns2: [%s]",ril_IPv6.ipv6dns2);
+    setIPv6(ril_IPv6);
+ done:
+    LEAVE_FUNC;
+    return ret;
+}
+
+static char * strupr(char * str)
+{
+    char * origin = str;
+    for (; *str != '\0'; str++)
+    {
+        *str = toupper(*str);
+    }
+    return origin;
+}
+
+static RIL_Pdptype odm_get_pdptype(const char * pdp_str)
+{
+    RIL_Pdptype type = 0;
+    char *p_tmp = (char *) alloca(ODM_PDP_TYPE_SIZE * sizeof(char));
+
+    if (NULL == pdp_str)
+    {
+        RLOGD("odm_get_pdptype input null");
+        type = PDP_IPUNKOWN;
+        return type;
+    }
+    
+    if (NULL == p_tmp)
+    {
+        RLOGD("odm_get_pdptype alloca for p_tmp failed");
+        type = PDP_IPUNKOWN;
+        return type;
+    }
+
+    memset(p_tmp, 0, ODM_PDP_TYPE_SIZE);
+
+    strcpy(p_tmp, pdp_str);
+
+    p_tmp = strupr(p_tmp);
+
+    if (0 == strcmp(p_tmp, "IP"))
+    {
+        type = PDP_IPV4;
+    }
+    else if (0 == strcmp(p_tmp, "IPV4V6"))
+    {
+        type = PDP_IPV4V6;
+    }
+    else if (0 == strcmp(p_tmp, "IPV6"))
+    {
+        type = PDP_IPV6;
+    }
+    else
+    {
+        type = PDP_IPUNKOWN;
+    }
+    
+    RLOGD("odm_get_pdptype  %d", type);
+
+    return type;
+}
+
+/* END:   Added by eric.li, 2019/1/28   PN:add interface for mark apn pdp type */
+int at_send_command_dial(int fd, const char * command);
+extern int dhcp_do_request(const char *ifname,
+        in_addr_t *ipaddr,
+        in_addr_t *gateway,
+        in_addr_t *mask,
+        in_addr_t *dns1,
+        in_addr_t *dns2,
+        in_addr_t *server,
+        uint32_t  *lease);
+
+extern int dhcp_stop(const char *interface);
+//added for NL678-E-00
+static int parseRegistrationState(char *str, int *type, int *items, int **response);
+
+/* BEGIN: Added by eric.li, 2019/1/17   PN:add function odm_get_dns_gtdns */
+int  odm_get_dns_gtdns(char ** dns1, char **dns2)
+{
+	int err;
+	ATResponse *p_response = NULL;
+	char *line;
+	int cid;
+
+	err = at_send_command_singleline("AT+GTDNS?", "+GTDNS:", &p_response);
+	/*
+	*AT+GTDNS?
+	*+GTDNS: 1,"120.80.80.80","221.5.88.88"
+	*<cid>    : 1
+	*<dns1> : "120.80.80.80"
+	*<dns2> : "221.5.88.88"
+	*/
+	if (err == 0 && p_response->success != 0)
+	{
+		line = p_response->p_intermediates->line;
+		err = at_tok_start(&line);
+		if (err < 0) goto error;
+
+		err = at_tok_nextint(&line, &cid);
+		if (err < 0) goto error;
+
+		err = at_tok_nextstr(&line, &dns1);
+		if (err < 0) goto error;
+
+		err = at_tok_nextstr(&line, &dns2);
+		if (err < 0) goto error;
+	}
+
+    at_response_free(p_response);
+    p_response = NULL;
+    return err;
+
+error:
+    at_response_free(p_response);
+    err = -1;
+    return err;	
+}
+
+/* END:   Added by eric.li, 2019/1/17   PN:add function odm_get_dns_gtdns */
+/* BEGIN: Added by eric.li, 2019/1/21   PN:check dns if legal */
+
+int odm_regex_exe(const char *regex_pattern, const char *to_match)
+{
+    regex_t r;
+    int ret;
+    int match;
+    char errmsg[128];
+ 
+    if(regcomp(&r, regex_pattern, REG_EXTENDED | REG_NEWLINE)) {
+        RLOGD("regcomp failed!\n");
+        regfree(&r);
+        return -1;
+    }
+ 
+    ret = regexec(&r, to_match, 0, NULL, 0);
+    if(!ret) {
+        match = 1;
+        RLOGD("match!\n");
+    } else if(ret == REG_NOMATCH) {
+        match = 0;
+        RLOGD("not match!\n");
+    } else {
+        regerror(ret, &r, errmsg, sizeof(errmsg));
+        RLOGD("regexec failed: %s!\n", errmsg);
+        regfree(&r);
+        return -1;
+    }
+ 
+    regfree(&r);
+    return match;
+}
+
+int odm_check_dns(const char * pdns, const char * sdns)
+{
+    int match;
+    const char validDnsRegex[] = "^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$";
+ 
+    RLOGD("odm_check_dns1:%s\n", pdns);
+    match = odm_regex_exe(validDnsRegex, pdns);
+    if(match != 1) {
+        return -1;
+    }
+
+    RLOGD("odm_check_dns2:%s\n", sdns);
+    match = odm_regex_exe(validDnsRegex, sdns);
+    if(match != 1) {
+        return -1;
+    }
+ 
+    return 0;
+}
+
+void odm_fix_gw(char *gw)
+{
+    int dot_count = 0, i = 0;
+    char *cmd = NULL;
+
+    property_get(ECM_local_ip, gw, "0.0.0.0");
+    RLOGD("[%s,%d] get local_ip: %s", __FUNCTION__, __LINE__, gw);
+
+    if(CHECK_DNS_AVAILABLE(gw))
+    {
+        do
+        {
+            //RLOGD("local_ip[%d]:%c", i, gw[i]);
+            if('.' == gw[i])
+            {
+                dot_count++;
+                //RLOGD("get '.', counter:%d", dot_count);
+            }
+            i++;
+        }
+        while (dot_count < 3);
+
+        //RLOGD("i:%d, local_ip[i]:%c", i, gw[i]);
+        strcpy(&gw[i], "1");
+        RLOGD("new gw:%s", gw);
+
+        cmd = (char *)malloc(128 * sizeof(char));
+
+        i = 3;
+        do
+        {
+            asprintf(&cmd, "/system/bin/ip route add default via %s dev %s", gw, ECM_NetifName);
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+            sleep(1);
+        }
+        while (--i);
+        
+
+
+        asprintf(&cmd, "/system/bin/ip rule add from all lookup main pref 31999");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+    }
+
+}
+
+int odm_fix_dns(char *p_pdns,  char *p_sdns)
+{
+    int err = -1;
+    ATResponse *p_response = NULL;
+    char *line;
+    int cid;
+
+    char *pdns =  (char *)calloc(ODM_DNS_SIZE, sizeof(char));
+    char *sdns =  (char *)calloc(ODM_DNS_SIZE, sizeof(char));
+    if (NULL == pdns)
+    {
+        err = -1;
+        RLOGD("odm_fix_dns calloc pdns failed");
+        return err;
+    }
+
+    if (NULL == sdns)
+    {
+        err = -1;
+        RLOGD("odm_fix_dns calloc sdns failed");
+        return err;
+    }
+
+// <!--added by wangmengying@2020.2.24 fix bug40975,ECM DNS report error
+    //err = odm_get_dns_gtdns(&pdns, &sdns);
+    err = at_send_command_singleline("AT+GTDNS?", "+GTDNS:", &p_response);
+    /*
+    *AT+GTDNS?
+    *+GTDNS: 1,"120.80.80.80","221.5.88.88"
+    *<cid>    : 1
+    *<dns1> : "120.80.80.80"
+    *<dns2> : "221.5.88.88"
+    */
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+
+        err = at_tok_nextint(&line, &cid);
+        if (err < 0) goto error;
+
+        err = at_tok_nextstr(&line, &pdns);
+        if (err < 0) goto error;
+
+        err = at_tok_nextstr(&line, &sdns);
+        if (err < 0) goto error;
+    }
+    else
+    {
+        goto error;
+    }
+// end-->
+    RLOGD("[%s,%d]pdns[%s](%d), sdns[%s](%d)", __FUNCTION__, __LINE__, pdns, CHECK_DNS_AVAILABLE(pdns), sdns, CHECK_DNS_AVAILABLE(sdns));
+
+    if(!CHECK_DNS_AVAILABLE(p_pdns) && CHECK_DNS_AVAILABLE(pdns))
+    {
+        RLOGD("p_pdns needs to be changed!");
+        strcpy(p_pdns, pdns);
+    }
+    else if(!CHECK_DNS_AVAILABLE(p_pdns) && !CHECK_DNS_AVAILABLE(pdns))
+    {
+        RLOGD("Set p_pdns to the default %s!", DEFAULT_PDNS);
+        strcpy(p_pdns, DEFAULT_PDNS);
+    }
+    else
+    {
+        RLOGD("p_pdns does not need to change!");
+    }
+
+    if(!CHECK_DNS_AVAILABLE(p_sdns) && CHECK_DNS_AVAILABLE(sdns))
+    {
+        RLOGD("p_sdns needs to be changed!");
+        strcpy(p_sdns, sdns);
+    }
+    else if(!CHECK_DNS_AVAILABLE(p_sdns) && !CHECK_DNS_AVAILABLE(sdns))
+    {
+        RLOGD("Set p_sdns to the default %s!", DEFAULT_SDNS);
+        strcpy(p_sdns, DEFAULT_SDNS);
+    }
+    else
+    {
+        RLOGD("p_sdns does not need to change!");
+    }
+
+    RLOGD("odm_fix_dns : p_pdns[%s](%d),p_sdns[%s](%d), err:%d",p_pdns, CHECK_DNS_AVAILABLE(p_pdns), p_sdns, CHECK_DNS_AVAILABLE(p_sdns), err);
+    at_response_free(p_response);
+    p_response = NULL;
+    return err;
+error:
+    at_response_free(p_response);
+    err = -1;
+    return err;
+}
+
+/* END:   Added by eric.li, 2019/1/21   PN:check dns if legal */
+static int readfile(char *pathname, char* buffer, int size)
+{
+    int fd;
+    int count=0;
+
+    if((fd=open(pathname,O_RDONLY))==-1)
+    {
+        return 0;
+    }
+    count=read(fd,buffer,size);
+    close(fd);
+    return 1;
+}
+
+static int readinterfaceprop(char *dir)
+{
+    char tmp[20];
+    struct dirent *filename;
+    static char* dot=".";
+    static char* dotdot="..";
+    DIR*dp=NULL;
+    char pathname[256];
+    dp=opendir(dir);
+    while((filename=readdir(dp))!=NULL)
+    {
+        if((filename->d_type == DT_DIR || filename->d_type == DT_LNK) && strcmp(filename->d_name,dot) && strcmp(filename->d_name,dotdot))
+        {
+            continue;
+        }
+        else
+        {
+            memset(pathname,0,sizeof(pathname));
+            strcpy(pathname,dir);
+            strcat(pathname,"/");
+            strcat(pathname,filename->d_name);
+            memset(tmp,0,sizeof(tmp));
+            readfile(pathname, tmp, 10);
+            RLOGD("%s = %s",filename->d_name,tmp);
+        }
+    }
+    return 1;
+}
+static const char* networkStatusToRilString(int state)
+{
+    switch(state)
+    {
+        case 0:
+            return("unknown");
+            break;
+        case 1:
+            return("available");
+            break;
+        case 2:
+            return("current");
+            break;
+        case 3:
+            return("forbidden");
+            break;
+        default:
+            return NULL;
+    }
+}
+int networktypeToRilType(int type)
+{
+    switch(type)
+    {
+        case 0:
+        case 1:
+            return 16;
+            break;
+        case 2:
+            return 3;
+            break;
+        case 3:
+            return 1;
+            break;
+        case 4:
+            return 9;
+            break;
+        case 5:
+            return 10;
+            break;
+        case 6:
+            return 11;
+            break;
+        case 7:
+            return 14;
+            break;
+            // <!--[ODM]for cdma/evdo network
+#if 0
+        case 8:
+            return 6;
+            break;
+        case 9:
+        case 10:
+            return 8;
+            break;
+#else
+        case 8:
+            return 16;
+            break;
+        case 9:
+        case 10:
+            return 3;
+            break;
+#endif
+            // end-->
+        default:
+            return 0;
+    }
+}
+
+char * get_network_type()
+{
+    int err;
+    ATResponse *p_response = NULL;
+    char *responsenet = NULL;
+    char *line;
+    const char *cmd;
+    const char *prefix;
+    int response[4];
+    char *p_responsnet = NULL;
+
+    at_send_command("AT+COPS=3,2",NULL);
+    cmd = "AT+COPS?";  //+COPS: 0,2,"46001",7
+    prefix = "+COPS:";
+    err = at_send_command_singleline(cmd, prefix, &p_response);
+    if (err == 0 && p_response->success != 0) 
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+	   
+	if (err < 0) goto error;
+	err = at_tok_nextint(&line, &response[0]);
+	if (err < 0) goto error;
+	err = at_tok_nextint(&line, &response[1]);
+	if (err < 0) goto error;
+	err = at_tok_nextint(&line, &response[2]);
+	if (err < 0) goto error;
+	err = at_tok_nextint(&line, &response[3]);
+	if (err < 0) goto error;
+
+    g_cops_lte = response[3];
+    RLOGD("network type %d,   g_cops_lte %d ,mode_flag: %d",response[3],g_cops_lte,mode_flag);
+       
+    if(mode_flag != GHT_FG650)
+    {
+        switch(response[3])
+        {
+            case 0://GSM
+                responsenet = "GSM";
+                break;
+            case 1://GSM Compact
+                responsenet = "GSM Compact";
+                break;
+            case 2://UTRAN
+                responsenet = "UTRAN";
+                break;
+            case 3://GSM w/EGPRS
+				responsenet = "GSM w/EGPRS";
+				break;
+			case 4://UTRAN w/HSDPA
+				responsenet = "UTRAN w/HSDPA";
+				break;
+			case 5://UTRAN w/HSUPA
+				responsenet = "UTRAN w/HSUPA";
+				break;
+			case 6://UTRAN w/HSDPA and HSUPA
+				responsenet = "UTRAN w/HSDPA and HSUPA ";
+				break;
+			case 7://E-UTRAN
+				responsenet = "E-UTRAN";
+				break;
+			case 8:
+				responsenet = "CDMA";
+				break;
+			case 9:
+				responsenet = "CDMA&EVDO";
+				break;
+			case 10:
+				responsenet = "EVDO";
+				break;
+			case 11:
+				responsenet = "eMTC";
+				break;
+			case 12:
+				responsenet = "NB-IoT";
+				break;
+			default:
+				responsenet = "UNKNOWN";
+				goto error;
+				break;
+	             }
+        }
+       else
+        {
+            switch(response[3])
+            {
+                case 0://GSM
+                    responsenet = "GSM";
+                    break;
+                case 1://GSM Compact
+                    responsenet = "GSM Compact";
+                    break;
+                case 2://UTRAN
+                    responsenet = "UTRAN";
+                    break;
+                case 3://GSM w/EGPRS
+                    responsenet = "GSM w/EGPRS";
+                    break;
+                case 4://UTRAN w/HSDPA
+                    responsenet = "UTRAN w/HSDPA";
+                    break;
+                case 5://UTRAN w/HSUPA
+                    responsenet = "UTRAN w/HSUPA";
+                    break;
+                case 6://UTRAN w/HSDPA and HSUPA
+                    responsenet = "UTRAN w/HSDPA and HSUPA ";
+                    break;
+                case 7://E-UTRAN
+                    responsenet = "E-UTRAN";
+                    break;
+                case 8:
+                    responsenet = "CDMA";
+                    break;
+                case 9:
+                    responsenet = "CDMA&EVDO";
+                    break;
+                case 10:
+                    responsenet = "EVDO";
+                    break;
+                case 11:
+                    responsenet = "NR";
+                    break;
+                case 12:
+                    responsenet = "NG-RAN";
+                    break;
+                case 13:
+                    responsenet = "NR-RAN/LTE";
+                    break;
+                default:
+                    RLOGD("[%d] response[3]=%d can't match network type,so default set UNKNOWN ", __LINE__,response[3]);
+                    responsenet = "UNKNOWN";
+                    goto error;
+                    break;
+            }
+        }
+    }
+    else
+    {
+        RLOGD("%s,%d failed to get cops", __FUNCTION__, __LINE__);
+        goto error;
+    }
+error:
+    if(responsenet == NULL)
+    {
+    	responsenet = "UNKNOWN";
+    }
+    at_response_free(p_response);
+    RLOGD("network type %s",responsenet);
+    return responsenet;
+}
+
+int odm_get_current_network_type()
+{
+    int err;
+    int response = 0;
+    const char *cmd;
+    const char *prefix;
+    char *line;
+    int *registration = NULL;
+    int count = 0;
+    int type = 0;
+    ATResponse *p_response = NULL;
+
+   registration = get_network_type();
+   RLOGD("get current network22222 %s\r",registration);
+   if(!strncmp(registration, "GPRS",strlen("GPRS")))
+        response = 1;
+   else if(!strncmp(registration, "GSM",strlen("GSM")))
+        response = 16;
+    else if(!strncmp(registration, "TDSCDMA",strlen("TDSCDMA")))
+        response = 3;
+    else if(!strncmp(registration, "EGPRS",strlen("EGPRS")))
+        response = 2;
+    else if(!strncmp(registration, "UTRAN",strlen("UTRAN")))
+        response = 3;
+    else if(!strncmp(registration, "HSDPA",strlen("HSDPA")))
+        response = 9;
+    else if(!strncmp(registration, "HSUPA",strlen("HSUPA")))
+        response = 10;
+    else if(!strncmp(registration, "HSPA+",strlen("HSPA+")))
+        response = 15;
+    else if(!strncmp(registration, "E-UTRAN",strlen("E-UTRAN")))
+        response = 14;
+    else if(!strncmp(registration, "EVDO",strlen("EVDO")) || !strncmp(registration, "CDMA&EVDO",strlen("CDMA&EVDO")))
+        response = 7;
+    else if(!strncmp(registration, "CDMA",strlen("CDMA")))
+        response = 6;
+    else if(!strncmp(registration, "EHRPD",strlen("EHRPD")))
+        response = 13;
+    else if((!strncmp(registration, "NR-RAN/LTE",strlen("NR-RAN/LTE"))) || (!strncmp(registration, "NR",strlen("NR"))) || (!strncmp(registration, "NG-RAN",strlen("NG-RAN"))))
+        response = 20;
+    else
+    {
+        response = 0;
+    }
+    RLOGD("network type %d",response);
+    return response;
+}
+void onDeactiveDataCallList()
+{
+    int err = 0;
+    char*cmd;
+    RLOGD("%s: Enter onDeactiveDataCallList", __FUNCTION__);
+#if 0
+/*begin:modfied by lisf for android 8 response 20190114*/
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        RIL_Data_Call_Response_v11 *responses = alloca(sizeof(RIL_Data_Call_Response_v11));
+#else
+    RIL_Data_Call_Response_v6 *responses = alloca(sizeof(RIL_Data_Call_Response_v6));
+#endif
+/*end:modfied by lisf for android 8 response 20190114*/
+#endif
+    RIL_Data_Call_Response_v6 *responses = (RIL_Data_Call_Response_v6 *)alloca(sizeof(RIL_Data_Call_Response_v6) + 64);
+    int response_len = sizeof(RIL_Data_Call_Response_v6);
+
+    if(dialmode == DIAL_RAS_MOD)
+    {
+        RLOGD("onDeactiveDataCallList pppd = %d",pppd);
+        if(pppd)
+        {
+            RLOGD("Stop existing PPPd");
+//modified by lisf for debug 20181210
+#if 0
+            at_send_command("ATH", NULL);
+            property_set("ctl.stop", SERVICE_PPPD_GPRS);
+#else
+            if(get_pid("pppd"))
+            {
+                err = at_send_command("ATH", NULL);
+                property_set("ctl.stop", SERVICE_PPPD_GPRS);
+/*begin:modified for android5x , don't kill pppd by lisf 20181221*/
+//#ifndef GHT_FEATURE_ANDROID5X
+                if(Ght_Android_Version != ANDROID_5)
+                {
+                    RLOGD("[%s,%d]: version_check Ght_Android_Version:%d !=5 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                    ril_kill_pppd(0);
+                }
+//#endif
+/*end:modified for android5x , don't kill pppd by lisf 20181221*/
+            }
+#endif
+            if(ppp_fd > 0)
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+            pppd = 0;
+        }
+        responses->ifname = "ppp0";
+    }	
+    else if(dialmode == DIAL_NDIS_MOD)
+    {
+       /*begin:modified "AT$QCRMCALL=0,1" timeout 45s by lisf 20190418 for mantis 0019714*/
+     //   err = at_send_command("AT$QCRMCALL=0,1", NULL);
+        err = at_send_command_timeout("AT$QCRMCALL=0,1",NULL, ATSEND_TIMEOUT_MSEC*4+5000);
+       /*end:modified "AT$QCRMCALL=0,1" timeout 45s by lisf 20190418 for mantis 0019714*/
+        if(ndis_fd > 0)
+        {
+            close(ndis_fd);
+            ndis_fd = -1;
+        }
+        responses->ifname = "usb0";
+    }
+    else if(dialmode == DIAL_ECM_MOD)
+    {
+        RLOGD("%s: ECM_cus_cid:%d", __FUNCTION__, cus_cid);
+        asprintf(&cmd, "AT+GTRNDIS=0,%d", cus_cid);
+        err = at_send_command_timeout(cmd, NULL, 30000);
+        free(cmd);
+        if (GHT_MA510_GL == mode_flag)
+        {
+            responses->ifname = "eth1";
+        }
+        else
+        {
+            responses->ifname = "usb0";
+        }
+
+/*BEGIN: Modified by wujiabao in 2022/05/23, because Android 7 and others need this feature as well*/
+#if 1
+//#if defined GHT_FEATURE_ANDROID10X
+       RLOGD("%s: ECM_NetifName:%s", __FUNCTION__, ECM_NetifName);
+
+       if(mode_flag ==GHT_L716)
+       {
+          asprintf(&cmd, "/system/bin/ip route del default dev %s", ECM_NetifName);
+          RLOGD("%s",cmd);
+          system(cmd);
+          free(cmd);
+       }
+       asprintf(&cmd, "/system/bin/busybox ifconfig %s down", ECM_NetifName);
+       RLOGD("%s",cmd);
+       system(cmd);
+       free(cmd);
+#endif
+/*END:  Modified by wujiabao in 2022/05/23, because Android 7 and others need this feature as well*/
+    }
+
+    responses->status = -1;
+    responses->suggestedRetryTime = -1;
+    responses->cid = 1;
+    responses->active = 0;
+    responses->type = "";
+    responses->addresses = "";
+    responses->dnses = "";
+    responses->gateways = "";
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        response_len = sizeof(RIL_Data_Call_Response_v11);
+        ((RIL_Data_Call_Response_v11 *)responses)->pcscf="";
+        ((RIL_Data_Call_Response_v11 *)responses)->mtu=ODM_MTU_SIZE;
+    }
+
+    RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+        responses, response_len);
+
+    fibocom_pingflag = 0;
+
+#if 0
+/*begin:modfied by lisf for android 8 response 20190114*/
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+      responses->status = -1;
+	responses->suggestedRetryTime = -1;
+	responses->cid = 1;
+	responses->active = 0;
+	responses->type = "";
+	responses->addresses = "";
+	responses->dnses = "";
+	responses->gateways = "";
+	responses->pcscf="";
+	responses->mtu=ODM_MTU_SIZE;
+    RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+            responses, sizeof(RIL_Data_Call_Response_v11));
+#else
+    responses->status = -1;
+    responses->suggestedRetryTime = -1;
+    responses->cid = 1;
+    responses->active = 0;
+    responses->type = "";
+    responses->addresses = "";
+    responses->dnses = "";
+    responses->gateways = "";
+    RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+            responses, sizeof(RIL_Data_Call_Response_v6));
+#endif
+/*end:modfied by lisf for android 8 response 20190114*/
+#endif
+
+}
+
+void OnResumeLTENetwork()
+{
+    int err = 0;
+	//modifed for NL678 
+	if (mode_flag <GHT_NL668)
+	{
+		RLOGD("OnResumeLTENetwork to mododr 2");
+		err = at_send_command("AT+MODODR=2",NULL);
+	}
+	else if(((mode_flag >= GHT_NL668) && (mode_flag <= GHT_NL678_E) )  || (mode_flag == GHT_L716))//modified support for NL668 NORMAL by lisf 20190318 add L716 by gr 20220801
+	{
+	    RLOGD("OnResumeLTENetwork to GTRAT 10");
+	    err = at_send_command("AT+GTRAT=10",NULL);
+	}
+        else if(mode_flag == GHT_FG650)
+        {
+	    RLOGD("OnResumeLTENetwork to GTRAT 20");
+	    err = at_send_command("AT+GTRAT=20",NULL);
+	}
+    onDeactiveDataCallList();
+    return;
+}
+
+//add by gaojing to test at+ecm begin
+static void requestOrSendDataCallList(RIL_Token *t)
+{
+    ATResponse *p_response = NULL;
+    ATLine *p_cur;
+    int err;
+    int n = 0;
+    char *out;
+    char gw[PROPERTY_VALUE_MAX]={0};
+    char *gw_ndis = (char *)calloc(PROPERTY_VALUE_MAX, sizeof(char));
+    char *cmd = NULL; //added route for network unreachable
+
+    /*Begin: Deleted by wujiabao in 2022/07/19, becaues it was not been used*/
+    /*begin:added by lisf for android 5x ping fail 20190115*/
+    //#ifdef GHT_FEATURE_ANDROID5X
+    #if 0
+    char *active_addr = NULL; //added 20190115
+    #endif
+    /*end:added by lisf for android 5x ping fail 20190115*/
+    /*Begin: Deleted by wujiabao in 2022/07/19, becaues it was not been used*/
+
+    int network_type = 0;
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        RIL_Data_Call_Response_v11 *responses = alloca(sizeof(RIL_Data_Call_Response_v11));
+#else
+        RIL_Data_Call_Response_v6 *responses = alloca(sizeof(RIL_Data_Call_Response_v6));
+#endif
+#endif
+    RIL_Data_Call_Response_v6 *responses = (RIL_Data_Call_Response_v6 *)alloca(sizeof(RIL_Data_Call_Response_v6) + 64);
+    int response_len = sizeof(RIL_Data_Call_Response_v6);
+
+
+    if (NULL == gw_ndis || NULL == responses)
+    {
+        RLOGD("calloc mem for gw_ndis or responses failed");
+        goto error;
+    }
+      get_gateway(&gw_ndis);
+      if (DIAL_NDIS_MOD == dialmode || DIAL_ECM_MOD == dialmode)
+      {
+            RLOGD("gateway  [%s]", gw_ndis);
+            strcpy(gw, gw_ndis);
+      }
+
+/*begin:modified by lisf 20181121*/
+    if(mode_flag == GHT_M910_GL)
+    {
+        network_type = odm_get_current_network_type_m910();
+    }
+    else if (mode_flag == GHT_MA510_GL)
+    {
+        network_type = odm_get_current_network_type_ma510();
+    }
+    else
+    {
+        network_type = odm_get_current_network_type();
+    }
+    /*end:added by lisf 20181121*/
+
+     if(6 == network_type || 7 == network_type || 13 == network_type)
+/*end:modified by lisf 20181121*/
+    {
+        char local_ip[PROPERTY_VALUE_MAX]={0};
+        char local_pdns[PROPERTY_VALUE_MAX]={0};
+        char local_sdns[PROPERTY_VALUE_MAX]={0};
+        char dns[PROPERTY_VALUE_MAX*2]={0};
+	//added by lisf for debug 20181220	
+	//char gw[PROPERTY_VALUE_MAX]={0};
+	char remote_ip[PROPERTY_VALUE_MAX]={0};
+        if(dialmode == DIAL_RAS_MOD)
+        {
+            property_get("net.ppp0.local-ip", local_ip, "");
+            property_get("net.ppp0.dns1", local_pdns, "");
+            property_get("net.ppp0.dns2", local_sdns, "");  
+            property_get("net.ppp0.gw", gw, "");
+            property_get("net.ppp0.remote-ip", remote_ip, "");
+            responses->ifname = "ppp0";
+        }
+        else if(dialmode == DIAL_NDIS_MOD)
+        {
+            property_get("net.usb0.local-ip", local_ip, "");
+            property_get("net.usb0.dns1", local_pdns, "");
+            property_get("net.usb0.dns2", local_sdns, "");
+            responses->ifname = "usb0";
+        }
+        else if(dialmode == DIAL_ECM_MOD)
+        {
+            if (GHT_MA510_GL == mode_flag)
+            {
+                property_get("net.eth1.local-ip", local_ip, "");
+                property_get("net.eth1.dns1", local_pdns, "");
+                property_get("net.eth1.dns2", local_sdns, "");
+                responses->ifname = "eth1";
+            }
+            else
+            {
+                property_get("net.usb0.local-ip", local_ip, "");
+                property_get("net.usb0.dns1", local_pdns, "");
+                property_get("net.usb0.dns2", local_sdns, "");
+                property_get("net.usb0.gw", gw, "");
+                responses->ifname = "usb0";
+            }
+        }
+//<!-- add default dns set by wmy@20171019
+/* BEGIN: Modified by eric.li, 2019/1/22   PN:check dns if legal for issue 0015665 */
+        if (PDP_IPV4 == g_apn_pdptype )
+        {
+            if ((dialmode == DIAL_NDIS_MOD||dialmode == DIAL_ECM_MOD) && (-1 == odm_check_dns(local_pdns, local_sdns)))
+            {
+                    if (-1 == odm_fix_dns(local_pdns, local_sdns))
+                    {
+                        memset(local_pdns, 0, sizeof(local_pdns));
+                        sprintf(local_pdns,"%s","8.8.8.8");
+                        memset(local_sdns, 0, sizeof(local_sdns));
+                        sprintf(local_sdns,"%s","8.8.4.4");
+                    }
+            }
+        }
+        sprintf(dns,"%s %s",local_pdns,local_sdns);
+
+        if(0 == strcmp(gw, ""))
+        {
+            memset(gw, 0, sizeof(gw));
+      //      sprintf(gw,"%s","10.64.64.64");
+               strcpy(gw, remote_ip);
+        }
+//end -->
+
+        responses->status = 0;
+        responses->suggestedRetryTime = -1;
+        responses->cid = 1;
+        responses->active = 1;
+        if(PDP_IPV6 == g_apn_pdptype ){
+            responses->type = "IPV6";
+        }
+        else if(PDP_IPV4V6 == g_apn_pdptype){
+            responses->type = "IPV4V6";
+        }
+        else{
+            responses->type = "IP";
+        }
+        responses->addresses = local_ip;
+        responses->dnses = dns;
+        responses->gateways = gw;
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            response_len = sizeof(RIL_Data_Call_Response_v11);
+            ((RIL_Data_Call_Response_v11 *)responses)->pcscf="";
+            ((RIL_Data_Call_Response_v11 *)responses)->mtu=ODM_MTU_SIZE;
+        }
+
+        if (t != NULL)
+            RIL_onRequestComplete(*t, RIL_E_SUCCESS, responses, response_len);
+        else
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED, responses, response_len);
+
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+	{//for  RIL_Data_Call_Response_v11
+	        responses->status = 0;
+	        responses->suggestedRetryTime = -1;
+	        responses->cid = 1;
+	        responses->active = 1;
+            if(PDP_IPV6 == g_apn_pdptype ){
+                responses->type = "IPV6";
+            }
+            else if(PDP_IPV4V6 == g_apn_pdptype){
+                responses->type = "IPV4V6";
+            }
+            else{
+	            responses->type = "IP";
+            }
+	        responses->addresses = local_ip;
+	        responses->dnses = dns;
+	        responses->gateways = gw;
+		 responses->pcscf="";
+		 responses->mtu=ODM_MTU_SIZE;
+	}
+
+#else
+	{// for RIL_Data_Call_Response_v06
+	        responses->status = 0;
+	        responses->suggestedRetryTime = -1;
+	        responses->cid = 1;
+	        responses->active = 1;
+            if(PDP_IPV6 == g_apn_pdptype ){
+                 responses->type = "IPV6";
+            }
+            else if(PDP_IPV4V6 == g_apn_pdptype){
+                 responses->type = "IPV4V6";
+            }
+            else{
+                 responses->type = "IP";
+            }
+	        responses->addresses = local_ip;
+	        responses->dnses = dns;
+	        responses->gateways = gw;
+	}
+#endif
+
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        if (t != NULL)
+            RIL_onRequestComplete(*t, RIL_E_SUCCESS, responses, sizeof(RIL_Data_Call_Response_v11));
+        else
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED, responses, sizeof(RIL_Data_Call_Response_v11));
+#else
+        if (t != NULL)
+            RIL_onRequestComplete(*t, RIL_E_SUCCESS, responses, sizeof(RIL_Data_Call_Response_v6));
+        else
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED, responses, sizeof(RIL_Data_Call_Response_v6));
+#endif
+        //RIL_onRequestComplete(*t,RIL_E_SUCCESS,responses,sizeof(RIL_Data_Call_Response_v6));
+                /* BEGIN: Added by eric.li, 2018/10/11   PN:debug SRCLTE CONNECT FAILURE */
+#endif
+
+        if (NULL != t)
+	{
+		RLOGD("eric debug RIL_E_SUCCESS");
+	}
+	else
+	{
+		RLOGD("eric debug RIL_UNSOL_DATA_CALL_LIST_CHANGED");
+	}
+        /* END:   Added by eric.li, 2018/10/11   PN:debug SRCLTE CONNECT FAILURE */
+
+    }
+    else
+    {
+        err = at_send_command_multiline ("AT+CGACT?", "+CGACT:", &p_response);
+        if (err != 0 || p_response->success == 0)
+        {
+            if (t != NULL)
+                RIL_onRequestComplete(*t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            else
+                RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED, NULL, 0);
+        /* BEGIN: Added by eric.li, 2019/2/18   PN:solve mem leak for switch CT-4g to CT-3g lead to AT+CGACT err */
+            at_response_free(p_response);
+            p_response = NULL;
+            RLOGD("%s,%d,err[%d]", __FUNCTION__,__LINE__,err);
+        /* END:   Added by eric.li, 2019/2/18   PN:solve mem leak for switch CT-4g to CT-3g lead to AT+CGACT err */            
+            return;
+        }
+        responses->status = -1;
+        responses->suggestedRetryTime = -1;
+        responses->cid = -1;
+        responses->active = -1;
+        responses->type = "";
+        responses->ifname = "";
+        responses->addresses = "";
+        responses->dnses = "";
+        responses->gateways = "";
+
+
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            response_len = sizeof(RIL_Data_Call_Response_v11);
+            ((RIL_Data_Call_Response_v11 *)responses)->pcscf="";
+            ((RIL_Data_Call_Response_v11 *)responses)->mtu=ODM_MTU_SIZE;
+        }
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X     //init for  RIL_Data_Call_Response_v11
+        for (i = 0; i < n; i++) {
+            responses[i].status = -1;
+            responses[i].suggestedRetryTime = -1;
+            responses[i].cid = -1;
+            responses[i].active = -1;
+            responses[i].type = "";
+            responses[i].ifname = "";
+            responses[i].addresses = "";
+            responses[i].dnses = "";
+            responses[i].gateways = "";
+	     responses[i].pcscf="";
+	     responses[i].mtu=-1;
+        }
+#else                                   //init for RIL_Data_Call_Response_v06
+        for (i = 0; i < n; i++) {
+            responses[i].status = -1;
+            responses[i].suggestedRetryTime = -1;
+            responses[i].cid = -1;
+            responses[i].active = -1;
+            responses[i].type = "";
+            responses[i].ifname = "";
+            responses[i].addresses = "";
+            responses[i].dnses = "";
+            responses[i].gateways = "";
+        }
+#endif
+#endif
+
+/*Begin:Deleted by wujiabao in 2022/07/19, because it is useless.*/
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    /*begin:modified by lisf 20181201 for RIL8*/
+        RIL_Data_Call_Response_v11 *response = responses;
+    /*end:modified by lisf 20181201 for RIL8*/
+#else
+        RIL_Data_Call_Response_v6 *response = responses;
+#endif
+#endif
+/*End:Deleted by wujiabao in 2022/07/19, because it is useless.*/
+
+
+            int cid, found_flag = 0;
+
+            p_cur = p_response->p_intermediates;
+            char *line = p_cur->line;
+
+            do
+            {
+                err = at_tok_start(&line);
+                if (err < 0)
+                    goto error;
+
+                err = at_tok_nextint(&line, &responses->cid);
+                if (err < 0)
+                    goto error;
+
+                if(responses->cid != cus_cid)
+                {
+                    p_cur = p_cur->p_next;
+                    line = p_cur->line;
+                }
+                else
+                {
+                    found_flag = 1;
+                    break;
+                }
+            }while(p_cur != NULL);
+
+            if(mode_flag == GHT_L716)
+            {
+                //L716 is NULL
+            }
+            else
+            {
+                if(1 != found_flag)
+                {
+                RLOGE("CGACT of the cid %d was not found!", cus_cid);
+                goto error;
+                }
+             }
+
+            err = at_tok_nextint(&line, &(responses->active));
+            if(mode_flag == GHT_L716)
+            {
+                //L716 is NULL
+            }
+            else
+            {
+                if (err < 0)
+                {
+                    goto error;
+                }
+            }
+        at_response_free(p_response);
+        err = at_send_command_multiline ("AT+CGDCONT?", "+CGDCONT:", &p_response);
+        if (err != 0 || p_response->success == 0) {
+            if (t != NULL)
+                RIL_onRequestComplete(*t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            else
+                RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+                        NULL, 0);
+            /* BEGIN: Added by eric.li, 2019/2/18   PN:debug mem leak */
+            RLOGD("%s,%d,err[%d]", __FUNCTION__,__LINE__,err);
+            at_response_free(p_response);
+            p_response = NULL;
+            /* END:   Added by eric.li, 2019/2/18   PN:debug mem leak */
+            return;
+        }
+
+        int i = 0;
+        found_flag = 0;
+
+        for(p_cur = p_response->p_intermediates; p_cur != NULL; p_cur = p_cur->p_next)
+        {
+            line = p_cur->line;
+
+            err = at_tok_start(&line);
+            if (err < 0)
+                goto error;
+        
+            err = at_tok_nextint(&line, &cid);
+            if (err < 0)
+                goto error;
+
+            if(cid != cus_cid)
+            {
+                continue;
+            }
+            else
+            {
+                found_flag = 1;
+                break;
+            }
+
+        }
+
+            if(!found_flag)
+            {
+                RLOGE("CGDCONT of the cid %d was not found!", cus_cid);
+                goto error;
+            }
+
+            // Assume no error
+            responses[i].status = 0;
+
+            // apn type
+            err = at_tok_nextstr(&line, &out);
+            if (err < 0)
+                goto error;
+            responses[i].type = alloca(strlen(out) + 1);
+            strcpy(responses[i].type, out);
+
+            // APN ignored for v5
+            err = at_tok_nextstr(&line, &out); //apn name
+            if (err < 0)
+                goto error;
+
+/*begin:added by lisf for android 5x ping fail 20190115*/
+//<---Start:Modified by Wujiabao in 2022/04/01, because it gets the IP address but it doesn't do anything
+//#ifdef GHT_FEATURE_ANDROID5X
+#if 0
+//----End:Modified by Wujiabao in 2022/04/01, because it gets the IP address but it doesn't do anything>
+            err = at_tok_nextstr(&line, &out);
+            if (err < 0)
+                goto error;
+            active_addr = alloca(strlen(out) + 1);
+            strcpy(active_addr, out);
+#endif
+   /*end:added by lisf for android 5x ping fail 20190115*/
+
+            if(dialmode == DIAL_RAS_MOD)
+            {
+                responses[i].ifname = alloca(strlen(PPP_TTY_PATH) + 1);
+                strcpy(responses[i].ifname, PPP_TTY_PATH);
+            }
+            else if(dialmode == DIAL_NDIS_MOD)
+            {
+                responses[i].ifname = alloca(strlen(NDIS_TTY_PATH) + 1);
+                strcpy(responses[i].ifname, NDIS_TTY_PATH);
+            }
+            else if(dialmode == DIAL_ECM_MOD)
+            {
+                if(cus_netifName_flag)
+                {
+                    responses[i].ifname = alloca(strlen(cus_netifName) + 1);
+                    strcpy(responses[i].ifname, cus_netifName);
+                }
+                else if(GHT_MA510_GL == mode_flag || 1 == eth1_interface)
+                {
+                    responses[i].ifname = alloca(strlen(ECM_TTY_PATH) + 1);
+                    strcpy(responses[i].ifname, ECM_TTY_PATH);
+                }
+                else
+                {
+                    responses[i].ifname = alloca(strlen(NDIS_TTY_PATH) + 1);
+                    strcpy(responses[i].ifname, NDIS_TTY_PATH);
+                }
+            }
+
+            err = at_tok_nextstr(&line, &out);  //ip address
+            if (err < 0)
+                goto error;
+            RLOGD("[%s,%d]AT+CGDCONT: ip_addr:%s", __FUNCTION__, __LINE__, out);
+
+            {
+                char local_ip[PROPERTY_VALUE_MAX]={0};
+                char local_pdns[PROPERTY_VALUE_MAX]={0};
+                char local_sdns[PROPERTY_VALUE_MAX]={0};
+                char dns[PROPERTY_VALUE_MAX*2]={0};
+                char remote_ip[PROPERTY_VALUE_MAX]={0};
+                char *line = NULL;
+                int active = -1;
+                int cid = -1;
+                if(dialmode == DIAL_RAS_MOD)
+                {
+                    property_get("net.ppp0.local-ip", local_ip, "");
+                    property_get("net.ppp0.dns1", local_pdns, "");
+                    property_get("net.ppp0.dns2", local_sdns, "");		
+                    property_get("net.ppp0.gw", gw, "");
+                    property_get("net.ppp0.remote-ip", remote_ip, "");
+                }
+                else if(dialmode == DIAL_NDIS_MOD)
+                {
+                    property_get("net.usb0.local-ip", local_ip, "");
+                    property_get("net.usb0.dns1", local_pdns, "");
+                    property_get("net.usb0.dns2", local_sdns, "");
+                }
+                else if(dialmode == DIAL_ECM_MOD)
+                {
+                    if(cus_netifName_flag)
+                    {
+                        property_get(cus_local_ip, local_ip, "");
+                        property_get(cus_dns1, local_pdns, "");
+                        property_get(cus_dns2, local_sdns, "");
+                        responses->ifname = cus_netifName;
+                    }
+                    else if (GHT_MA510_GL == mode_flag || 1 == eth1_interface)
+                    {
+                        property_get("net.eth1.local-ip", local_ip, "");
+                        property_get("net.eth1.dns1", local_pdns, "");
+                        property_get("net.eth1.dns2", local_sdns, "");
+                        responses->ifname = "eth1";
+                    }
+                    else
+                    {
+                        property_get("net.usb0.local-ip", local_ip, "");
+                        property_get("net.usb0.dns1", local_pdns, "");
+                        property_get("net.usb0.dns2", local_sdns, "");
+                        responses->ifname = "usb0";
+                    }
+                }
+
+                if(PDP_IPV4 == g_apn_pdptype && GHT_MC919 != mode_flag)    //The AT+GTDNS? command of MC919 returns ERROR
+                {
+                    if ((dialmode == DIAL_NDIS_MOD||dialmode == DIAL_ECM_MOD) && (-1 == odm_check_dns(local_pdns, local_sdns)))
+                    {
+                            if (-1 == odm_fix_dns(local_pdns, local_sdns))
+                            {
+                                if(!CHECK_DNS_AVAILABLE(local_pdns))
+                                {
+                                    RLOGE("local_pdns:%s is unavailable, and set to default %s!", local_pdns, DEFAULT_PDNS);
+                                    memset(local_pdns, 0, sizeof(local_pdns));
+                                    sprintf(local_pdns,"%s",DEFAULT_PDNS);
+                                }
+
+                                if(!CHECK_DNS_AVAILABLE(local_sdns))
+                                {
+                                    RLOGE("local_sdns:%s is unavailable, and set to default %s!", local_sdns, DEFAULT_SDNS);
+                                    memset(local_sdns, 0, sizeof(local_sdns));
+                                    sprintf(local_sdns,"%s",DEFAULT_SDNS);
+                                }
+                            }
+                            if(cus_netifName_flag)
+                            {
+                                property_set(cus_dns1, local_pdns);
+                                property_set(cus_dns2, local_sdns);
+                            }
+                            else if(1 == eth1_interface)
+                            {
+                                property_set("net.eth1.dns1", local_pdns);
+                                property_set("net.eth1.dns2", local_sdns);
+                            }
+                            else
+                            {
+                                property_set("net.usb0.dns1", local_pdns);
+                                property_set("net.usb0.dns2", local_sdns);
+                            }
+
+                    }
+                }
+
+                sprintf(dns,"%s %s",local_pdns,local_sdns);
+                responses[i].dnses = alloca(strlen(dns) + 1);
+                strcpy(responses[i].dnses, dns);
+//                property_set("net.usb0.dns1", local_pdns);
+//                property_set("net.usb0.dns2", local_sdns);
+
+                RLOGD("dns:%s",dns);
+
+
+                if(strcmp(local_ip, "") != 0)
+                {
+                    responses[i].addresses = alloca(strlen(local_ip) + 1);
+                    strcpy(responses[i].addresses, local_ip);
+
+                    RLOGD("ip(get from net.xx.local-ip):%s",local_ip);
+                }
+                else
+                {
+                    responses[i].addresses = alloca(strlen(out) + 1);
+                    strcpy(responses[i].addresses, out);
+                    RLOGD("ip(get from AT+CGDCONT):%s",out);
+                }
+                if ((strcmp(gw, "") == 0)||(strcmp(gw, "0.0.0.0") == 0))
+                {
+                    get_gateway(&gw_ndis);
+                    RLOGD("if gateway  [%s]", gw_ndis);
+                    strcpy(gw, gw_ndis);
+                }
+                    RLOGD("gw:[ %s]",gw);
+                    if(dialmode == DIAL_RAS_MOD)
+                        property_set("net.ppp0.gw", gw);
+                    else if (cus_netifName_flag)
+                        property_set(cus_gw,gw);
+                    else if(eth1_interface == 1)
+                        property_set("net.eth1.gw",gw);
+                    else
+                        property_set("net.usb0.gw", gw);
+                    responses[i].gateways = alloca(strlen(gw) + 1);
+                    strcpy(responses[i].gateways, gw);
+
+                    RLOGD("gateways:[%s]",responses[i].gateways);
+
+#if 0
+/* BEGIN: Added by eric.li, 2019/1/3   PN:for ndis dial MTU size */
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+                {
+                    responses[i].mtu = ODM_MTU_SIZE;
+                }
+#endif
+/* END:   Added by eric.li, 2019/1/3   PN:for ndis dial MTU size */
+#endif
+            }
+
+        at_response_free(p_response);
+
+		RLOGD("status [%d],suggestedRetryTime [%d], cid[%d], active[%d], type[%s], ifname[%s], addresses[%s],dnses[%s],gateways[%s]", \
+		                                                    responses->status, \
+		                                                    responses->suggestedRetryTime, \
+		                                                    responses->cid, \
+		                                                    responses->active, \
+		                                                    responses->type, \
+		                                                    responses->ifname, \
+		                                                    responses->addresses, \
+		                                                    responses->dnses, \
+		                                                    responses->gateways);
+
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            RLOGD("pcscf[%s], mtu[%d]", ((RIL_Data_Call_Response_v11 *)responses)->pcscf, ((RIL_Data_Call_Response_v11 *)responses)->mtu);
+        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+		/* BEGIN: Added by eric.li, 2018/10/9   PN:debug CT ppp dail issue */
+		RLOGD("status [%d],suggestedRetryTime [%d], cid[%d], active[%d], type[%s], ifname[%s], addresses[%s],dnses[%s],gateways[%s], pcscf[%s], mtu[%d]", \
+		                                                    responses[0].status, \
+		                                                    responses[0].suggestedRetryTime, \
+		                                                    responses[0].cid, \
+		                                                    responses[0].active, \
+		                                                    responses[0].type, \
+		                                                    responses[0].ifname, \
+		                                                    responses[0].addresses, \
+		                                                    responses[0].dnses, \
+		                                                    responses[0].gateways, \
+		                                                    responses[0].pcscf, \
+		                                                    responses[0].mtu);
+		/* END:   Added by eric.li, 2018/10/9   PN:debug CT ppp dail issue */
+#else
+		/* BEGIN: Added by eric.li, 2018/10/9   PN:debug CT ppp dail issue */
+		RLOGD("status [%d],suggestedRetryTime [%d], cid[%d], active[%d], type[%s], ifname[%s], addresses[%s],dnses[%s],gateways[%s]", \
+		                                                    responses[0].status, \
+		                                                    responses[0].suggestedRetryTime, \
+		                                                    responses[0].cid, \
+		                                                    responses[0].active, \
+		                                                    responses[0].type, \
+		                                                    responses[0].ifname, \
+		                                                    responses[0].addresses, \
+		                                                    responses[0].dnses, \
+		                                                    responses[0].gateways);
+		/* END:   Added by eric.li, 2018/10/9   PN:debug CT ppp dail issue */
+#endif
+#endif
+
+//added for deactive pdp ,don't reply response  by lisf   20181221
+#if 1
+      if(mode_flag == GHT_L716)
+      {
+      }
+      else
+      {
+	    if(!responses->active)
+	    {
+            RLOGD(" debug active #######22222");
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED, responses, response_len);
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+	  /*begin:modified by lisf 20181201 for RIL8*/		
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+                    responses,
+                    n * sizeof(RIL_Data_Call_Response_v11));
+	   /*end:modified by lisf 20181201 for RIL8*/
+#else
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED,
+                    responses,
+                    n * sizeof(RIL_Data_Call_Response_v6));
+#endif
+#endif
+            return;
+         }
+       }
+#endif
+
+        if (t != NULL)
+        {
+            RIL_onRequestComplete(*t, RIL_E_SUCCESS, responses,response_len);
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+            /*begin:modified by lisf 20181201 for RIL8*/
+            RIL_onRequestComplete(*t, RIL_E_SUCCESS, responses,n * sizeof(RIL_Data_Call_Response_v11));/*modify by eric.li, n -> */
+            /*end:modified by lisf 20181201 for RIL8*/
+#else
+            RIL_onRequestComplete(*t, RIL_E_SUCCESS, responses,n * sizeof(RIL_Data_Call_Response_v6));/*modify by eric.li, n -> */
+#endif
+#endif
+        }
+        else
+        {
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED, responses, response_len);
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+            /*begin:modified by lisf 20181201 for RIL8*/
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED,responses,n * sizeof(RIL_Data_Call_Response_v11));
+            /*end:modified by lisf 20181201 for RIL8*/
+#else
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED,responses,n * sizeof(RIL_Data_Call_Response_v6));
+#endif
+#endif
+        }
+
+    if(ANDROID_5 == Ght_Android_Version)
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 5 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+/*begin:added route for network unreachable  20190112*/
+//#ifdef GHT_FEATURE_ANDROID5X
+/*end:added route for network unreachable  20190112*/
+        if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+        {
+            if(dialmode == DIAL_RAS_MOD)
+            {
+                char local_ip[PROPERTY_VALUE_MAX]={0};
+                property_get("net.ppp0.local-ip", local_ip, "");
+                asprintf(&cmd, "busybox ifconfig ppp0 %s",  local_ip);
+                system(cmd);
+                free(cmd);
+                asprintf(&cmd, "ip route del default dev ppp0");
+                RLOGD("%s",cmd);
+                system(cmd);
+                sleep(1);
+                free(cmd);
+                asprintf(&cmd, "ip route add default dev ppp0");
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+                asprintf(&cmd, "ip route add default dev ppp0 table ppp0");
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+            }
+        }
+//#endif
+    }
+    return;
+
+error:
+        if (t != NULL)
+            RIL_onRequestComplete(*t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        else
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED, NULL, 0);
+        if(p_response != NULL)
+            at_response_free(p_response);
+    }
+    free(gw_ndis);
+    gw_ndis = NULL;
+}
+
+//add by gaojing to test at+ecm end
+
+static void requestOrSendDataCallList(RIL_Token *t);
+
+/*called by onUnsolicited() */
+void onDataCallListChanged(void *param __unused)
+{
+    requestOrSendDataCallList(NULL);
+}
+
+void requestDataCallList(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    requestOrSendDataCallList(&t);
+}
+
+
+void requestQueryNetworkSelectionMode(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    ATResponse *p_response = NULL;
+    int response = 0;
+    char *line;
+
+    err = at_send_command_singleline("AT+COPS?", "+COPS:", &p_response);
+
+    if (err < 0 || p_response->success == 0)
+    {
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+    err = at_tok_start(&line);
+
+    if (err < 0)
+    {
+        goto error;
+    }
+
+    err = at_tok_nextint(&line, &response);
+
+    if (err < 0)
+    {
+        goto error;
+    }
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(int));
+    at_response_free(p_response);
+    return;
+error:
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+
+//add by  nodecom aron
+void requestQueryAvailableNetworks(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    /* We expect an answer on the following form:
+       +COPS: (2,"AT&T","AT&T","310410",0),(1,"T-Mobile ","TMO","310260",0)
+       */
+
+    int err, operators, i, status;
+    ATResponse *p_response = NULL;
+    char * c_skip, *line, *p = NULL;
+    char ** response = NULL;
+
+    // <!--[ODM]lindong@2017.11.24 for manual select network
+    RLOGD("[%s,%d],QueryAvailableNetworks Timeout is [%d]ms.\r",__FUNCTION__, __LINE__, QUERY_NETWORK_TIMEOUT);
+    err = at_send_command_singleline_timeout("AT+COPS=?", "+COPS:", QUERY_NETWORK_TIMEOUT, &p_response);
+    // --!>
+
+    if (err < 0 || p_response->success == 0) goto error;
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    /* Count number of '(' in the +COPS response to get number of operators*/
+    operators = 0;
+    for (p = line ; *p != '\0' ; p++)
+    {
+        if (*p == '(') operators++;
+    }
+
+    response = (char **)alloca(operators * 4 * sizeof(char *));
+
+    RLOGD("[%s,%d],operators num[%d],response[%p]\r",__FUNCTION__, __LINE__, operators, response);
+    for (i = 0 ; i < operators ; i++ )
+    {
+        err = at_tok_nextstr(&line, &c_skip);
+        if (err < 0) goto error;
+        RLOGD("[%s,%d],Index[%d], c_skip[%s]\r",__FUNCTION__, __LINE__, i, c_skip);
+        if (strcmp(c_skip,"") == 0)
+        {
+            operators = i;
+            continue;
+        }
+        status = atoi(&c_skip[1]);
+        response[i*4+3] = (char*)networkStatusToRilString(status);
+        RLOGD("[%s,%d],Index[%d], status[%d][%s]\r",__FUNCTION__, __LINE__, i, status, response[i*4+3]);
+
+        err = at_tok_nextstr(&line, &(response[i*4+0]));
+        if (err < 0) goto error;
+        RLOGD("[%s,%d],Index[%d], long[%s]\r",__FUNCTION__, __LINE__, i, response[i*4+0]);
+
+        err = at_tok_nextstr(&line, &(response[i*4+1]));
+        if (err < 0) goto error;
+        RLOGD("[%s,%d],Index[%d], short[%s]\r",__FUNCTION__, __LINE__, i, response[i*4+1]);
+
+        err = at_tok_nextstr(&line, &(response[i*4+2]));
+        if (err < 0) goto error;
+        RLOGD("[%s,%d],Index[%d], digit[%s]\r",__FUNCTION__, __LINE__, i, response[i*4+2]);
+
+        err = at_tok_nextstr(&line, &c_skip);
+
+        if (err < 0) goto error;
+    }
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, response, (operators * 4 * sizeof(char *)));
+    at_response_free(p_response);
+    return;
+
+error:
+    RLOGD("[%s,%d],QueryAvailableNetworks Error\r",__FUNCTION__, __LINE__);
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+
+// <!--added by wangmengying@2017.12.06 for ShunFengFengChao NL660-757S LTE->EVDO shows 1x.
+static void check_net_mode(void)
+{
+    int err;
+    ATResponse *p_response = NULL;
+    int response[4], sys_response[4];
+    char *line;
+
+    int supportedTechs_old = supportedTechs;
+
+    if(GHT_L610 != mode_flag)                //L610 doesn't support this AT
+    {
+        const char *cmd;
+        const char *prefix;
+
+        cmd = "AT^SYSINFO";
+        prefix = "^SYSINFO:";
+
+        err = at_send_command_singleline(cmd, prefix, &p_response);
+
+        if ((err != 0) || (p_response->success == 0) ) goto error;
+
+        line = p_response->p_intermediates->line;
+
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &sys_response[0]);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &sys_response[1]);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &sys_response[2]);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &sys_response[3]);
+        if (err < 0) goto error;
+    }
+
+   char *registration = NULL;
+   registration = get_network_type();
+   RLOGD("get current network1111 %s\r",registration);
+   if(!strncmp(registration, "GPRS",strlen("GPRS")))
+   {
+        response[3]  = 1;
+        supportedTechs = RADIO_TECH_GPRS;
+   }
+   else if(!strncmp(registration, "GSM",strlen("GSM")))
+   {
+        /*begin:modifed supportedTechs 1 ,because of android4  framework can't recognize 16  by lisf 20190418 for mantis 0020107 */
+        response[3]  = 1;//16;
+         supportedTechs = RADIO_TECH_GPRS;//RADIO_TECH_GSM;
+        /*end:modifed supportedTechs 1 ,because of android4  framework can't recognize 16  by lisf 20190418 for mantis 0020107 */
+   }
+    else if(!strncmp(registration, "TDSCDMA",strlen("TDSCDMA")))
+    {
+        response[3]  = 3;
+        supportedTechs = RADIO_TECH_UMTS;
+    }
+    else if(!strncmp(registration, "EGPRS",strlen("EGPRS")))
+    {
+        response[3]  = 2;
+       supportedTechs = RADIO_TECH_EDGE;
+    }
+    else if(!strncmp(registration, "UTRAN",strlen("UTRAN")))
+    {
+        response[3]  = 3;
+        supportedTechs = RADIO_TECH_UMTS;
+    }
+    else if(!strncmp(registration, "HSDPA",strlen("HSDPA")))
+    {
+        response[3]  = 9;
+        supportedTechs = RADIO_TECH_HSDPA;
+    }
+    else if(!strncmp(registration, "HSUPA",strlen("HSUPA")))
+    {
+        response[3]  = 10;
+        supportedTechs = RADIO_TECH_HSUPA;
+    }
+    else if(!strncmp(registration, "HSPA+",strlen("HSPA+")))
+    {
+         response[3] = 15;
+        supportedTechs = RADIO_TECH_HSPAP;
+    }
+    else if(!strncmp(registration, "E-UTRAN",strlen("E-UTRAN")))
+    {
+        response[3]  = 14;
+        supportedTechs = RADIO_TECH_LTE;
+    }
+     else if((!strncmp(registration, "NR-RAN/LTE",strlen("NR-RAN/LTE"))) || (!strncmp(registration, "NR",strlen("NR"))) || (!strncmp(registration, "NG-RAN",strlen("NG-RAN"))))
+    {
+        response[3]  = 20;
+        supportedTechs = RADIO_TECH_LTE_NR;
+    }
+    else if(!strncmp(registration, "E-EVDO",strlen("E-EVDO")) || !strncmp(registration, "CDMA&EVDO",strlen("CDMA&EVDO")))
+    {
+        response[3]  = 7;
+        if((RADIO_TECH_1xRTT != supportedTechs)
+            && (RADIO_TECH_EVDO_0 != supportedTechs)
+            && (RADIO_TECH_EVDO_A != supportedTechs)
+            && (RADIO_TECH_EVDO_B != supportedTechs)
+            && (1 == pppd)
+        )
+        {
+            if((GHT_L610 != mode_flag) && (( 4 == sys_response[3] ) || ( 8 == sys_response[3] ) || ( 2 == sys_response[3] )))
+            {
+              supportedTechs = RADIO_TECH_EVDO_0;
+              onDeactiveDataCallList();
+            }
+        }
+        else
+        {
+            supportedTechs = RADIO_TECH_EVDO_0;
+        }
+    }
+    else if(!strncmp(registration, "CDMA",strlen("CDMA")))
+    {
+        response[3]  = 6;
+        if((RADIO_TECH_1xRTT != supportedTechs)
+            && (RADIO_TECH_EVDO_0 != supportedTechs)
+            && (RADIO_TECH_EVDO_A != supportedTechs)
+            && (RADIO_TECH_EVDO_B != supportedTechs)
+            && (1 == pppd)
+        )
+        {
+            if ((GHT_L610 != mode_flag) && (( 2 == sys_response[3] ) || ( 8 == sys_response[3] ) || ( 4 == sys_response[3] )))
+            {
+                supportedTechs = RADIO_TECH_1xRTT;
+                onDeactiveDataCallList();
+            }
+        }
+        else
+        {
+            supportedTechs = RADIO_TECH_1xRTT;
+        }
+    }
+    else if(!strncmp(registration, "EHRPD",strlen("EHRPD")))
+    {
+        response[3]  = 13;
+        supportedTechs = RADIO_TECH_EHRPD;
+    }
+    else
+    {
+        response[3]  = 0;
+        supportedTechs = -1;
+    }
+    
+    RLOGD("[%s,%d],supportedTechs_old[%d], supportedTechs[%d] ",__FUNCTION__, __LINE__, supportedTechs_old, supportedTechs);
+    if(supportedTechs_old != supportedTechs)
+    {
+        RLOGD("[%s,%d],RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED",__FUNCTION__, __LINE__);
+        RIL_onUnsolicitedResponse (
+                RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED,
+                NULL, 0);
+    }
+    at_response_free(p_response);
+    return;
+
+error:
+    at_response_free(p_response);
+}
+//end -->
+
+//<!-- modify signal trans by caogang@20171025
+#define CDMA_RSSI_THRESH        125
+#define CDMA_RSSI_SPAN      (CDMA_RSSI_THRESH - 75)
+static int SignalStrengthTransform(int Signal)  
+{     
+    if(Signal == 99){
+        return 140;  
+    }
+    return (Signal*3 - 140)*(-1);  //RSRP(44~140)
+} 
+
+static int RSRPTransform(int rsrp)
+{
+    if (rsrp >97 || rsrp <= 0)
+    {
+        return 0x7FFFFFFF;
+    }
+	else
+	{
+	    return 141 - rsrp;
+	}
+}
+
+int getCSQInfo(CSQInfo *csqInfo)
+{
+    int err = -1;
+    ATResponse *p_response = NULL;
+    char *line;
+    int signalStrength = 0;
+    int bitErrorRate = 0;
+
+
+#if 0
+    {
+        int rxlev,ber,rscp,ecno,rsrq,rsrp;
+		
+	    err = at_send_command_singleline("AT+CESQ", "+CESQ:", &p_response);
+
+	    if (err < 0 || p_response->success == 0) 
+		{
+		    goto error;
+	    }
+
+		line = p_response->p_intermediates->line;
+
+	    err = at_tok_start(&line);
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(rxlev));//GERAN
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(ber));
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(rscp));//WCDMA
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(ecno));
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(rsrq));//LTE
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(rsrp));
+	    if (err < 0) goto error;
+
+		RLOGD("It is LTE network, and get rsrp : %d",rsrp);
+		csqInfo->rsrp = rsrp;
+
+    }
+#endif
+
+	{
+	    err = at_send_command_singleline("AT+CSQ", "+CSQ:", &p_response);
+        if (err < 0 || p_response->success == 0) 
+		{
+            goto error;
+        }
+		
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &signalStrength);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &bitErrorRate);
+        if (err < 0) goto error;
+
+        if( signalStrength > 99 && signalStrength < 200)
+        {
+            signalStrength = (signalStrength - 100)*31/91;
+        }
+
+        RLOGD("[%s] get signalStrength :[%d]",__FUNCTION__,signalStrength);
+        RLOGD("[%s] get bitErrorRate :[%d]",__FUNCTION__,bitErrorRate);
+
+        csqInfo->rssi = signalStrength;
+        csqInfo->ber  = bitErrorRate;
+	    csqInfo->rsrp = -1;        // -1 means UNKNOWN
+	}
+
+    if(g_cops_lte == 7 || g_cops_lte == 11 || g_cops_lte == 13)
+    {
+        int rxlev,ber,rscp,ecno,rsrq,rsrp;
+        int ss_rsrq,ss_rsrp,ss_sinr;
+		
+	    err = at_send_command_singleline("AT+CESQ", "+CESQ:", &p_response);
+
+	    if (err < 0 || p_response->success == 0) 
+		{
+		    goto error;
+	    }
+
+		line = p_response->p_intermediates->line;
+
+	    err = at_tok_start(&line);
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(rxlev));//GERAN
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(ber));
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(rscp));//WCDMA
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(ecno));
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(rsrq));//LTE
+	    if (err < 0) goto error;
+
+	    err = at_tok_nextint(&line, &(rsrp));
+	    if (err < 0) goto error;
+
+        if(mode_flag == GHT_FG650)
+        {
+            err = at_tok_nextint(&line, &(ss_rsrq));
+            if (err < 0) goto error;
+
+            err = at_tok_nextint(&line, &(ss_rsrp));
+            if (err < 0) goto error;
+
+            err = at_tok_nextint(&line, &(ss_sinr));
+            if (err < 0) goto error;
+        }
+
+		RLOGD("It is LTE network, and get rsrp : %d",rsrp);
+        if(g_cops_lte == 7)
+        {
+            csqInfo->rsrp = rsrp;
+        }
+        else if(g_cops_lte == 11 || g_cops_lte == 13)
+        {
+            csqInfo->rsrp = ss_rsrp;
+        }
+    }
+
+
+	
+error:
+    at_response_free(p_response);
+    return err;
+}
+
+
+/*Begin: Deleted by wujiabao in 2022/07/19, because we don't need it*/
+#if 0
+void requestSignalStrength_CESQ(void *data, size_t datalen, RIL_Token t)
+{
+    RLOGD("[%s] ====== Enter ",__FUNCTION__);
+    ATResponse *p_response = NULL;
+    int err;
+    char *line;
+    int rxlev = 0;//GERAN
+    int ber = 0;
+    int rscp = 0;//WCDMA
+    int ecno = 0;
+    int rsrq = 0;//LTE
+    int rsrp = 0;
+    int ss_rsrq = 0;//NR
+    int ss_rsrp = 0;
+    int ss_sinr = 0;
+    
+    
+    int cdma_rssi = 0;//wcdma
+    int lte_rssi = 0;//lte
+
+    RIL_SignalStrength_v6 response;
+#if defined GHT_FEATURE_ANDROID6X || defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    RIL_SignalStrength_v10 res;
+    memset(&res, 0, sizeof(res));
+#endif
+    memset(&response, 0, sizeof(response));
+
+    check_net_mode();
+
+    err = at_send_command_singleline("AT+CESQ", "+CESQ:", &p_response);
+
+    if (err < 0 || p_response->success == 0) {
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(rxlev));//GERAN
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(ber));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(rscp));//WCDMA
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(ecno));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(rsrq));//LTE
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(rsrp));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(ss_rsrq));//NR
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(ss_rsrp));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(ss_sinr));
+    if (err < 0) goto error;
+
+    if(g_cops_lte == 2 || g_cops_lte == 6)
+        cdma_rssi = 120 - ecno; // Change it following the modem code.
+    else
+        cdma_rssi = 120;
+    if(g_cops_lte == 7 || g_cops_lte == 13)
+    {
+        lte_rssi = 140 - rsrp; // Change it following the modem code.for LTE
+        if(g_cops_lte == 13)
+        {
+            if(rsrp != 255)
+                lte_rssi = 140 - rsrp;
+            else if(ss_rsrp != 255)
+                lte_rssi = 156 - ss_rsrp;
+            else
+                lte_rssi = 156;
+        }
+    }
+    else if(g_cops_lte == 11 || g_cops_lte == 12)
+        lte_rssi = 156 - ss_rsrp; // Change it following the modem code.
+    else
+        lte_rssi = 156;
+
+
+#if defined GHT_FEATURE_ANDROID6X || defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    res.GW_SignalStrength.signalStrength = rxlev;
+    res.GW_SignalStrength.bitErrorRate = ber;
+/* BEGIN: Modified by eric.li, 2019/2/18   PN:modify for signal strength display issue on UI when switch to CT-3G */
+    res.CDMA_SignalStrength.dbm = cdma_rssi;//-1;
+    res.CDMA_SignalStrength.ecio = cdma_rssi;//-1;
+    res.EVDO_SignalStrength.dbm = cdma_rssi;//-1;
+    res.EVDO_SignalStrength.ecio = cdma_rssi;//-1;
+    res.EVDO_SignalStrength.signalNoiseRatio =0;// -1;
+/* END:   Modified by eric.li, 2019/2/18   PN:modify for signal strength display issue on UI */
+
+    res.LTE_SignalStrength.signalStrength = 0x7FFFFFFF;
+    res.LTE_SignalStrength.rsrp = lte_rssi;
+    res.LTE_SignalStrength.rsrq = 0x7FFFFFFF;
+    res.LTE_SignalStrength.rssnr = 0x7FFFFFFF;
+    res.LTE_SignalStrength.cqi = 0x7FFFFFFF;
+    res.LTE_SignalStrength.timingAdvance = 0x7FFFFFFF;
+    res.TD_SCDMA_SignalStrength.rscp = 0x7FFFFFFF;
+
+    RLOGD("RES***LTE signalStrength=%d, rsrp=%d, rsrq=%d, rssnr=%d, cqi=%d, timingAdvance=%d, rscp=%d\r\n", res.LTE_SignalStrength.signalStrength,\
+    res.LTE_SignalStrength.rsrp, \
+    res.LTE_SignalStrength.rsrq, \
+    res.LTE_SignalStrength.rssnr, \
+    res.LTE_SignalStrength.cqi, \
+    res.LTE_SignalStrength.timingAdvance, \
+    res.TD_SCDMA_SignalStrength.rscp);
+
+    RLOGD("CDMA/EVDO dbm=%d, ecio=%d, dbm=%d, ecio=%d, signalNoiseRatio=%d\r\n", res.CDMA_SignalStrength.dbm,\
+    res.CDMA_SignalStrength.ecio, \
+    res.EVDO_SignalStrength.dbm, \
+    res.EVDO_SignalStrength.ecio, \
+    res.EVDO_SignalStrength.signalNoiseRatio);
+
+    RLOGD("GSM signalStrength=%d, bitErrorRate=%d\r\n", \
+    res.GW_SignalStrength.signalStrength, res.GW_SignalStrength.bitErrorRate);
+
+    
+    if (NULL == t)
+    {
+        RIL_onUnsolicitedResponse(RIL_UNSOL_SIGNAL_STRENGTH, &res, sizeof(RIL_SignalStrength_v10));
+    }
+    else
+    {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, &res, sizeof(RIL_SignalStrength_v10));
+    }
+#else
+
+//GW
+    response.GW_SignalStrength.signalStrength = rxlev;
+    response.GW_SignalStrength.bitErrorRate = ber;
+//CDMA
+//EVDO
+    /**
+     *  Fill the cdma rssi value here. When we fill the actual rssi with 75, the
+     *  SignalStrength.java will deal with it as -75
+     */
+    
+    response.CDMA_SignalStrength.dbm = cdma_rssi;
+    response.CDMA_SignalStrength.ecio = cdma_rssi;
+    response.EVDO_SignalStrength.dbm = cdma_rssi;
+    response.EVDO_SignalStrength.ecio = cdma_rssi;
+//LTE
+    response.LTE_SignalStrength.signalStrength = 0x7FFFFFFF;
+    response.LTE_SignalStrength.rsrp = lte_rssi;
+    response.LTE_SignalStrength.rsrq = 0x7FFFFFFF;
+    response.LTE_SignalStrength.rssnr = 0x7FFFFFFF;
+    response.LTE_SignalStrength.cqi = 0x7FFFFFFF;
+
+    RLOGD("response****LTE signalStrength=%d, rsrp=%d, rsrq=%d, rssnr=%d, cqi=%d\r\n", response.LTE_SignalStrength.signalStrength,\
+    response.LTE_SignalStrength.rsrp, \
+    response.LTE_SignalStrength.rsrq, \
+    response.LTE_SignalStrength.rssnr, \
+    response.LTE_SignalStrength.cqi);
+
+    RLOGD("CDMA/EVDO dbm=%d, ecio=%d, dbm=%d, ecio=%d, signalNoiseRatio=%d\r\n", response.CDMA_SignalStrength.dbm,\
+    response.CDMA_SignalStrength.ecio, \
+    response.EVDO_SignalStrength.dbm, \
+    response.EVDO_SignalStrength.ecio, \
+    response.EVDO_SignalStrength.signalNoiseRatio);
+
+    RLOGD("GSM signalStrength=%d, bitErrorRate=%d\r\n", \
+    response.GW_SignalStrength.signalStrength, response.GW_SignalStrength.bitErrorRate);
+
+    if (NULL == t)
+    {
+        RIL_onUnsolicitedResponse(RIL_UNSOL_SIGNAL_STRENGTH, &response, sizeof(response));
+    }
+    else
+    {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(response));
+    }
+#endif
+    at_response_free(p_response);
+   // err = checkIP();
+  //if (err < 0) goto error; 
+    RLOGD("[%s] ====== Leave ",__FUNCTION__);
+
+    return;
+
+error:
+    RLOGD("requestSignalStrength must never return an error when radio is on");
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+#endif
+/*End: Deleted by wujiabao in 2022/07/19, because we don't need it*/
+
+
+
+static int setSignalStrength(RIL_SignalStrength_v6 *response, int *response_len)
+{
+    int err = -1;
+	int lte_rsrp = 0x7FFFFFFF;
+    CSQInfo csqInfo;
+    int cdma_rssi = 0;
+    
+    if(response == NULL){
+        RLOGE("[%s] parameter err",__FUNCTION__);
+        goto error;
+    }
+    
+    err = getCSQInfo(&csqInfo);
+    if(err){
+        RLOGE("[%s] getCSQInfo err",__FUNCTION__);
+        goto error;
+    }
+    // Change it following the modem code.
+    cdma_rssi = CDMA_RSSI_THRESH - ((csqInfo.rssi * CDMA_RSSI_SPAN) / 31);
+	RLOGD("cdma_rssi : %d",cdma_rssi);
+		
+	
+//These parameters are common
+//GW
+    response->GW_SignalStrength.signalStrength = csqInfo.rssi;
+    response->GW_SignalStrength.bitErrorRate = csqInfo.ber;
+
+//CDMA
+    response->CDMA_SignalStrength.dbm = 0x7FFFFFFF;//-1;
+    response->CDMA_SignalStrength.ecio = 0x7FFFFFFF;//-1;
+
+//EVDO
+    response->EVDO_SignalStrength.dbm = 0x7FFFFFFF;//-1;
+    response->EVDO_SignalStrength.ecio = 0x7FFFFFFF;//-1;
+    response->EVDO_SignalStrength.signalNoiseRatio =0x7FFFFFFF;// -1;
+
+//LTE
+    response->LTE_SignalStrength.signalStrength = csqInfo.rssi;
+    response->LTE_SignalStrength.rsrp = RSRPTransform(csqInfo.rsrp);
+    RLOGD("LTE_SignalStrength.signalStrength: %d",response->LTE_SignalStrength.signalStrength);
+    RLOGD("rsrp after conversion : %d",response->LTE_SignalStrength.rsrp);
+    response->LTE_SignalStrength.rsrq = 0x7FFFFFFF;
+    response->LTE_SignalStrength.rssnr = 0x7FFFFFFF;
+    response->LTE_SignalStrength.cqi = 0x7FFFFFFF;
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        ((RIL_SignalStrength_v10 *)response)->LTE_SignalStrength.timingAdvance = 0x7FFFFFFF;
+        ((RIL_SignalStrength_v10 *)response)->TD_SCDMA_SignalStrength.rscp = 0x7FFFFFFF;
+        *response_len = sizeof(RIL_SignalStrength_v10);
+    }
+
+#if 0
+//These parameters are specific to Android 8,9, and 10
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+//Additional LTE
+    response->LTE_SignalStrength.timingAdvance = 0x7FFFFFFF;
+
+//TD-SCDMA
+    response->TD_SCDMA_SignalStrength.rscp = 0x7FFFFFFF;
+#endif
+#endif
+
+error:
+    return err;
+    RLOGD("Leave %s error.",__FUNCTION__);
+}
+void requestSignalStrength_Generic(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err = -1;
+
+    RIL_SignalStrength_v6 *response = NULL;
+    int response_len = sizeof(RIL_SignalStrength_v6);
+
+    response = (RIL_SignalStrength_v6 *)malloc(sizeof(RIL_SignalStrength_v6) + 64);
+
+    RLOGD("[%s] ====== Enter ",__FUNCTION__);
+
+    memset(response, 0, sizeof(*response));
+
+    if (!((GHT_FG621 == mode_flag) || (GHT_MC919 == mode_flag) || GHT_MC66x == mode_flag))
+    {
+      check_net_mode();
+    }
+
+    err = setSignalStrength(response, &response_len);
+    if(err){
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+    else{
+        if (NULL == t){
+            RIL_onUnsolicitedResponse(RIL_UNSOL_SIGNAL_STRENGTH, response, response_len);
+        }
+        else{
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, response, response_len);
+        }
+    }
+    RLOGD("[%s] ====== Leave ",__FUNCTION__);
+    return;
+}
+
+#if 0
+void requestSignalStrength(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    ATResponse *p_response = NULL;
+    int err;
+    char *line;    
+    int signalStrength = 0;
+    int bitErrorRate = 0;
+    int cdma_rssi = 0;
+    RIL_SignalStrength_v6 response;
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    RIL_SignalStrength_v10 res;
+    memset(&res, 0, sizeof(res));
+#endif
+    memset(&response, 0, sizeof(response));
+
+// <!--added by wangmengying@2017.12.06 for ShunFengFengChao NL660-757S LTE->EVDO shows 1x.
+    check_net_mode();
+//end-->
+    err = at_send_command_singleline("AT+CSQ", "+CSQ:", &p_response);
+
+    if (err < 0 || p_response->success == 0) {
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(signalStrength));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(bitErrorRate));
+    if (err < 0) goto error;
+
+    RLOGD("signalStrength=%d\r\n", signalStrength);
+    RLOGD("bitErrorRate=%d\r\n", bitErrorRate);
+
+    if( signalStrength > 99 && signalStrength < 200)
+    {
+        signalStrength = (signalStrength - 100)*31/91;
+    }
+
+//GW
+    response.GW_SignalStrength.signalStrength = signalStrength;
+    response.GW_SignalStrength.bitErrorRate = bitErrorRate;
+//CDMA
+//EVDO
+    /**
+     *  Fill the cdma rssi value here. When we fill the actual rssi with 75, the
+     *  SignalStrength.java will deal with it as -75
+     */
+    cdma_rssi = CDMA_RSSI_THRESH - ((signalStrength * CDMA_RSSI_SPAN) / 31); // Change it following the modem code.
+    response.CDMA_SignalStrength.dbm = cdma_rssi;
+    response.CDMA_SignalStrength.ecio = cdma_rssi;
+    response.EVDO_SignalStrength.dbm = cdma_rssi;
+    response.EVDO_SignalStrength.ecio = cdma_rssi;
+//LTE
+    response.LTE_SignalStrength.signalStrength = signalStrength;
+    response.LTE_SignalStrength.rsrp = SignalStrengthTransform(signalStrength);
+    response.LTE_SignalStrength.rsrq = 0x7FFFFFFF;
+    response.LTE_SignalStrength.rssnr = 0x7FFFFFFF;
+    response.LTE_SignalStrength.cqi = 0x7FFFFFFF;
+
+    RLOGD("LTE signalStrength=%d, rsrp=%d, rsrq=%d, rssnr=%d, cqi=%d\r\n", response.LTE_SignalStrength.signalStrength,\
+    response.LTE_SignalStrength.rsrp, \
+    response.LTE_SignalStrength.rsrq, \
+    response.LTE_SignalStrength.rssnr, \
+    response.LTE_SignalStrength.cqi);
+
+    RLOGD("CDMA/EVDO dbm=%d, ecio=%d, dbm=%d, ecio=%d, signalNoiseRatio=%d\r\n", response.CDMA_SignalStrength.dbm,\
+    response.CDMA_SignalStrength.ecio, \
+    response.EVDO_SignalStrength.dbm, \
+    response.EVDO_SignalStrength.ecio, \
+    response.EVDO_SignalStrength.signalNoiseRatio);
+
+    RLOGD("GSM signalStrength=%d, bitErrorRate=%d\r\n", \
+    response.GW_SignalStrength.signalStrength, response.GW_SignalStrength.bitErrorRate);
+
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    res.GW_SignalStrength.signalStrength = signalStrength;
+    res.GW_SignalStrength.bitErrorRate = bitErrorRate;
+/* BEGIN: Modified by eric.li, 2019/2/18   PN:modify for signal strength display issue on UI when switch to CT-3G */
+    res.CDMA_SignalStrength.dbm = cdma_rssi;//-1;
+    res.CDMA_SignalStrength.ecio = cdma_rssi;//-1;
+    res.EVDO_SignalStrength.dbm = cdma_rssi;//-1;
+    res.EVDO_SignalStrength.ecio = cdma_rssi;//-1;
+    res.EVDO_SignalStrength.signalNoiseRatio =0;// -1;
+/* END:   Modified by eric.li, 2019/2/18   PN:modify for signal strength display issue on UI */
+
+    res.LTE_SignalStrength.signalStrength = signalStrength;
+    res.LTE_SignalStrength.rsrp = 0x7FFFFFFF;
+    res.LTE_SignalStrength.rsrq = 0x7FFFFFFF;
+    res.LTE_SignalStrength.rssnr = 0x7FFFFFFF;
+    res.LTE_SignalStrength.cqi = 0x7FFFFFFF;
+    res.LTE_SignalStrength.timingAdvance = 0x7FFFFFFF;
+    res.TD_SCDMA_SignalStrength.rscp = 0x7FFFFFFF;
+    if (NULL == t)
+    {
+        RIL_onUnsolicitedResponse(RIL_UNSOL_SIGNAL_STRENGTH, &res, sizeof(RIL_SignalStrength_v10));
+    }
+    else
+    {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, &res, sizeof(RIL_SignalStrength_v10));
+    }
+#else
+    if (NULL == t)
+    {
+        RIL_onUnsolicitedResponse(RIL_UNSOL_SIGNAL_STRENGTH, &response, sizeof(response));
+    }
+    else
+    {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(response));
+    }
+#endif
+    at_response_free(p_response);
+    return;
+
+error:
+    RLOGD("requestSignalStrength must never return an error when radio is on");
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+#else
+void requestSignalStrength(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+}
+#endif
+//end -->
+//added for NL678-E-00
+static int parseRegistrationState(char *str, int *type __unused, int *items, int **response)
+{
+    int err;
+    char *line = str, *p;
+    int *resp = NULL;
+    int skip;
+    int count = 3;
+    int commas;
+
+    RLOGD("parseRegistrationState. Parsing: %s",str);
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    /* Ok you have to be careful here
+     * The solicited version of the CREG response is
+     * +CREG: n, stat, [lac, cid]
+     * and the unsolicited version is
+     * +CREG: stat, [lac, cid]
+     * The <n> parameter is basically "is unsolicited creg on?"
+     * which it should always be
+     *
+     * Now we should normally get the solicited version here,
+     * but the unsolicited version could have snuck in
+     * so we have to handle both
+     *
+     * Also since the LAC and CID are only reported when registered,
+     * we can have 1, 2, 3, or 4 arguments here
+     *
+     * finally, a +CGREG: answer may have a fifth value that corresponds
+     * to the network type, as in;
+     *
+     *   +CGREG: n, stat [,lac, cid [,networkType]]
+     */
+    /* count number of commas */
+    commas = 0;
+    for (p = line ; *p != '\0' ;p++) {
+        if (*p == ',') commas++;
+    }
+
+    resp = (int *)calloc(commas + 1, sizeof(int));
+    if (!resp) goto error;
+    RLOGD("commas = %d\n",commas);
+    switch (commas) {
+        case 0: /* +CREG: <stat> */
+            err = at_tok_nextint(&line, &resp[0]);
+            if (err < 0) goto error;
+            resp[1] = -1;
+            resp[2] = -1;
+            resp[3] = -1;
+            break;
+            
+            case 1: /* +CREG: <n>, <stat> */
+                err = at_tok_nextint(&line, &skip);
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[0]);
+                if (err < 0) goto error;
+                resp[1] = 0;
+                resp[2] = 0;
+                resp[3] = 0;
+                if (err < 0) goto error;
+                RLOGD("resp[] = %d, %d, %d",resp[0], resp[1], resp[2]);
+                break;
+                
+            case 2: /* +CREG: <stat>, <lac>, <cid> */
+                err = at_tok_nextint(&line, &resp[0]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[1]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[2]);
+                if (err < 0) goto error;
+                resp[3] = -1;
+                RLOGD("resp[] = %d, %d, %d",resp[0], resp[1], resp[2]);
+                break;
+            case 3: /* +CREG: <n>, <stat>, <lac>, <cid> */
+                err = at_tok_nextint(&line, &skip);
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[0]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[1]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[2]);
+                if (err < 0) goto error;
+                resp[3] = -1;
+                RLOGD("resp[] = %d, %d, %d",resp[0], resp[1], resp[2]);
+                break;
+            /* special case for CGREG, there is a fourth parameter
+             * that is the network type (unknown/gprs/edge/umts)
+             */
+            case 4: /* +CGREG: <n>, <stat>, <lac>, <cid>, <networkType> */
+            //case 5: /* +CGREG: <n>, <stat>, <lac>, <cid>, <networkType> */
+            case 5: /* +CGREG: <n>, <stat>, <lac>, <cid>, <networkType> */
+            case 6:/*+C5GREG:<n>,<stat>,<tac>,<ci>,<AcT>,<Allowed_NSSAI_length>,<Allowed_NSSAI>*/
+                err = at_tok_nextint(&line, &skip);
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[0]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[1]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[2]);
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[3]);
+                if (err < 0) goto error;
+                count = 4;
+                RLOGD("resp[] = %d, %d, %d, %d",resp[0], resp[1], resp[2], resp[3]);
+                break;
+            default:
+                goto error;
+            }
+    RLOGD("resp[] = %d, %d, %d, %d",resp[0], resp[1], resp[2], resp[3]);
+    if (response)
+        *response = resp;
+    if (items)
+        *items = commas + 1;
+    return 0;
+error:
+    free(resp);
+    return -1;
+}
+
+
+void requestRegistrationState(int request, void *data __unused,size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    int *registration = NULL;
+    char **responseStr = NULL;
+    ATResponse *p_response = NULL;
+    int response[4];
+    const char *cmd;
+    const char *prefix;
+    char *line;
+    int i = 0, j, numElements = 0;
+    int type, startfrom = 0;
+    bool flag_creg = false;
+    bool flag_cereg = false;
+    int count = 3;
+
+    RLOGD("********enter %s********",__FUNCTION__);
+    if (mode_flag < GHT_NL668)
+    {
+    if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE) {
+        cmd = "AT^SYSINFO";
+        prefix = "^SYSINFO:";
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        numElements = 15;
+    }
+    else
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        numElements = 4;
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+	/*begin:modified by lisf 20181201 for RIL8*/	
+	numElements = 15;
+	/*end:modified by lisf 20181201 for RIL8*/
+#else
+        numElements = 4;
+#endif
+#endif
+    } else if (request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+        cmd = "AT^SYSINFO";
+        prefix = "^SYSINFO:";
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        numElements = 6;
+    }
+    else
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        numElements = 4;
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+	/*begin:modified by lisf 20181201 for RIL8*/		
+	numElements = 6;
+	/*end:modified by lisf 20181201 for RIL8*/
+#else
+        numElements = 4;
+#endif
+#endif
+    } else {
+        assert(0);
+        goto error;
+    }
+
+    err = at_send_command_singleline(cmd, prefix, &p_response);
+
+    if ((err != 0) || (p_response->success == 0) ) goto error;
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+    err = at_tok_nextint(&line, &response[0]);
+    if (err < 0) goto error;
+    err = at_tok_nextint(&line, &response[1]);
+    if (err < 0) goto error;
+    err = at_tok_nextint(&line, &response[2]);
+    if (err < 0) goto error;
+    err = at_tok_nextint(&line, &response[3]);
+    if (err < 0) goto error;
+    
+    at_response_free(p_response);
+    p_response = NULL;
+    
+    responseStr = malloc(numElements * sizeof(char *));
+    if (!responseStr) goto error;
+    memset(responseStr, 0, numElements * sizeof(char *));
+    /**
+     * The first '4' bytes for both registration states remain the same.
+     * But if the request is 'DATA_REGISTRATION_STATE',
+     * the 5th and 6th byte(s) are optional.
+     */
+
+    if((request == RIL_REQUEST_VOICE_REGISTRATION_STATE) && (response[0] != 0) && (response[0] != 4)){
+        if(response[1] == 0)
+            asprintf(&responseStr[0], "%d", 0);
+        else if(response[1] == 4)
+            asprintf(&responseStr[0], "%d", 2);
+        else if(response[2] == 1)
+            asprintf(&responseStr[0], "%d", 5);
+        else
+            asprintf(&responseStr[0], "%d", 1);
+    }else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+        asprintf(&responseStr[0], "%d", 0);
+
+    if((request == RIL_REQUEST_DATA_REGISTRATION_STATE) && (response[0] != 0) && ((response[1] == 2) || (response[1] == 3) || (response[1] == 255))){
+        if(response[2] == 1)
+            asprintf(&responseStr[0], "%d", 5);
+        else
+            asprintf(&responseStr[0], "%d", 1);
+    }else if(request == RIL_REQUEST_DATA_REGISTRATION_STATE)
+        asprintf(&responseStr[0], "%d", 0);
+
+    {
+    cmd = "AT+PSRAT";
+    prefix = "+PSRAT:";
+    err = at_send_command_singleline(cmd, prefix, &p_response);
+    if (err == 0 && p_response->success != 0) {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err == 0) {
+            if ((strstr(line, "FDD LTE") != NULL)||(strstr(line, "TDD LTE") != NULL) ||
+                 strstr(line, "SRLTE")||(strstr(line, "LTE")))
+            {
+                response[3] = 14;
+                supportedTechs = RADIO_TECH_LTE;
+            }
+            else if (strstr(line, "TDSCDMA") != NULL)
+            {
+                response[3] = 3;
+                supportedTechs = RADIO_TECH_UMTS;
+            }
+            else if (strstr(line, "HSDPA") != NULL)
+            {
+                response[3] = 9;
+                supportedTechs = RADIO_TECH_HSDPA;
+            }
+            else if (strstr(line, "HSUPA") != NULL)
+            {
+                response[3] = 10;
+                supportedTechs = RADIO_TECH_HSUPA;
+            }
+            else if (strstr(line, "HSPA+") != NULL)
+            {
+                response[3] = 15;
+                supportedTechs = RADIO_TECH_HSPAP;
+            }
+            else if (strstr(line, "GPRS") != NULL)
+            {
+                response[3] = 1;
+                supportedTechs = RADIO_TECH_GPRS;
+            }
+            else if (strstr(line, "EDGE") != NULL)
+            {
+                response[3] = 2;
+                supportedTechs = RADIO_TECH_EDGE;
+            }
+            else if (strstr(line, "WCDMA") != NULL)
+            {
+                response[3] = 3;
+                supportedTechs = RADIO_TECH_UMTS;
+            }
+            else if ((strstr(line, "EVDO") != NULL) || (0 == strcmp(line,"CDMA&EVDO")) || (strstr(line, "HDR") != NULL))
+            {
+                response[3] = 7;
+                supportedTechs = RADIO_TECH_EVDO_0;
+            }
+            else if (strstr(line, "CDMA") != NULL)
+            {
+                response[3] = 6;
+                supportedTechs = RADIO_TECH_1xRTT;
+            }
+            else if (strstr(line, "GSM") != NULL)
+            {
+                response[3] = 16;
+                supportedTechs = RADIO_TECH_GSM;
+            }
+            else if (strstr(line, "EHRPD") != NULL)
+            {
+                response[3] = 13;
+                supportedTechs = RADIO_TECH_EHRPD;
+            }
+            else
+            {
+                response[3] = 0;
+                supportedTechs = -1;
+            }
+        }
+    }
+    at_response_free(p_response);
+    p_response = NULL;
+
+    asprintf(&responseStr[3], "%d", response[3]);
+    }
+
+    if ((supportedTechs == 6) || (supportedTechs == 7) || (supportedTechs == 13)) {
+        startfrom = 0;
+        asprintf(&responseStr[1], "%x", 0);
+        asprintf(&responseStr[2], "%x", 0);
+/*******************************************************************************/
+        if((GHT_NL660 == mode_flag) || (GHT_NL668 == mode_flag))
+        {
+            err = at_send_command_multiline("AT+SCELLINFO","", &p_response);
+            if (err != 0){
+                RLOGD("There is no CELL INFO!");
+            }else{
+             char *skip;
+            ATLine *p_cur;
+            for (i = 0,p_cur = p_response->p_intermediates
+                    ; p_cur != NULL
+                    ; p_cur = p_cur->p_next, i++) {
+                char *line = p_cur->line;
+
+                if (!at_tok_hasmore(&line)) {
+                    continue;
+                }
+                if(i==0){
+                    at_tok_start(&line);
+                    at_tok_nextstr(&line, &skip);
+                    at_tok_nextstr(&line, &skip);
+                }
+                if(i==1){
+                    at_tok_start(&line);
+                    at_tok_nextstr(&line, &skip);
+                }
+                if(i==2){
+                    at_tok_start(&line);
+                    at_tok_nexthexint(&line, &response[1]);
+                    response[1] = -1;
+                    asprintf(&responseStr[1], "%x", response[1]);
+                }
+                if(i==3){
+                    at_tok_start(&line);
+                    at_tok_nexthexint(&line, &response[2]);
+                    response[2] = -1;
+                    asprintf(&responseStr[2], "%x", response[2]);
+                }
+                if(i==4){
+                    at_tok_start(&line);
+                    at_tok_nextstr(&line, &skip);
+                }
+                if(i==5){
+                    at_tok_start(&line);
+                    at_tok_nextstr(&line, &skip);
+                }
+                if (!at_tok_hasmore(&line)) {
+                    continue;
+                }
+                at_tok_nextstr(&line, &skip);
+                if (!at_tok_hasmore(&line)) {
+                    continue;
+                }
+                at_tok_nextstr(&line, &skip);
+
+            }
+        }
+    }
+
+/*******************************************************************************/
+       else{
+       err = at_send_command_multiline("AT+LCTCELLINFO","", &p_response);
+       if (err != 0){
+           RLOGD("There is no CELL INFO!");
+       }else{
+             char *skip;
+            ATLine *p_cur;
+            for (i = 0,p_cur = p_response->p_intermediates
+                    ; p_cur != NULL
+                    ; p_cur = p_cur->p_next, i++) {
+                char *line = p_cur->line;
+
+                if (!at_tok_hasmore(&line)) {
+                    continue;
+                }
+                if(i==0){
+                    at_tok_start(&line);
+                    at_tok_nextstr(&line, &skip);
+                    at_tok_nextstr(&line, &skip);
+                }
+                if(i==1){
+                    at_tok_start(&line);
+                    at_tok_nextstr(&line, &skip);
+                }
+                if(i==2){
+                    at_tok_start(&line);
+                    at_tok_nexthexint(&line, &response[1]);
+                    response[1] = -1;
+                    asprintf(&responseStr[1], "%x", response[1]);
+                }
+                if(i==3){
+                    at_tok_start(&line);
+                    at_tok_nexthexint(&line, &response[2]);
+                    response[2] = -1;
+                    asprintf(&responseStr[2], "%x", response[2]);
+                }
+                if(i==4){
+                    at_tok_start(&line);
+                    at_tok_nextstr(&line, &skip);
+                }
+                if(i==5){
+                    at_tok_start(&line);
+                    at_tok_nextstr(&line, &skip);
+                }
+                if (!at_tok_hasmore(&line)) {
+                    continue;
+                }
+                at_tok_nextstr(&line, &skip);
+                if (!at_tok_hasmore(&line)) {
+                    continue;
+                }
+                at_tok_nextstr(&line, &skip);
+
+            }
+        }
+        }
+/***************************************************************************/
+    }else if(supportedTechs == 14){
+        asprintf(&responseStr[1], "%x", 0);
+        asprintf(&responseStr[2], "%x", 0);
+        startfrom = 0;
+        if(!flag_cereg){
+        err = at_send_command("AT+CEREG=2", NULL);
+        if (err < 0 )
+                flag_cereg = false;
+            else
+                flag_cereg = true;
+        }
+        
+        if(flag_cereg){
+            err = at_send_command_singleline("AT+CEREG?", "+CEREG:", &p_response);
+            if ((err == 0) && (p_response->success != 0)){
+                char *p;
+                int commas = 0;
+                line = p_response->p_intermediates->line;
+                at_tok_start(&line);
+                commas = 0;
+                for (p = line ; *p != '\0' ;p++) {
+                    if (*p == ',') commas++;
+                }
+                if(commas > 2) {
+                    at_tok_nextint(&line, &err);
+                    at_tok_nextint(&line, &err);
+                    at_tok_nexthexint(&line, &response[1]);
+                    // at_tok_nextint(&line, &err); //modified get lte cell id by lisf 20181217
+                    at_tok_nexthexint(&line, &response[2]);
+                    asprintf(&responseStr[1], "%x", response[1]);
+                    asprintf(&responseStr[2], "%x", response[2]);
+                }
+            }
+        }
+    }else if (supportedTechs != -1){
+        asprintf(&responseStr[1], "%x", 0);
+        asprintf(&responseStr[2], "%x", 0);
+        startfrom = 0;
+        if(!flag_creg){
+        err = at_send_command("AT+CREG=2", NULL);
+        if (err < 0)
+                flag_creg = false;
+            else
+                flag_creg = true;
+        }
+        
+        if(flag_creg){
+            err = at_send_command_singleline("AT+CREG?", "+CREG:", &p_response);
+            if ((err == 0) && (p_response->success != 0)){
+                char *p;
+                int commas = 0;
+                line = p_response->p_intermediates->line;
+                at_tok_start(&line);
+                commas = 0;
+                for (p = line ; *p != '\0' ;p++) {
+                    if (*p == ',') commas++;
+                }
+                if(commas > 2) {
+                    at_tok_nextint(&line, &err);
+                    at_tok_nextint(&line, &err);
+                    at_tok_nexthexint(&line, &response[1]);
+                    at_tok_nexthexint(&line, &response[2]);
+                    asprintf(&responseStr[1], "%x", response[1]);
+                    asprintf(&responseStr[2], "%x", response[2]);
+                }
+            }
+        }
+    }
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        if(request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+            asprintf(&responseStr[4],"%d", 0);
+            asprintf(&responseStr[5],"%d",1);
+        }
+        else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+        {
+            for(j = 4 ; j < numElements;j++)
+            {
+                asprintf(&responseStr[j],"%d", 0);
+            }
+        }
+    }
+    else
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        for (j = startfrom; j < numElements; j++)
+        {
+            if (!responseStr[j])
+            {
+                RLOGD("[%s,%d],j[%d]\r",__FUNCTION__, __LINE__, j);
+                goto error;
+            }
+        }
+    }
+
+#if 0
+	/*begin:modified by lisf 20181201 for RIL8*/		
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    if(request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+            asprintf(&responseStr[4],"%d", 0);
+            asprintf(&responseStr[5],"%d",1);
+    }
+    else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+    {
+	     for(j = 4 ; j < numElements;j++)
+	     {
+            		asprintf(&responseStr[j],"%d", 0);
+	     }
+    }
+#else
+    for (j = startfrom; j < numElements; j++)
+    {
+        if (!responseStr[j])
+        {
+            RLOGD("[%s,%d],j[%d]\r",__FUNCTION__, __LINE__, j);
+            goto error;
+        }
+    }
+#endif
+	/*end:modified by lisf 20181201 for RIL8*/	
+#endif
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, responseStr, numElements*sizeof(responseStr));
+    for (j = 0; j < numElements; j++ ) {
+        free(responseStr[j]);
+        responseStr[j] = NULL;
+    }
+    free(responseStr);
+    responseStr = NULL;
+    at_response_free(p_response);
+    return;
+
+    }
+    else if (((mode_flag >= GHT_NL668) && (mode_flag <= GHT_NL678_E)) || (mode_flag == GHT_L716))//modified support for NL668 NORMAL by lisf 20190318
+    {
+        int network_type = 0;
+        network_type = odm_get_current_network_type();
+        at_send_command("AT+CREG=2", NULL);
+        at_send_command("AT+CGREG=2", NULL);
+        at_send_command("AT+CEREG=2", NULL);
+           
+	    if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+	    {
+	        if (network_type == 14)
+	        {
+	            cmd = "AT+CEREG?";
+	            prefix = "+CEREG:";
+	        }
+	        else
+	        {
+	            cmd = "AT+CREG?";
+	            prefix = "+CREG:";
+	        }
+
+            if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+            {
+                RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 15;
+            }
+            else
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 4;
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+		numElements = 15;
+#else
+		numElements = 4;
+#endif
+#endif
+
+	    }
+	    else if (request == RIL_REQUEST_DATA_REGISTRATION_STATE)
+	    {
+	        if (network_type == 14)
+	        {
+	            cmd = "AT+CEREG?";
+	            prefix = "+CEREG:";
+	        }
+	        else
+            {
+                if((ODM_CT_OPERATOR_3G == cur_oper) || (ODM_CT_OPERATOR_4G == cur_oper))
+                {
+                    cmd = "AT+CREG?";
+                    prefix = "+CREG:";
+                }
+                else
+                {
+                    cmd = "AT+CGREG?";
+                    prefix = "+CGREG:";
+                }
+            }
+
+            if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+            {
+                RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 6;
+            }
+            else
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 4;
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+	        numElements = 6;
+#else
+    	    numElements = 4;
+#endif
+#endif
+	    } 
+	    else 
+	    {
+	        assert(0);
+	        goto error;
+	    }
+
+	    err = at_send_command_singleline(cmd, prefix, &p_response);
+
+	    if ((err != 0) || (p_response->success == 0) ) goto error;
+
+	    line = p_response->p_intermediates->line;
+
+	    if (parseRegistrationState(line, &type, &count, &registration)) goto error;
+
+	    responseStr = malloc(numElements * sizeof(char *));
+	    if (!responseStr) goto error;
+	    memset(responseStr, 0, numElements * sizeof(char *));
+	    /**
+	     * The first '4' bytes for both registration states remain the same.
+	     * But if the request is 'DATA_REGISTRATION_STATE',
+	     * the 5th and 6th byte(s) are optional.
+	     */
+	    startfrom = 0;
+	    asprintf(&responseStr[1], "%x", registration[1]);
+	    asprintf(&responseStr[2], "%x", registration[2]);
+           RLOGD("[%d]registration[0][1][2][3] == %d,%d,%d,%d\r\n",__LINE__,registration[0],registration[1],registration[2],registration[3]);
+
+        if (count > 3)
+        {
+            switch(registration[3])
+            {
+                 case 0:
+                 case 1:
+                     registration[3] = RADIO_TECH_GPRS;
+                     break;
+                 case 2:
+                     registration[3] = RADIO_TECH_UMTS;
+                     break;
+                 case 3:
+                     registration[3] = RADIO_TECH_EDGE;
+                     break;
+                 case 4:
+                     registration[3] = RADIO_TECH_HSDPA;
+                     break;
+                 case 5:
+                     registration[3] = RADIO_TECH_HSUPA;
+                     break;
+                 case 6:
+                     registration[3] = RADIO_TECH_HSPA;
+                     break;
+                 case 7:
+                 case 12:
+                     registration[3] = RADIO_TECH_LTE;
+                     break;
+                 case 8:
+                     registration[3] = RADIO_TECH_HSPAP;
+                 case 9:
+                     if(!Net_3G_Support_Flag)
+                     {
+                         registration[3] = RADIO_TECH_LTE;
+                         break;
+                     }
+                 default:
+                     registration[3] = RADIO_TECH_UNKNOWN;
+                     break;
+           }
+           asprintf(&responseStr[3], "%d", registration[3]);
+           RLOGD("registration[3] == %d\r\n",registration[3]);
+        }
+
+	    if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+	    {
+	        if (registration[0] == 6)
+	        {
+	            registration[0] = 1;
+	            RLOGD("registration[0] ==  %d \r\n",registration[0] );
+	        }
+	    }
+	    asprintf(&responseStr[0], "%d", registration[0]);
+	    RLOGD("registration[0] == %d\r\n",registration[0]);
+	    free(registration);
+	    registration = NULL;
+
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            if(request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+                asprintf(&responseStr[4],"%d", 0);
+                asprintf(&responseStr[5],"%d",1);
+            }
+            else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+            {
+                for(j = 4 ; j < numElements;j++)
+                {
+                    asprintf(&responseStr[j],"%d", 0);
+                }
+            }
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            for (j = startfrom; j < numElements; j++)
+            {
+                if (!responseStr[j])
+                {
+                    RLOGD("[%s,%d],j[%d]\r",__FUNCTION__, __LINE__, j);
+                    goto error;
+                }
+            }
+        }
+
+#if 0
+//added by lisf for android8 report data registration and voice registration 20181221
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    if(request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+            asprintf(&responseStr[4],"%d", 0);
+            asprintf(&responseStr[5],"%d",1);
+    }
+    else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+    {
+        for(j = 4 ; j < numElements;j++)
+        {
+            asprintf(&responseStr[j],"%d", 0);
+        }
+    }
+#else
+    for (j = startfrom; j < numElements; j++)
+    {
+        if (!responseStr[j])
+        {
+            RLOGD("[%s,%d],j[%d]\r",__FUNCTION__, __LINE__, j);
+            goto error;
+        }
+    }
+#endif
+#endif
+	    RIL_onRequestComplete(t, RIL_E_SUCCESS, responseStr, numElements*sizeof(responseStr));
+	    for (j = 0; j < numElements; j++ ) {
+	        free(responseStr[j]);
+	        responseStr[j] = NULL;
+	    }
+	    free(responseStr);
+	    responseStr = NULL;
+	    at_response_free(p_response);
+	    return;
+
+
+    }
+    else if(mode_flag == GHT_FG650)
+    {
+        at_send_command("AT+CREG=2", NULL);
+        at_send_command("AT+CGREG=2", NULL);
+        at_send_command("AT+CEREG=2", NULL);
+        at_send_command("AT+C5GREG=2", NULL);
+
+        if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+        {
+            if ((g_cops_lte == 7) || (g_cops_lte ==13))
+            {
+                cmd = "AT+CEREG?";
+                prefix = "+CEREG:";
+            }
+            else if ((g_cops_lte == 11)||(g_cops_lte == 12))
+            {
+                cmd = "AT+C5GREG?";
+                prefix = "+C5GREG:";
+            }
+            else if ((g_cops_lte == 6)||(g_cops_lte == 2))
+            {
+                cmd = "AT+CGREG?";
+                prefix = "+CGREG:";
+            }
+            else if((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+            {
+                cmd = "AT+CGREG?";
+                prefix = "+CGREG:";
+            }
+            else
+            {
+                cmd = "AT+CREG?";
+                prefix = "+CREG:";
+            }
+
+            if((ANDROID_6 == Ght_Android_Version) || (Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11))
+            {
+                RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11, or == 6 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 15;
+            }
+            else
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11, and != 6 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 4;
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID6X || defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+            numElements = 15;
+#else
+            numElements = 4;
+#endif
+#endif
+        }
+        else if (request == RIL_REQUEST_DATA_REGISTRATION_STATE)
+        {
+            if ((g_cops_lte == 7) || (g_cops_lte == 13) )
+            {
+                cmd = "AT+CEREG?";
+                prefix = "+CEREG:";
+            }
+            else if ((g_cops_lte == 11) || (g_cops_lte == 12))
+            {
+                cmd = "AT+C5GREG?";
+                prefix = "+C5GREG:";
+            }
+            else
+            {
+                cmd = "AT+CGREG?";
+                prefix = "+CGREG:";
+            }
+
+            if((ANDROID_6 == Ght_Android_Version) || (Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11))
+            {
+                RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11, or == 6 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 6;
+            }
+            else
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11, and != 6 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 4;
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID6X || defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+            numElements = 6;
+#else
+            numElements = 4;
+#endif
+#endif
+        }
+        else
+        {
+            assert(0);
+            goto error;
+        }
+
+        err = at_send_command_singleline(cmd, prefix, &p_response);
+        if ((err != 0) || (p_response->success == 0) )
+            goto error;
+
+        line = p_response->p_intermediates->line;
+        if (parseRegistrationState(line, &type, &count, &registration))
+            goto error;
+
+        responseStr = malloc(numElements * sizeof(char *));
+        if (!responseStr)
+            goto error;
+
+        memset(responseStr, 0, numElements * sizeof(char *));
+        /**
+        * The first '4' bytes for both registration states remain the same.
+        * But if the request is 'DATA_REGISTRATION_STATE',
+        * the 5th and 6th byte(s) are optional.
+        */
+        startfrom = 0;
+        asprintf(&responseStr[1], "%x", registration[1]);
+        asprintf(&responseStr[2], "%x", registration[2]);
+        if (count > 3)
+        {
+            switch(registration[3])
+            {
+                /* AT response */
+                // 0 GSM
+                // 2 UTRAN
+                // 3 GSM w/EGPRS
+                // 4 UTRAN w/HSDPA
+                // 5 UTRAN w/HSUPA
+                // 6 UTRAN w/HSDPA and HSUPA
+                case 0:
+                    registration[3] = RADIO_TECH_GPRS;
+                    break;
+                case 1:
+                    registration[3] = RADIO_TECH_GPRS;
+                    break;
+                case 2:
+                    registration[3] = RADIO_TECH_UMTS;
+                    break;
+                case 3:
+                    registration[3] = RADIO_TECH_EDGE;
+                    break;
+                case 4:
+                    registration[3] = RADIO_TECH_HSDPA;
+                    break;
+                case 5:
+                    registration[3] = RADIO_TECH_HSUPA;
+                    break;
+                case 6:
+                    registration[3] = RADIO_TECH_HSPA;
+                    break;
+                case 7:
+                    registration[3] = RADIO_TECH_LTE;
+                    break;
+                case 11:
+                case 12:
+                case 13:
+                    registration[3] = RADIO_TECH_LTE_NR;
+                    break;
+                case 8:
+                    registration[3] = RADIO_TECH_HSPAP;
+                    break;
+                default:
+                    registration[3] = RADIO_TECH_UNKNOWN;
+                    break;
+            }
+            asprintf(&responseStr[3], "%d", registration[3]);
+            RLOGD("registration[3] == %d\r\n",registration[3]);
+        }
+        if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+        {
+            if (registration[0] == 6)
+            {
+                registration[0] = 1;
+                RLOGD("voice registration[0] ==  %d \r\n",registration[0] );
+            }
+        }
+        asprintf(&responseStr[0], "%d", registration[0]);
+        RLOGD("registration[0] == %d\r\n",registration[0]);
+        free(registration);
+        registration = NULL;
+
+        if((ANDROID_6 == Ght_Android_Version) || (Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11))
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11, or == 6 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            if(request == RIL_REQUEST_DATA_REGISTRATION_STATE)
+            {
+                asprintf(&responseStr[4],"%d", 0);
+                asprintf(&responseStr[5],"%d",1);
+            }
+            else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+            {
+                for(j = 4 ; j < numElements;j++)
+                {
+                    asprintf(&responseStr[j],"%d", 0);
+                }
+            }
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11, and != 6 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            for (j = startfrom; j < numElements; j++)
+            {
+                if (!responseStr[j])
+                {
+                    RLOGD("[%s,%d],j[%d]\r",__FUNCTION__, __LINE__, j);
+                    goto error;
+                }
+            }
+        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID6X || defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        if(request == RIL_REQUEST_DATA_REGISTRATION_STATE)
+        {
+            asprintf(&responseStr[4],"%d", 0);
+            asprintf(&responseStr[5],"%d",1);
+        }
+        else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+        {
+            for(j = 4 ; j < numElements;j++)
+            {
+                asprintf(&responseStr[j],"%d", 0);
+            }
+        }
+#else
+        for (j = startfrom; j < numElements; j++)
+        {
+            if (!responseStr[j])
+            {
+                RLOGD("[%s,%d],j[%d]\r",__FUNCTION__, __LINE__, j);
+                goto error;
+            }
+        }
+#endif
+#endif
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, responseStr, numElements*sizeof(responseStr));
+        for (j = 0; j < numElements; j++ )
+        {
+            free(responseStr[j]);
+            responseStr[j] = NULL;
+        }
+        free(responseStr);
+        responseStr = NULL;
+        at_response_free(p_response);
+        return;
+    }
+    else if(GHT_H330S == mode_flag)
+    {
+        int network_type = 0;
+        network_type = odm_get_current_network_type();
+        at_send_command("AT+CREG=2", NULL);
+        at_send_command("AT+CGREG=2", NULL);
+
+        cmd = "AT+CREG?";
+        prefix = "+CREG:";
+
+        if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+        {
+
+            if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+            {
+                RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 15;
+            }
+            else
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 4;
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+            numElements = 15;
+#else
+            numElements = 4;
+#endif
+#endif
+        }
+        else if (request == RIL_REQUEST_DATA_REGISTRATION_STATE)
+        {
+
+            if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+            {
+                RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 6;
+            }
+            else
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                numElements = 4;
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+            numElements = 6;
+#else
+            numElements = 4;
+#endif
+#endif
+        } 
+        else 
+        {
+            assert(0);
+            goto error;
+        }
+
+        err = at_send_command_singleline(cmd, prefix, &p_response);
+        if ((err != 0) || (p_response->success == 0) ) goto error;
+
+        line = p_response->p_intermediates->line;
+        if (parseRegistrationState(line, &type, &count, &registration)) goto error;
+
+        responseStr = malloc(numElements * sizeof(char *));
+        if (!responseStr) goto error;
+        memset(responseStr, 0, numElements * sizeof(char *));
+        /**
+        * The first '4' bytes for both registration states remain the same.
+        * But if the request is 'DATA_REGISTRATION_STATE',
+        * the 5th and 6th byte(s) are optional.
+        */
+        startfrom = 0;
+        asprintf(&responseStr[1], "%x", registration[1]);
+        asprintf(&responseStr[2], "%x", registration[2]);
+        RLOGD("[%d]registration[0][1][2][3] == %d,%d,%d,%d\r\n",__LINE__,registration[0],registration[1],registration[2],registration[3]);
+        
+        if (count > 3)
+        {
+            switch(registration[3])
+            {
+                case 0:
+                case 1:
+                case 3:
+                    registration[3] = RADIO_TECH_GPRS;
+                    break;
+                case 2:
+                case 6:                      //NOTE :The return value from this command does not match the AT manual, and there may be an error
+                    registration[3] = RADIO_TECH_UMTS;
+                    break;
+                default:
+                    registration[3] = RADIO_TECH_UNKNOWN;
+                    break;
+            }
+            asprintf(&responseStr[3], "%d", registration[3]);
+            RLOGD("registration[3] == %d\r\n",registration[3]);
+        }
+        
+        if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+        {
+            if (registration[0] == 6)
+            {
+                registration[0] = 1;
+                RLOGD("registration[0] ==  %d \r\n",registration[0] );
+            }
+        }
+        asprintf(&responseStr[0], "%d", registration[0]);
+        RLOGD("registration[0] == %d\r\n",registration[0]);
+        free(registration);
+        registration = NULL;
+
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            if(request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+                asprintf(&responseStr[4],"%d", 0);
+                asprintf(&responseStr[5],"%d",1);
+            }
+            else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+            {
+                for(j = 4 ; j < numElements;j++)
+                {
+                    asprintf(&responseStr[j],"%d", 0);
+                }
+            }
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            for (j = startfrom; j < numElements; j++)
+            {
+                if (!responseStr[j])
+                {
+                    RLOGD("[%s,%d],j[%d]\r",__FUNCTION__, __LINE__, j);
+                    goto error;
+                }
+            }
+        }
+
+#if 0
+        //added by lisf for android8 report data registration and voice registration 20181221
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        if(request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+            asprintf(&responseStr[4],"%d", 0);
+            asprintf(&responseStr[5],"%d",1);
+        }
+        else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+        {
+            for(j = 4 ; j < numElements;j++)
+            {
+                asprintf(&responseStr[j],"%d", 0);
+            }
+        }
+#else
+        for (j = startfrom; j < numElements; j++)
+        {
+            if (!responseStr[j])
+            {
+                RLOGD("[%s,%d],j[%d]\r",__FUNCTION__, __LINE__, j);
+                goto error;
+            }
+        }
+#endif
+#endif
+
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, responseStr, numElements*sizeof(responseStr));
+        for (j = 0; j < numElements; j++ ) {
+            free(responseStr[j]);
+            responseStr[j] = NULL;
+        }
+        free(responseStr);
+        responseStr = NULL;
+        at_response_free(p_response);
+        return;
+    }
+    else{
+        RLOGD("Unknown module, so registration status cannot be recognized");
+        goto error;
+    }
+    RLOGD("********leave %s********",__FUNCTION__);
+
+error:
+    if (responseStr) {
+        for (j = 0; j < numElements; j++) {
+            free(responseStr[j]);
+            responseStr[j] = NULL;
+        }
+        free(responseStr);
+        responseStr = NULL;
+    }
+    RLOGD("RequestRegistrationState must never return an error when radio is on");
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    //at_response_free(p_response);
+    RLOGD("*********Leave %s***********", __FUNCTION__);
+}
+int getCOPSInfo(COPSInfo *copsInfo)
+{
+    int err = -1;
+    ATResponse *p_response = NULL;
+    char *line = NULL;
+    int mode = -1;
+    int format = -1;
+    char *oper = NULL;
+    int Act = 0;
+
+    if(copsInfo == NULL){
+        RLOGE("[%s] parameters err",__FUNCTION__);
+        goto error;
+    }
+    err = at_send_command_singleline("AT+COPS?", "+COPS:", &p_response);
+    if (err < 0 || p_response->success == 0){
+        RLOGE("[%s] at_send_command_singleline err",__FUNCTION__);
+        goto error;
+    }
+    line = p_response->p_intermediates->line;
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+    err = at_tok_nextint(&line, &mode);
+    if (err < 0) goto error;
+    err = at_tok_nextint(&line, &format);
+    if (err < 0) goto error;
+    err = at_tok_nextstr(&line, &oper);
+    if (err < 0) goto error;
+    err = at_tok_nextint(&line, &Act);
+
+    copsInfo->mode = mode;
+    copsInfo->format = format;
+    copsInfo->oper = strdup(oper);
+    copsInfo->Act = Act;
+
+error:
+    at_response_free(p_response);
+    return err;
+}
+
+static int getOperaterStr(char **oper,char **oper1,char **oper2)
+{
+    int err = -1;
+    int i = 0;
+    char *cmd = NULL;
+    COPSInfo copsInfo[3];
+//    int network_debounce_time = 2;
+
+//__operator_restart:
+
+    memset(&copsInfo,0,sizeof(COPSInfo));
+    for(i = 0; i < 3; i++){
+        asprintf(&cmd, "AT+COPS=3,%d", i);
+        at_send_command(cmd, NULL);
+        err = getCOPSInfo(&copsInfo[i]);
+        if(err){
+            goto error;
+        }
+        free(cmd);
+    }
+    
+    RLOGD("[%s] oper:[%s] ",__FUNCTION__,copsInfo[0].oper);
+    RLOGD("[%s] oper:[%s] ",__FUNCTION__,copsInfo[1].oper);
+    RLOGD("[%s] oper:[%s] ",__FUNCTION__,copsInfo[2].oper);
+    
+    *oper   = copsInfo[0].oper;
+    *oper1  = copsInfo[1].oper;
+    *oper2  = copsInfo[2].oper;
+
+    g_cops_lte = copsInfo[2].Act;
+    RLOGD("[%s] set g_cops_lte:[%d] ",__FUNCTION__,g_cops_lte);
+
+error:
+/*
+    if(err && (network_debounce_time > 0)){
+        sleep(1);
+        network_debounce_time--;
+        goto __operator_restart;
+    }
+*/
+    return err;
+}
+void requestOperator_Generic(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err = -1;
+    int i = 0;
+    char *response[3];
+
+    RLOGD("[%s] ====== Enter ",__FUNCTION__);
+    memset(response,0,sizeof(response));
+    
+    err = getOperaterStr(&response[0],&response[1],&response[2]);
+    if(err){
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+    else{
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, response, sizeof(response));
+        for(i = 0; i< 3 ; i++){
+            free(response[i]);
+        }
+    }
+    RLOGD("[%s] ====== Leave ",__FUNCTION__);
+    return;
+}
+/*begin:modified by lisf for get operator 20181208*/
+void requestOperator(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    int i;
+    int skip;
+
+    char *response[3] = {0};
+    char *usol_reresponse[3] = {0};
+    char cmd[32] = {0};
+    char *line = NULL;
+    int findCount = 0;
+    int size_cnt = 0;
+
+    memset(response, 0, sizeof(response));
+
+    ATResponse *p_response = NULL;
+
+    for (i = 0; i < 3; i++)
+    {
+        memset(cmd, 0, sizeof(cmd));
+        snprintf(cmd, sizeof(cmd), "AT+COPS=3,%d", i);
+/* BEGIN: Modified by eric.li, 2018/12/24   PN:sovle issue 0014206 that at+cops=3,0 timeout to reset modem */
+        at_send_command(cmd, NULL);
+/* END:   Modified by eric.li, 2018/12/24   PN:sovle issue 0014206 that at+cops=3,0 timeout to reset modem */
+        err = at_send_command_singleline("AT+COPS?", "+COPS:", &p_response);
+
+        if (err < 0 || p_response->success == 0)
+        {
+            goto error;
+        }
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+
+        err = at_tok_nextint(&line, &skip);
+        if (err < 0) goto error;
+
+        // If we're unregistered, we may just get
+        // a "+COPS: 0" response
+        if (!at_tok_hasmore(&line))
+        {
+            response[i] = NULL;
+            /*Begin: [NA] Moded by liuqifeng if network on register exit SETUP_DATA_CALL 20170801*/
+            g_cops_lte = -1;
+            /*End  : [NA] Moded by liuqifeng if network on register exit SETUP_DATA_CALL 20170801*/
+            if(NULL != p_response)
+            {
+                at_response_free(p_response);
+                p_response = NULL;
+            }
+            continue;
+        }
+
+        err = at_tok_nextint(&line, &skip);
+        if (err < 0) goto error;
+
+        // a "+COPS: 0, n" response is also possible
+        if (!at_tok_hasmore(&line))
+        {
+            response[i] = NULL;
+            /*Begin: [NA] Moded by liuqifeng if network on register exit SETUP_DATA_CALL 20170801*/
+            g_cops_lte = -1;
+            /*End  : [NA] Moded by liuqifeng if network on register exit SETUP_DATA_CALL 20170801*/
+            if(NULL != p_response)
+            {
+                at_response_free(p_response);
+                p_response = NULL;
+            }
+            continue;
+        }
+
+        err = at_tok_nextstr(&line, &(response[i]));
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &g_cops_lte);
+        if (err < 0) goto error;
+        RLOGD("######### g_cops_lte[%d] ########\r\n",g_cops_lte);
+
+        size_cnt = strlen(response[i]) + 1;
+        usol_reresponse[i] = alloca(size_cnt);
+        memset(usol_reresponse[i], 0, size_cnt);
+        strcpy(usol_reresponse[i], response[i]);
+
+        findCount++;
+        
+        at_response_free(p_response);
+        p_response = NULL;     
+    }
+
+    if (findCount != 3)
+    {
+        /* expect 3 lines exactly */
+        /*Begin: [NA] Moded by liuqifeng if network on register exit SETUP_DATA_CALL 20170801*/
+        g_cops_lte = -1;
+        /*End  : [NA] Moded by liuqifeng if network on register exit SETUP_DATA_CALL 20170801*/
+        goto error;
+    }
+
+    RLOGD("%s,%d,[%zu][%zu][%zu]", __FUNCTION__, __LINE__, strlen(usol_reresponse[0]), strlen(usol_reresponse[1]), strlen(usol_reresponse[2]));
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, usol_reresponse, 3 * sizeof(char *));
+    if(NULL != p_response)
+    {
+        at_response_free(p_response);
+        p_response = NULL;
+    }
+
+    return;
+error:
+    RLOGE("requestOperator must not return error when radio is on");
+    /*Begin: [NA] Moded by liuqifeng if network on register exit SETUP_DATA_CALL 20170801*/
+    g_cops_lte = -1;
+    /*End  : [NA] Moded by liuqifeng if network on register exit SETUP_DATA_CALL 20170801*/
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    if(NULL != p_response)
+    {
+        at_response_free(p_response);
+        p_response = NULL;
+    }
+}
+/*end:modified by lisf for get operator 20181208*/
+/**
+ *called by setupDataCallRASMode
+ *
+ * rerurn 0 for success
+ * return 1 for failure
+ */
+static int isReadyForConnetion()
+{
+    return 1;
+#if 0
+#define SUCCESS 0
+#define FAILURE 1
+    ATResponse *p_response;
+    int err;
+    char *line;
+    char *network_type;
+    char *domain;
+
+    err = at_send_command_singleline("AT+ZPAS?", "+ZPAS:", &p_response);
+    if (err < 0 || p_response->success == 0)
+    {
+        goto error;
+    }
+    line = p_response->p_intermediates->line;
+
+    /**
+     * we expect response such as :
+     * +ZPAS:"UMTS","CS_PS"
+     * but sometimes it return
+     * limited service
+     */
+
+    err = at_tok_start(&line);
+    if (err < 0)
+    {
+        goto error;
+    }
+
+    err = at_tok_nextstr(&line,&network_type);
+    if (err < 0)
+    {
+        goto error;
+    }
+    RLOGD("********network_type:%s********",network_type);
+
+    if(at_tok_hasmore(&line))
+
+    {
+        err = at_tok_nextstr(&line,&domain);
+
+        if (err < 0)
+        {
+            goto error;
+        }
+        RLOGD("********domain:%s********",domain);
+
+        if(!strcmp(domain,"CS_PS") || !strcmp(domain,"PS_ONLY") || !strcmp(domain,"cs_ps") || !strcmp(domain,"ps_only"))
+        {
+            return SUCCESS;
+        }
+        else
+        {
+            return FAILURE;
+        }
+
+    }
+    else
+    {
+        return FAILURE;
+    }
+
+error:
+
+    RLOGD("********isReadyForConnetion() error happened********");
+    return FAILURE;
+#endif
+}
+
+//<!-- build 32/64 by caogang@20171025
+#ifndef ODM_ARM64
+//replace system func
+extern char **environ;
+int ril_exec_cmd(const char *command)
+{
+    pid_t pid;
+    sig_t intsave, quitsave;
+    sigset_t mask, omask;
+    int pstat = -1;
+    /*Begin DTS2013101000098  wujiacheng  2013-10-10 for modified*/
+    char buffer[1024] = {0};
+    /*End DTS2013101000098  wujiacheng  2013-10-10 for modified*/
+    char *argp[32] = {0};
+    char *next = buffer;
+    char *tmp = NULL;
+    int i = 0;
+
+    if (!command)
+        return 1;
+
+    if (strnlen(command, sizeof(buffer) - 1) == sizeof(buffer) - 1) {
+        RLOGD("command line too long while processing: %s", command);
+        return -1;
+    }
+
+    strcpy(buffer, command); // Command len is already checked.
+    while ((tmp = strsep(&next, " "))) {
+        if(0 == strlen(tmp))
+        {
+            continue;
+        }
+        argp[i++] = tmp;
+        if (i == 32) {
+            RLOGD("argument overflow while processing: %s", command);
+            return -1;
+        }
+    }
+    argp[i] = NULL;
+
+    sigemptyset(&mask);
+    sigaddset(&mask, SIGCHLD);
+    sigprocmask(SIG_BLOCK, &mask, &omask);
+    switch (pid = vfork())
+    {
+        case -1:                        /* error */
+            sigprocmask(SIG_SETMASK, &omask, NULL);
+            return(-1);
+        case 0:                                 /* child */
+            sigprocmask(SIG_SETMASK, &omask, NULL);
+            execve(argp[0], argp, environ);
+            _exit(127);
+    }
+
+    intsave = (sig_t)  bsd_signal(SIGINT, SIG_IGN);
+    quitsave = (sig_t) bsd_signal(SIGQUIT, SIG_IGN);
+    pid = waitpid(pid, (int *)&pstat, 0);
+    sigprocmask(SIG_SETMASK, &omask, NULL);
+    (void)bsd_signal(SIGINT, intsave);
+    (void)bsd_signal(SIGQUIT, quitsave);
+    return (pid == -1 ? -1 : pstat);
+}
+#endif //ODM_ARM64
+//end -->
+
+/**
+ * called by requestSetupDataCall
+ *
+ * return 0 for success
+ * return 1 for error;
+ */
+static int setupDataCallDefault(const char* apn)
+{
+#define SUCCESS 0
+#define ERROR 1
+    int fd, qmistatus;
+    size_t cur = 0;
+    size_t len;
+    ssize_t written, rlen;
+    char status[32] = {0};
+    int retry = 10;
+    char *cmd;
+    ATResponse *p_response = NULL;
+
+    int err = 0;
+
+    fd = open ("/dev/qmi", O_RDWR);
+    if (fd >= 0)   /* the device doesn't exist on the emulator */
+    {
+
+        RLOGD("opened the qmi device\n");
+        asprintf(&cmd, "up:%s", apn);
+        len = strlen(cmd);
+
+        while (cur < len)
+        {
+            do
+            {
+                written = write (fd, cmd + cur, len - cur);
+            }
+            while (written < 0 && errno == EINTR);
+
+            if (written < 0)
+            {
+                RLOGD("### ERROR writing to /dev/qmi");
+                close(fd);
+                goto error;
+            }
+
+            cur += written;
+        }
+        // wait for interface to come online
+        do
+        {
+            sleep(1);
+            do
+            {
+                rlen = read(fd, status, 31);
+            }
+            while (rlen < 0 && errno == EINTR);
+
+            if (rlen < 0)
+            {
+                RLOGD("### ERROR reading from /dev/qmi");
+                close(fd);
+                goto error;
+            }
+            else
+            {
+                status[rlen] = '\0';
+                RLOGD("### status: %s", status);
+            }
+        }
+        while (strncmp(status, "STATE=up", 8) && strcmp(status, "online") && --retry);
+
+        close(fd);
+
+        if (retry == 0)
+        {
+            RLOGD("### Failed to get data connection up\n");
+            goto error;
+        }
+
+        qmistatus = system("netcfg rmnet0 dhcp");
+
+        RLOGD("netcfg rmnet0 dhcp: status %d\n", qmistatus);
+
+        if (qmistatus < 0) goto error;
+
+    }
+    else
+    {
+        asprintf(&cmd, "AT+CGDCONT=%d,\"IP\",\"%s\",,0,0", cus_cid, apn);
+        //FIXME check for error here
+        err = at_send_command(cmd, NULL);
+        free(cmd);
+
+        // Set required QoS params to default
+        err = at_send_command("AT+CGQREQ=1", NULL);
+
+        // Set minimum QoS params to default
+        err = at_send_command("AT+CGQMIN=1", NULL);
+
+        // packet-domain event reporting
+        err = at_send_command("AT+CGEREP=2,1", NULL);
+
+        // Hangup anything that's happening there now
+        err = at_send_command("AT+CGACT=1,0", NULL);
+
+        // Start data on PDP context 1
+        err = at_send_command("ATD*99***1#", &p_response);
+
+        if (err < 0 || p_response->success == 0)
+        {
+            goto error;
+        }
+    }
+    at_response_free(p_response);
+    return SUCCESS;
+error:
+    at_response_free(p_response);
+    return ERROR;
+}
+//added by lisf for get pid 20181210
+int get_pid(char *name)
+{
+    char cmd[20] = { 0 };
+    char szbuf[100] = { 0 };
+    char *p_pid = NULL;
+    FILE *pFile = NULL;
+    int pid = 0;
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        sprintf(cmd, "ps  -e| grep %s", name);
+    }
+    else
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        sprintf(cmd, "ps | grep %s", name);
+    }
+
+#if 0
+/* BEGIN: Modified by eric.li, 2018/12/28   PN:0015062 */
+/*Begin: [NA] Moded by liuqifeng fixed kill pppd or dhcp failed in android6.0 system 20170814*/
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+	sprintf(cmd, "ps  -e| grep %s", name);
+#else
+	sprintf(cmd, "ps | grep %s", name);
+#endif
+/*End  : [NA] Moded by liuqifeng fixed kill pppd or dhcp failed in android6.0 system 20170814*/
+/* END:   Modified by eric.li, 2018/12/28   PN:0015062 */
+#endif
+
+    pFile = popen(cmd, "r");
+    if (pFile != NULL) {
+        while (fgets(szbuf, sizeof(szbuf), pFile)) {
+            if (strstr(szbuf, name)) {
+                p_pid = strstr(szbuf, " ");
+                if(p_pid!=NULL)
+                {
+                    pid = strtoul(p_pid, NULL, 10);
+                }
+                RLOGD("--- PPPD PID = %d ---", pid);
+                break;
+            }
+        }
+        pclose(pFile);
+    }
+
+    pclose(pFile);
+    return pid;
+}
+//added by lisf for kill pppd 20181210
+void ril_kill_pppd(int flag)
+{
+    int pppd_pid ;
+    //= get_pid("pppd");
+    int count = 50;
+
+ while(--count >= 0)
+    {
+        pppd_pid = get_pid("pppd");
+        if (pppd_pid)
+        {
+            if(1 == flag && count > 45)
+            {
+                kill(pppd_pid, SIGTERM);
+            }
+            else
+            {
+                kill(pppd_pid, SIGKILL);
+            }
+            sleep(1);
+        }
+        else
+        {
+            break;
+        }
+    }
+    pppd_pid = get_pid("pppd");
+    RLOGD("pppd is %d , killed %d times", pppd_pid, 50-count);
+}
+
+static int dial_at_modem(int fd)
+{
+    int readlen = 0;
+    char pch[129] = { 0 };
+    time_t readtime;
+    const char *match_msg = "CONNECT";
+    const char *match_err_msg = "NO CARRIER";
+    const char *match_err_msg_2 = "ERROR";
+    time_t gettime;
+    int  cur, i;
+    i = 0;
+    cur = 0;
+
+    // disable echo on serial lines and set a 10 second timeout
+    RLOGD("modem : read");
+    readtime = time(&gettime);
+    // <!--[ODM]wangmengying@2019.8.16 [SN-20190712001,SN-20190608001]optimization ppp time
+    while ((time(&gettime) - readtime) <= 3)
+    // end-->
+	{
+        readlen = read(fd, pch, 64);
+        if (readlen <= 0 &&( errno == EINTR ||errno == EAGAIN)) {
+          //  RLOGD("read none");
+	     //sleep(1);
+            continue;
+        } else if (readlen > 0) {
+            pch[readlen] = '\0';
+	     RLOGD("====== read from modem:readlen,%d=======", readlen);
+            RLOGD("====== read from modem:%s=======", pch);
+            if (strstr(pch, match_msg)) {
+                RLOGD("read CONNECT");
+                return 0;
+            } else if (strstr(pch, match_err_msg)) {
+                RLOGD("read NO CARRIER");
+                return AT_ERROR_GENERIC;
+            }
+            else if(strstr(pch, match_err_msg_2))
+            {
+                RLOGD("read ERROR");
+                return AT_ERROR_GENERIC;
+            }
+        }
+    }
+    RLOGD("dial_at_modem return");
+    return 1;
+}
+
+/**
+ * called by requestSetupDataCall
+ *
+ * return 0 for success
+ * return 1 for error;
+ * return 2 for ppp_error;
+ */
+static int setupDataCallRASMode(char**response_local_ip,const char* apn,const char* auth_type,const char* username,const  char* password,const char* pdp_type)
+{
+    #define SUCCESS 0
+    #define ERROR 1
+    #define PPP_ERROR 2
+
+    int fd;
+    char buffer[20];
+    char exit_code[PROPERTY_VALUE_MAX]={0};
+    char local_ip[PROPERTY_VALUE_MAX]={0};
+    char local_pdns[PROPERTY_VALUE_MAX]={0};
+    char local_sdns[PROPERTY_VALUE_MAX]={0};
+
+    char gw[PROPERTY_VALUE_MAX]={0};
+    char remote_ip[PROPERTY_VALUE_MAX]={0};
+
+    int retry = POLL_PPP_SYSFS_RETRY;
+    char apntype[PROPERTY_VALUE_MAX];
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char*cmd =NULL;
+    char*line =NULL;
+    /*begin:added by for NL678 ppp dial 20190129*/
+    char *pppd_cmd = NULL ; 
+
+    int network_type = 0;
+    char datachannel[PROPERTY_VALUE_MAX]={0};
+
+    RLOGD("******** Enter setupDataCallRASMode ********");
+
+    property_get("ril.datachannel",datachannel,"");
+
+// <!--added by wangmengying@2020.2.27 add CGPIAF set IPV6 address format
+    err = at_send_command_singleline("AT+CGPIAF?", "+CGPIAF:", &p_response);
+    if (err < 0 || p_response->success == 0)
+    {
+        RLOGD("Not support this command!!!");
+    }
+    else
+    {
+        line = p_response->p_intermediates->line;
+        at_tok_start(&line);
+        at_tok_nextint(&line,&format_ip);
+    }
+
+    at_response_free(p_response);
+    p_response = NULL;
+
+    network_type = odm_get_current_network_type();
+
+    pppd = 0;//added by lisf for debug 20190131
+    if(get_pid("pppd"))
+    {
+        err = at_send_command("ATH", NULL);
+        property_set("ctl.stop", SERVICE_PPPD_GPRS);
+
+        if(ANDROID_5 != Ght_Android_Version)
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d != 5 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            ril_kill_pppd(0);
+        }
+
+#if 0
+        /*begin:modified for android5x , don't kill pppd by lisf 20181221*/
+        #ifndef GHT_FEATURE_ANDROID5X
+        ril_kill_pppd(0);
+        #endif
+        /*end:modified for android5x , don't kill pppd by lisf 20181221*/
+#endif
+    }
+
+    g_apn_pdptype = odm_get_pdptype(pdp_type);
+
+    getSetAPN(cus_cid, pdp_type, apn);
+
+    if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+    {
+        if((username != NULL) && (password != NULL))
+        {
+            if (mode_flag < GHT_NL668)
+            {
+                asprintf(&cmd, "AT^PPPCFG=\"%s\",\"%s\"", username, password);
+                err = at_send_command(cmd, NULL);
+                free(cmd);
+            }
+        }
+    }
+
+    if((username != NULL) && (password != NULL))
+    {
+        if ((0 != strlen(username)) || (0 != strlen(password)))
+        {
+            if (mode_flag < GHT_NL668)
+            {
+                asprintf(&cmd, "AT$QCPDPP=1,%s,\"%s\",\"%s\"", auth_type, password, username);
+            }
+            else
+            {
+                asprintf(&cmd, "AT+MGAUTH=1,%s,\"%s\",\"%s\"",auth_type,username,password);
+            }
+            err = at_send_command(cmd, NULL);
+            free(cmd);
+
+            property_set("net.ppp0.user", username);
+            property_set("net.ppp0.password", password);
+        }
+    }
+
+    property_set(PROPERTY_PPPD_EXIT_CODE, "");
+
+    RLOGD("[%s,%d]script_type:%d, ppp_fd:%d", __FUNCTION__, __LINE__, script_type, ppp_fd);
+    if(0 == script_type)
+    {
+        do
+        {
+            if(ppp_fd > 0)
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+
+        /*begin:modified for NL678-E ppp dial 20190129*/
+        if(mode_flag  <= GHT_NL678_E || mode_flag == GHT_L716)
+        {
+            ppp_fd = open(datachannel, O_RDWR | O_NONBLOCK | O_NOCTTY);
+        }
+        else
+        {
+                 ppp_fd = open(datachannel, O_RDWR);
+        }
+        /*end:modified for NL678-E ppp dial 20190129*/
+
+        if (ppp_fd > 0)
+        {
+            struct termios ios;
+
+            tcgetattr(ppp_fd, &ios);
+            ios.c_lflag = 0;
+
+            /*begin:added for NL678-E ppp dial 20190129*/
+            if(mode_flag  <= GHT_NL678_E|| mode_flag == GHT_L716)
+            {
+                ios.c_oflag &= (~ONLCR);
+                ios.c_iflag &= (~(ICRNL | INLCR));
+                ios.c_iflag |= (IGNCR | IXOFF);
+                ios.c_cc[VTIME] = 10;
+                ios.c_cc[VMIN] = 0;
+            }
+            /*end:added for NL678-E ppp dial 20190129*/
+            tcsetattr(ppp_fd, TCSANOW, &ios);
+            tcflush(ppp_fd, TCIOFLUSH);
+
+            //network_type = odm_get_current_network_type();
+            if(!network_type)
+            {
+                RLOGD("No service,can not setup data call");
+                if(ppp_fd > 0)
+                {
+                    close(ppp_fd);
+                    ppp_fd = -1;
+                }
+                goto error;
+            }
+            else if(6 == network_type || 7 ==network_type || 13 ==network_type)
+            {
+                /*begin:added by lisf for switch cdma & evdo*/
+                if(GHT_MDM_NORMAL == mode_flag)
+                {
+                    RIL_onUnsolicitedResponse( RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);  //added by lisf 20190323
+                }
+                err = at_send_command_dial(ppp_fd, "ATD#777");
+            }
+            else
+            {
+                err = at_send_command_dial(ppp_fd, "ATD*99#");
+            }
+
+            if(mode_flag  <= GHT_NL678_E || mode_flag == GHT_L716)
+            {
+                err = dial_at_modem(ppp_fd);
+                if(err < 0 || err ==1)
+                {
+                    RLOGD("send dial command failed!");
+                    close(ppp_fd);
+                    ppp_fd = -1;
+                }
+                else
+               {
+                    break;
+               }
+            }
+            else
+            {
+                if (err < 0 && mode_flag  != GHT_NL678_E)
+                {
+                    RLOGD("send dial command failed!");
+                    close(ppp_fd);
+                     ppp_fd = -1;
+                }
+                break;
+            }
+        }
+        else
+        {
+            close(ppp_fd);
+            ppp_fd = -1;
+            RLOGD("retry %d after %d seconds", retry, POLL_PPP_SYSFS_SECONDS);
+            sleep(POLL_PPP_SYSFS_SECONDS);
+        }
+        }while(--retry);
+
+        if ((ppp_fd < 0) && (retry == 0))
+        {
+            close(ppp_fd);
+            ppp_fd = -1;
+            RLOGD("open ppp_fd fail!");
+
+            /* BEGIN: Added by eric.li, 2019/2/1   PN:fix exception with ppp dial in modem */
+            err = at_send_command("ATH", NULL);
+            RLOGD("ppp dial  force hang up in case exception");
+            /* END:   Added by eric.li, 2019/2/1   PN:fix exception with ppp dial in modem */
+
+            goto error;
+        }
+
+        if(!network_type)
+        {
+            RLOGD("No service,can not setup data call");
+            if(ppp_fd > 0)
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+            goto error;
+        }
+        else if(6 == network_type || 7 ==network_type || 13 ==network_type)
+        {
+            if (0 == strcmp(auth_type,"1"))
+            {
+                /* BEGIN: Modified by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+                if (PDP_IPV4V6 == g_apn_pdptype || PDP_IPV6 == g_apn_pdptype)
+                {
+                    asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts user %s password %s usepeerdns noipdefault debug ipcp-accept-local ipcp-accept-remote defaultroute -chap +ipv6 ipv6cp-use-ipaddr",datachannel,username,password);
+                }
+                else
+                {
+                    asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts user %s password %s usepeerdns noipdefault debug ipcp-accept-local ipcp-accept-remote defaultroute -chap ",datachannel,username,password);
+                }
+                /* END:   Modified by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+            }
+            else
+            {
+                /* BEGIN: Modified by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+                if (PDP_IPV4V6 == g_apn_pdptype || PDP_IPV6 == g_apn_pdptype)
+                {
+                    asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts user %s password %s usepeerdns  noipdefault debug ipcp-accept-local ipcp-accept-remote defaultroute +ipv6 ipv6cp-use-ipaddr",datachannel,username,password);
+                }
+                else
+                {
+                    asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts user %s password %s usepeerdns  noipdefault debug ipcp-accept-local ipcp-accept-remote defaultroute",datachannel,username,password);
+                }
+                /* END:   Modified by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+            }
+        }
+        else
+        {
+            //modify by zhengjianrong for IPV4V6 switch to IPV6 issue 20190528 begin
+            if(PDP_IPV6 == g_apn_pdptype || PDP_IPV4V6 == g_apn_pdptype || PDP_IPV4 == g_apn_pdptype)
+            {
+                property_set("net.ppp0.gw", "");
+            }
+            //modify by zhengjianrong for IPV4V6 switch to IPV6 issue 20190528 end
+
+            if((username != NULL) && (password != NULL))
+            {
+                /* BEGIN: Modified by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+                if (PDP_IPV4V6 == g_apn_pdptype || PDP_IPV6 == g_apn_pdptype)
+                {
+                  asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts user %s password %s usepeerdns noipdefault debug ipcp-accept-local ipcp-accept-remote defaultroute +ipv6 ipv6cp-use-ipaddr",datachannel,username,password);
+                }
+                else
+                {
+                  asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts user %s password %s usepeerdns noipdefault debug ipcp-accept-local ipcp-accept-remote defaultroute",datachannel,username,password);
+                }
+                /* END:   Modified by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+            }
+            else
+            {
+                /* BEGIN: Modified by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+                if (PDP_IPV4V6 == g_apn_pdptype || PDP_IPV6 == g_apn_pdptype)
+                {
+                  asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts usepeerdns noipdefault debug ipcp-accept-local ipcp-accept-remote defaultroute +ipv6 ipv6cp-use-ipaddr",datachannel);
+                }
+                else
+                {
+                  asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts usepeerdns noipdefault debug ipcp-accept-local ipcp-accept-remote defaultroute",datachannel);
+                }
+                /* END:   Modified by eric.li, 2019/1/28   PN:solve issue 0016245 that support IPV4V6 */
+            }
+        }
+        RLOGD("%s",cmd);
+        system(cmd);
+
+        /*begin: modified for NL678-E ppp dial by lisf 20190111*/
+        if(mode_flag  == GHT_NL678_E)
+        {
+            asprintf(&pppd_cmd,"%s",cmd); 
+        }
+        /*end: modified for NL678-E ppp dial by lisf 20190111*/
+
+        gPid_pppd_live = get_pid("pppd");
+        RLOGD(" gPid_pppd_died[%d], gPid_pppd_live[%d]", gPid_pppd_died, gPid_pppd_live);
+        if (gPid_pppd_died  == gPid_pppd_live)
+        {
+            RLOGD("!!!!!!!!!!!pppd call failed as kill pppd failed!");
+        }
+        free(cmd);
+    }
+    else if(1 == script_type)
+    {
+        do
+        {
+            if(ppp_fd > 0)
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+
+            ppp_fd = open(datachannel, O_RDWR);
+            if (ppp_fd > 0)
+            {
+                struct termios ios;
+                tcgetattr(ppp_fd, &ios);
+                ios.c_lflag = 0;
+                tcsetattr(ppp_fd, TCSANOW, &ios);
+                tcflush(ppp_fd, TCIOFLUSH);
+
+                //network_type = odm_get_current_network_type();
+                if(!network_type)
+                {
+                    RLOGD("No service,can not setup data call");
+                    if(ppp_fd > 0)
+                    {
+                        close(ppp_fd);
+                        ppp_fd = -1;
+                    }
+                    goto error;
+                }
+                else if(6 == network_type || 7 ==network_type || 13 ==network_type)
+                {
+                    err = at_send_command_dial(ppp_fd, "ATD#777");
+                }
+                else
+                {
+                    err = at_send_command_dial(ppp_fd, "ATD*99#");
+                }
+
+                if (err < 0)
+                {
+                    RLOGD("send dial command failed!");
+                }
+                break;
+            }
+            else
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+                RLOGD("retry %d after %d seconds", retry, POLL_PPP_SYSFS_SECONDS);
+                sleep(POLL_PPP_SYSFS_SECONDS);
+            }
+        }while(--retry);
+
+        if ((ppp_fd < 0) && (retry == 0))
+        {
+            RLOGD("open ppp_fd fail!");
+            goto error;
+        }
+
+        retry = POLL_PPP_SYSFS_RETRY;
+        property_set(PROPERTY_PPPD_EXIT_CODE, "");
+        err = property_set("ctl.start", SERVICE_PPPD_GPRS);
+        if (err < 0)
+        {
+            RLOGD("Can not start PPPd");
+            goto error;
+        }
+    }
+    else if(2 == script_type)
+    {
+        if(!network_type)
+        {
+            RLOGD("No service,can not setup data call");
+            goto error;
+        }
+
+        err = property_set("ctl.start", SERVICE_PPPD_GPRS);
+        if (err < 0)
+        {
+            RLOGD("Can not start use modem to connect internet\n");
+            goto ppp_error;
+        }
+    }
+    else if(3 == script_type)
+    {
+        if(!network_type)
+        {
+            RLOGD("No service,can not setup data call");
+            goto error;
+        }
+        property_set("net.gprs.enable", "1");
+        err = property_set("ctl.start", SERVICE_PPPD_GPRS);
+    }
+
+    RLOGD("[%s,%d] g_apn_pdptype:%d", __FUNCTION__, __LINE__, g_apn_pdptype);
+    sleep(3);
+    pppd = 1;
+
+    if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+    {
+        retry = 15;
+    }
+    else
+    {
+        retry = 3;
+    }
+
+    if (PDP_IPV6 == g_apn_pdptype || PDP_IPV4V6 == g_apn_pdptype)
+    {
+        if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+        {
+            sleep(5);
+        }
+        if (6 == network_type || 7 ==network_type || 13 ==network_type)
+        {
+            RLOGD("Not support 3GPP2");
+        }
+        else
+        {
+            rilInitIPV6();
+        }
+    }
+
+    do
+    {
+        property_get(PROPERTY_PPPD_EXIT_CODE, exit_code, "");
+        if(strcmp(exit_code, "") != 0)
+        {
+            RLOGD("PPPd exit with code %s", exit_code);
+            retry = 0;
+            break;
+        }
+
+        fd  = open(PPP_OPERSTATE_PATH, O_RDONLY);
+        if (fd >= 0)
+        {
+            buffer[0] = 0;
+            memset(buffer,0,sizeof(buffer)) ;//added by lisf for debug 20181219
+            read(fd, buffer, sizeof(buffer));
+            close(fd);
+
+            if(!strncmp(buffer, "up", strlen("up")) || !strncmp(buffer, "unknown", strlen("unknown")))
+            {
+                local_ip[0] = 0;
+
+                property_get("net.ppp0.local-ip", local_ip, "");
+                property_get("net.ppp0.dns1", local_pdns, "");
+                property_get("net.ppp0.dns2", local_sdns, "");
+                property_get("net.ppp0.gw", gw, "");
+                property_get("net.ppp0.remote-ip", remote_ip, "");
+
+                RLOGD("local_pdns:%s",local_pdns);
+                RLOGD("local_sdns:%s",local_sdns);
+                RLOGD("local_ip:%s",local_ip);
+                RLOGD("remote_ip:%s",remote_ip);
+                RLOGD("gw:%s",gw);
+
+                if ((!strcmp(apntype, "mms")))
+                {
+                    if((!strcmp(local_ip, "")))
+                    {
+                        RLOGD("PPP link is up but no local IP is assigned. Will retry %d times after %d seconds", \
+                                retry, POLL_PPP_SYSFS_SECONDS);
+                    }
+                    else
+                    {
+                        RLOGD("PPP link is up with local IP address %s", local_ip);
+                        *response_local_ip = local_ip;
+                        break;
+                    }
+                }
+                else
+                {
+                    if((!strcmp(local_ip, "")) || (!strcmp(local_ip, "0.0.0.0")))
+                    {
+                        RLOGD("PPP link is up but no local IP is assigned. Will retry %d times after %d seconds", \
+                                    retry, POLL_PPP_SYSFS_SECONDS);
+                    }
+                    else
+                    {
+                        RLOGD("PPP link is up with local IP address %s", local_ip);
+                        *response_local_ip = local_ip;
+                        // now we think PPPd is ready
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                RLOGD("PPP link status in %s is %s. Will retry %d times", \
+                        PPP_OPERSTATE_PATH, buffer, retry);
+
+                asprintf(&cmd, "/system/bin/ifconfig ppp0 up");
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+            }
+        }
+        else
+        {
+            RLOGD("Can not detect PPP state,PPPD PID %d ",get_pid("pppd"));
+            RLOGD("Can not detect PPP state in %s. Will retry %d times after %d seconds", \
+                    PPP_OPERSTATE_PATH, retry, POLL_PPP_SYSFS_SECONDS);
+
+            /*begin: modified for NL678-E ppp dial by lisf 20190111*/
+            if( mode_flag == GHT_NL678_E)
+            {
+                if(!get_pid("pppd"))
+                {
+                    pppd = 0;
+                    system(pppd_cmd);
+                    retry = 3;
+                    pppd =1 ;
+                    free(pppd_cmd);
+                    pppd_cmd = NULL;
+                }
+            }
+           /*end: modified for NL678-E ppp dial by lisf 20190111*/
+        }
+
+        sleep(POLL_PPP_SYSFS_SECONDS-1);
+    }while (--retry);
+
+    if(retry == 0)
+    {
+        goto ppp_error;
+    }
+
+    close(ppp_fd);
+    ppp_fd = -1;
+    if(pppd_cmd)
+    {
+        free(pppd_cmd);
+        pppd_cmd = NULL;
+    }
+
+    at_response_free(p_response);
+    return SUCCESS;
+error:
+    close(ppp_fd);
+    ppp_fd = -1;
+    if(pppd_cmd)
+    {
+	free(pppd_cmd);
+	pppd_cmd = NULL;
+    }
+
+    at_response_free(p_response);
+    return ERROR;
+ppp_error:
+    close(ppp_fd);
+    ppp_fd = -1;
+	
+    if(pppd_cmd)
+    {
+	free(pppd_cmd);
+	pppd_cmd = NULL;
+    }
+    at_response_free(p_response);
+    return PPP_ERROR;
+}
+
+/**
+ * called by requestSetupDataCall
+ *
+ * return 0 for success
+ * return 1 for error;
+ * return 2 for ndis_error;
+ */
+
+static int setupDataCallNDISMode(char**response_local_ip,const char* apn,const char* auth_type,const char* username,const  char* password,const char* pdp_type)
+{
+#define SUCCESS 0
+#define ERROR 1
+#define NDIS_ERROR 2
+#define RMNET_DIAL_TIME_OUT 75 
+
+    int fd;
+    int ret = 0;
+    char bufsrc[100]={0};
+    char *bufdest;
+
+    char buffer[20];
+    static char local_ip[PROPERTY_VALUE_MAX]={0};
+    static char local_pdns[PROPERTY_VALUE_MAX]={0};
+    static char local_sdns[PROPERTY_VALUE_MAX]={0};
+    static char kernel_version[PROPERTY_VALUE_MAX]={0};
+    int retry = POLL_NDIS_SYSFS_RETRY;
+    char apntype[PROPERTY_VALUE_MAX];
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char*cmd;
+    char *gw_ndis = (char *)calloc(PROPERTY_VALUE_MAX, sizeof(char));
+    char local_gateway[PROPERTY_VALUE_MAX]={0};
+    long secTime;
+    struct timeval beginTime, endTime;
+    gettimeofday(&beginTime, NULL);
+
+    int network_type = 0;
+    network_type = odm_get_current_network_type();
+
+    RLOGD("******** Enter setupDataCallNDISMode ********");
+
+    err = at_send_command_timeout("AT$QCRMCALL=0,1",NULL, ATSEND_TIMEOUT_MSEC*4+5000);
+
+    if(!network_type)
+    {
+        RLOGD("No service,can not setup data call");
+        goto error;
+    }
+
+    if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+    {
+         /*begin:added by lisf for switch cdma & evdo*/
+        if(GHT_MDM_NORMAL == mode_flag)
+        {
+            RIL_onUnsolicitedResponse( RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);  //added by lisf 20190323
+        }
+         /*end:added by lisf for switch cdma & evdo*/
+        if((username != NULL) && (password != NULL))
+        {
+            if (mode_flag < GHT_NL668)
+            {
+                asprintf(&cmd, "AT^PPPCFG=\"%s\",\"%s\"", username, password);
+                err = at_send_command(cmd, NULL);
+                free(cmd);
+            }
+        }
+    }
+
+    if((username != NULL) && (password != NULL))
+    {
+        if ((0 != strlen(username)) || (0 != strlen(password)))
+        {
+          if (mode_flag < GHT_NL668)
+          {
+              asprintf(&cmd, "AT$QCPDPP=1,%s,\"%s\",\"%s\"", auth_type, password, username);
+          }
+          else
+          {
+              asprintf(&cmd, "AT+MGAUTH=1,%s,\"%s\",\"%s\"",auth_type,username,password);
+          }
+          err = at_send_command(cmd, NULL);
+          free(cmd);
+        }
+    }
+
+    if(mode_flag == GHT_NL678_E)
+    {
+        //weak up ndis_do_dhcp_pthread
+        pthread_mutex_lock(&s_ndismutex);
+        pthread_cond_broadcast (&s_ndiscond);
+        pthread_mutex_unlock(&s_ndismutex);
+    }
+    do
+    {
+        network_type = odm_get_current_network_type();
+        if(6 == network_type || 7 ==network_type || 13 ==network_type)
+        {
+            if (GHT_NL660 == mode_flag)
+            {
+                if (0 == strcmp(auth_type,"1"))
+                {
+                    asprintf(&cmd, "AT+NETCFG=1,2,\"%s\",\"%s\",\"%s\",\"%s\",\"PAP\"",apn,pdp_type,username,password);
+                }
+                else
+                {
+                    asprintf(&cmd, "AT+NETCFG=1,2,\"%s\",\"%s\",\"%s\",\"%s\",\"PAP_CHAP\"",apn,pdp_type,username,password);
+                }
+                err = at_send_command(cmd, NULL);
+                free(cmd);
+                err = at_send_command_singleline_timeout("AT$QCRMCALL=1,1,1,1,,101", "$QCRMCALL:", ODM_RMNET_CALL_TIME_OUT, &p_response);
+            }
+            else if((mode_flag >= GHT_NL668) && (mode_flag <= GHT_NL678_E))
+            {
+                asprintf(&cmd, "AT+MGAUTH=1,%s,\"%s\",\"%s\"",auth_type,username,password);
+                err = at_send_command(cmd, NULL);
+                free(cmd);
+                err = at_send_command_singleline_timeout("AT$QCRMCALL=1,1", "$QCRMCALL:", ODM_RMNET_CALL_TIME_OUT, &p_response);
+            }
+            else
+            {
+                    if (0 == strcmp(auth_type,"1"))
+                    {
+                        asprintf(&cmd, "AT+EHRPDINFO=1,101,\"APN_String:%s;PDN_Label:internet;PDN_IP_Version:IPV4V6;RAN_Type:HRPD_EHRPD;PDN_Level_Auth_Protocol:PAP;PDN_Level_Auth_User_ID:%s;PDN_Level_Auth_Password:%s;\"",apn,username,password);
+                        err = at_send_command(cmd, NULL);
+                        free(cmd);
+
+    					asprintf(&cmd, "AT+NETCFG=1,2,%s,%s,%s,%s,PAP",apn,pdp_type,username,password);
+                        err = at_send_command(cmd, NULL);
+                        free(cmd);
+                    }
+                    else
+                    {
+                        asprintf(&cmd, "AT+EHRPDINFO=1,101,\"APN_String:%s;PDN_Label:internet;PDN_IP_Version:IPV4V6;RAN_Type:HRPD_EHRPD;PDN_Level_Auth_Protocol:PAP_CHAP;PDN_Level_Auth_User_ID:%s;PDN_Level_Auth_Password:%s;\"",apn,username,password);
+                        err = at_send_command(cmd, NULL);
+                        free(cmd);
+
+    					asprintf(&cmd, "AT+NETCFG=1,2,%s,%s,%s,%s,PAP_CHAP",apn,pdp_type,username,password);
+                        err = at_send_command(cmd, NULL);
+                        free(cmd);
+                    }
+                    
+                    err = at_send_command_singleline_timeout("AT$QCRMCALL=1,1,1,1,,101", "$QCRMCALL:", ODM_RMNET_CALL_TIME_OUT, &p_response);
+            }            
+        }
+        else
+        {          
+            #ifdef ODM_ARM64    //"ifconfig ..." for 64-bit and "busybox ifconfig ..." for 32-bit
+            RLOGD("ODM_ARM64 has been defined!");
+            asprintf(&cmd, "ifconfig usb0 up");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+            sleep(1);
+            #else
+            asprintf(&cmd, "busybox ifconfig usb0 up");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+            #endif
+            if(PDP_IPV4 == g_apn_pdptype )
+            {
+                err = at_send_command_singleline_timeout("AT$QCRMCALL=1,1", "$QCRMCALL:", ODM_RMNET_CALL_TIME_OUT, &p_response);
+                RLOGD("err=%d,p_response->sucess=%d",err,p_response->success);
+                if (err != 0 || p_response->success == 0)
+                {
+                    RLOGD("IPV4 rmnet send dial command failed!");
+                    goto error;
+                }
+                break;
+            }
+            else if(PDP_IPV6 == g_apn_pdptype )
+            {
+                err = at_send_command_singleline_timeout("AT$QCRMCALL=1,1,2", "$QCRMCALL:", ODM_RMNET_CALL_TIME_OUT, &p_response);
+                RLOGD("err=%d,p_response->sucess=%d",err,p_response->success);
+                if (err != 0 ||  p_response->success == 0)
+                {
+                    RLOGD("IPV6 rmnet send dial command failed!");
+                    goto error;
+                }
+                break;
+            }
+            else
+            {
+                err = at_send_command_singleline_timeout("AT$QCRMCALL=1,1", "$QCRMCALL:", ODM_RMNET_CALL_TIME_OUT, &p_response);
+                RLOGD("err=%d,p_response->sucess=%d",err,p_response->success);
+                if (err != 0 || p_response->success == 0)
+                {
+                    RLOGD("IPV4 rmnet send dial command failed!");
+                }
+                else
+                {
+                    ipv4_dial_flag = true;
+                    RLOGD("rmnet ipv4 dial sucess!");
+                }
+                err = at_send_command_singleline_timeout("AT$QCRMCALL=1,1,2", "$QCRMCALL:", ODM_RMNET_CALL_TIME_OUT, &p_response);
+                RLOGD("err=%d,p_response->sucess=%d",err,p_response->success);
+                if (err != 0 ||  p_response->success == 0)
+                {
+                    RLOGD("IPV6 rmnet send dial command failed!");
+                }
+                else
+                {
+                    ipv6_dial_flag = true;
+                    RLOGD("rmnet ipv6 dial sucess!");
+                }
+                if(!ipv4_dial_flag && !ipv6_dial_flag)
+                {
+                    RLOGD("rmnet ipv4ipv6 send dial command failed!");
+                    gettimeofday(&endTime, NULL);
+                    secTime  = endTime.tv_sec - beginTime.tv_sec;
+                    at_response_free(p_response);
+                    if(secTime >= RMNET_DIAL_TIME_OUT)
+                    {
+                        RLOGD("rmnet dial failed and time out %d seconds, will reboot modem",secTime);
+                        at_send_command("at+syscmd=\"reboot\"", NULL);
+                    }
+                    RLOGD("Dialling failed.Will redial in three seconds!");
+                    sleep(3);
+                    continue;
+                }
+                break;                
+            }
+        }
+        
+    }while(--retry);
+    if(retry == 0)
+    {
+        RLOGD("Rmnet dial failed five times!!!!");
+        goto error;
+    }
+#ifdef ODM_ARM64
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_9)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 9 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        asprintf(&cmd, "/system/bin/ip rule add from all lookup main pref 1");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID8X
+/*    	asprintf(&cmd, "echo 1 > proc/sys/net/ipv4/ip_forward");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+		
+        asprintf(&cmd, "/system/bin/ip route add default via 192.168.0.1");
+        RLOGD("%s",cmd);
+        system(cmd);
+	    free(cmd);
+*/
+	    asprintf(&cmd, "/system/bin/ip rule add from all lookup main pref 1");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+#endif
+#endif
+
+    if(PDP_IPV4 == g_apn_pdptype )
+    {
+        fibo_bring_up_interface_do_dhcp("usb0");
+        fibo_get_ip("usb0", bufsrc);
+        property_set("net.usb0.local-ip", bufsrc);
+        get_gateway(&gw_ndis);
+        RLOGD("gw_ndis [%s]", gw_ndis);
+        strcpy(local_gateway, gw_ndis);
+        free(gw_ndis);
+        gw_ndis = NULL;
+        property_set("net.usb0.gw", local_gateway);
+    }
+     else if( PDP_IPV4V6 == g_apn_pdptype)
+    {
+        fibo_bring_up_interface_do_dhcp("usb0");
+        fibo_get_ip("usb0", bufsrc);
+        property_set("net.usb0.local-ip", bufsrc);
+        get_gateway(&gw_ndis);
+        RLOGD("gw_ndis [%s]", gw_ndis);
+        strcpy(local_gateway, gw_ndis);
+        free(gw_ndis);
+        gw_ndis = NULL;
+        property_set("net.usb0.gw", local_gateway);
+        err = rilInitIPV6();
+        if (err < 0) 
+            RLOGD("get IPV6 information failed");
+    }
+    else if(PDP_IPV6 == g_apn_pdptype )
+    {
+        fibo_get_ip("usb0", bufsrc);
+        property_set("net.usb0.local-ip", bufsrc);
+        err = rilInitIPV6();
+        if (err < 0) 
+            RLOGD("get IPV6 information failed");
+        property_set("net.usb0.dns1", "2400:3200::1");
+        property_set("net.usb0.dns2", "2400:3200:baba::1");
+    }
+    else
+    {
+        RLOGD("g_apn_pdptype error!");
+        goto error;
+    }
+#else
+    if(PDP_IPV4 == g_apn_pdptype )
+    {
+        property_get("odm.kernel.version", kernel_version, "");
+        asprintf(&cmd, "busybox ifconfig usb0 mtu 1428");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+        RLOGD("@@kernel_version:%s",kernel_version);
+        if (0 > strcmp(kernel_version, Kernel_Version))
+        {
+            if(!(mode_flag == GHT_NL678_E))
+            {
+                asprintf(&cmd, "busybox ifconfig usb0 up");
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+                asprintf(&cmd, "netcfg usb0 dhcp");
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+            }
+            asprintf(&cmd, "ifconfig usb0 > /data/ODM_IP");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+
+            fd = open("/data/ODM_IP", O_RDONLY);
+            ret = read(fd, bufsrc, sizeof(bufsrc));
+            close(fd);
+        
+            bufdest = strtok(bufsrc, " ");
+            bufdest = strtok(NULL, " ");
+            bufdest = strtok(NULL, " ");
+
+            property_set("net.usb0.local-ip", bufdest);
+        }
+        else
+        {
+            asprintf(&cmd, "dhcptool usb0");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+            asprintf(&cmd, "ifconfig usb0|grep \"inet addr:\"|cut -d\":\" -f2|cut -d\" \" -f1 > /data/ODM_IP");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+
+            fd = open("/data/ODM_IP", O_RDONLY);
+            ret = read(fd, bufsrc, sizeof(bufsrc));
+            close(fd);
+            property_set("net.usb0.local-ip", bufsrc);
+        }
+    }
+    if((PDP_IPV4V6== g_apn_pdptype))
+    {
+        property_get("odm.kernel.version", kernel_version, "");
+        asprintf(&cmd, "busybox ifconfig usb0 mtu 1428");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+        RLOGD("@@kernel_version:%s",kernel_version);
+        if (0 > strcmp(kernel_version, Kernel_Version))
+        {
+            if(!(mode_flag == GHT_NL678_E))
+            {
+                asprintf(&cmd, "busybox ifconfig usb0 up");
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+                asprintf(&cmd, "netcfg usb0 dhcp");
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+            }
+            asprintf(&cmd, "ifconfig usb0 > /data/ODM_IP");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+
+            fd = open("/data/ODM_IP", O_RDONLY);
+            ret = read(fd, bufsrc, sizeof(bufsrc));
+            close(fd);
+        
+            bufdest = strtok(bufsrc, " ");
+            bufdest = strtok(NULL, " ");
+            bufdest = strtok(NULL, " ");
+
+            property_set("net.usb0.local-ip", bufdest);
+        }
+        else
+        {
+            asprintf(&cmd, "dhcptool usb0");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+            asprintf(&cmd, "ifconfig usb0|grep \"inet addr:\"|cut -d\":\" -f2|cut -d\" \" -f1 > /data/ODM_IP");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+
+            fd = open("/data/ODM_IP", O_RDONLY);
+            ret = read(fd, bufsrc, sizeof(bufsrc));
+            close(fd);
+            property_set("net.usb0.local-ip", bufsrc);
+        }
+        rilInitIPV6();
+    }
+    if (PDP_IPV6 == g_apn_pdptype )
+    {
+        rilInitIPV6();
+    }
+#endif	
+    retry = POLL_NDIS_SYSFS_RETRY;
+    do
+    {   
+        fd = open(NDIS_OPERSTATE_PATH, O_RDONLY);
+        if (fd >= 0)
+        {
+            buffer[0] = 0;
+            read(fd, buffer, sizeof(buffer));
+            close(fd);
+            if(!strncmp(buffer, "up", strlen("up")) || !strncmp(buffer, "unknown", strlen("unknown")))
+            {
+             
+                local_ip[0] = 0;
+                property_get("net.usb0.local-ip", local_ip, "");
+                property_get("net.usb0.dns1", local_pdns, "");
+                property_get("net.usb0.dns2", local_sdns, "");
+                property_get("net.usb0.gw", local_gateway, "");
+
+                RLOGD("local_pdns:%s",local_pdns);
+                RLOGD("local_sdns:%s",local_sdns);
+                RLOGD("local_ip:%s",local_ip);
+                RLOGD("local_gateway:%s",local_gateway);
+
+                 if((!strcmp(local_ip, "")) || (!strcmp(local_ip, "0.0.0.0")))
+                {
+                    strcpy(local_ip,bufsrc);
+                    RLOGD("local_ipp:%s",local_ip);
+                    property_set("net.usb0.local-ip", bufsrc);
+                }
+                if((!strcmp(local_pdns, "")) || (!strcmp(local_sdns, "")))
+                {
+                    char *pdns =  (char *)calloc(ODM_DNS_SIZE, sizeof(char));
+                    char *sdns =  (char *)calloc(ODM_DNS_SIZE, sizeof(char));
+                    err = odm_get_dns_gtdns(&pdns, &sdns);
+                    //Because China unicom network has DNS issure so set up a default DNS when you can't get it from the network side
+                    if((err < 0) && (ODM_CU_OPERATOR == cur_oper))
+                    {
+                        strcpy(pdns,"8.8.8.8");
+                        strcpy(sdns,"114.114.114.114");
+                    }
+
+                    if(((0 == strcmp(pdp_type,"IPV4"))||(0 ==  strcmp(pdp_type,"IP"))) && (!strcmp(local_gateway, "")))
+                    {
+                        get_gateway(&gw_ndis);
+                        RLOGD("gw_ndis  [%s]", gw_ndis);
+                        strcpy(local_gateway, gw_ndis);
+                        free(gw_ndis);
+                        gw_ndis = NULL;
+                        property_set("net.usb0.gw", local_gateway);
+                    }
+
+                    property_get("net.usb0.local-ip", local_ip, "");
+                    property_get("net.usb0.dns1", local_pdns, "");
+                    property_get("net.usb0.dns2", local_sdns, "");
+                    property_get("net.usb0.gw", local_gateway, "");
+
+                    RLOGD("local_pdns:%s",local_pdns);
+                    RLOGD("local_sdns:%s",local_sdns);
+                    RLOGD("local_ip:%s",local_ip);
+                    RLOGD("local_gateway:%s",local_gateway);
+                }
+                if((!strcmp(local_ip, "")) || (!strcmp(local_ip, "0.0.0.0")))
+
+                {
+                    RLOGD("NDIS link is up but no local IP is assigned. Will retry %d times after %d seconds", \
+                            retry, POLL_NDIS_SYSFS_SECONDS);
+                }
+                else
+                {
+                    RLOGD("NDIS link is up with local IP address %s", local_ip);
+                    *response_local_ip = local_ip;
+                    break;
+                }
+            }        
+           else
+            {
+                RLOGD("NDIS link status in %s is %s. Will retry %d times", \
+                        NDIS_OPERSTATE_PATH, buffer, retry);
+            }
+        }
+        else
+        {
+            RLOGD("Can not detect NDIS state in %s. Will retry %d times after %d seconds", \
+                    NDIS_OPERSTATE_PATH, retry-1, POLL_NDIS_SYSFS_SECONDS);
+        }
+        sleep(POLL_NDIS_SYSFS_SECONDS-1);
+    
+        }while(--retry);        
+
+    if(retry == 0)
+    {
+        goto ndis_error;
+    }
+
+    at_response_free(p_response);
+    return SUCCESS;
+error:
+    at_response_free(p_response);
+    return ERROR;
+ndis_error:
+    at_response_free(p_response);
+    return NDIS_ERROR;
+
+}
+
+
+void Get_NetProperties()
+{
+    RLOGD("***********Enter %s**********", __FUNCTION__);
+    static char local_ip[PROPERTY_VALUE_MAX]={0};
+    static char local_pdns[PROPERTY_VALUE_MAX]={0};
+    static char local_sdns[PROPERTY_VALUE_MAX]={0};
+    char gw[PROPERTY_VALUE_MAX]={0};
+
+    if(cus_netifName_flag)
+    {
+        property_get(cus_local_ip, local_ip, "");
+        property_get(cus_dns1, local_pdns, "");
+        property_get(cus_dns2, local_sdns, "");
+        property_get(cus_gw, gw, "");
+    }
+    else if (GHT_MA510_GL == mode_flag || eth1_interface == 1)
+    {
+        property_get("net.eth1.local-ip", local_ip, "");
+        property_get("net.eth1.dns1", local_pdns, "");
+        property_get("net.eth1.dns2", local_sdns, "");
+        property_get("net.eth1.gw", gw, "");
+    }
+    else
+    {
+        property_get("net.usb0.local-ip", local_ip, "");
+        property_get("net.usb0.dns1", local_pdns, "");
+        property_get("net.usb0.dns2", local_sdns, "");
+        property_get("net.usb0.gw", gw, "");
+    }
+    
+    RLOGD("local_ip:%s",local_ip);
+    RLOGD("local_pdns:%s",local_pdns);
+    RLOGD("local_sdns:%s",local_sdns);
+    RLOGD("gw:%s", gw);
+
+    RLOGD("***********Leave %s**********", __FUNCTION__);
+}
+
+/**
+ * called by requestSetupDataCall
+ *
+ * return 0 for success
+ * return 1 for error;
+ * return 2 for ppp_error;
+ */
+static int setupDataCallECMMode(char**response_local_ip,const char* apn,const char* auth_type,const char* username,const  char* password,const char* pdp_type)
+{
+#define SUCCESS 0
+#define ERROR 1
+#define NDIS_ERROR 2
+    int fd;
+    int ret = 0;
+    int i = 0;
+    int j = 0;
+    int n = 1;
+    char bufsrc[100]={0};
+    char *bufdest;
+
+    char buffer[20];
+    char exit_code[PROPERTY_VALUE_MAX]={0};
+    static char local_ip[PROPERTY_VALUE_MAX]={0};
+    static char local_pdns[PROPERTY_VALUE_MAX]={0};
+    static char local_sdns[PROPERTY_VALUE_MAX]={0};
+    int retry = POLL_NDIS_SYSFS_SECONDS;
+    int ready_for_connect = 0;
+    int try_connect_numbers = 0;
+    char apntype[PROPERTY_VALUE_MAX];
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char *cmd = NULL;
+
+    int active=-1;
+    char *line,*if_name;
+    int network_type = 0;
+    RIL_IPv6 ril_IPv6;
+
+    RLOGD("******** Enter setupDataCallECMMode ********");
+
+    if(mode_flag == GHT_L716)
+    {
+        asprintf(&cmd, "/system/bin/ip route del default dev %s", cus_netifName);
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+        asprintf(&cmd, "/system/bin/busybox ifconfig %s down", cus_netifName);
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+        ifc_init();
+        ifc_up(cus_netifName);
+        ifc_close();
+    }
+    network_type = odm_get_current_network_type();
+    g_apn_pdptype = odm_get_pdptype(pdp_type);
+
+#if 0
+    asprintf(&cmd, "AT+GTRNDIS=0,%d", cus_cid);
+    err = at_send_command_timeout(cmd,  &p_response, 30000);
+    free(cmd);
+    if (err < 0 || p_response->success == 0)
+        RLOGD("No call,can not release data call");
+#endif
+
+    err = at_send_command_singleline("AT+GTRNDIS?", "+GTRNDIS:", &p_response);
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        at_tok_start(&line);
+        at_tok_nextint(&line,&active);
+        if (active == 1)
+        {
+            at_response_free(p_response);
+            asprintf(&cmd, "AT+GTRNDIS=0,%d", cus_cid);
+            err = at_send_command_timeout(cmd,  &p_response, 30000);
+            free(cmd);
+            if (err < 0 || p_response->success == 0)
+                goto error;
+        }
+    }
+    at_response_free(p_response);
+    p_response = NULL;
+
+    RLOGD("%s: ECM_NetifName:%s", __FUNCTION__, cus_netifName);
+
+    if (0 == network_type)
+    {
+        RLOGD("No service,can not setup data call");
+        goto error;
+    }
+
+    if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+    {
+        if((username != NULL) && (password != NULL))
+        {
+            if (mode_flag < GHT_NL668)
+            {
+                asprintf(&cmd, "AT^PPPCFG=\"%s\",\"%s\"", username, password);
+                err = at_send_command(cmd, NULL);
+                free(cmd);
+            }
+        }
+    }
+
+    if((username != NULL) && (password != NULL))
+    {
+        if ((0 != strlen(username)) || (0 != strlen(password)))
+        {
+            if (mode_flag < GHT_NL668)
+            {
+                asprintf(&cmd, "AT$QCPDPP=1,%s,\"%s\",\"%s\"", auth_type, password, username);
+            }
+            else
+            {
+                asprintf(&cmd, "AT+MGAUTH=1,%s,\"%s\",\"%s\"",auth_type,username,password);
+            }
+            err = at_send_command(cmd, NULL);
+            free(cmd);
+        }
+    }
+
+    do {
+        if(6 == network_type || 7 ==network_type || 13 ==network_type)
+        {
+
+            asprintf(&cmd, "AT+NETCFG=1,2,\"%s\",\"%s\",\"%s\",\"%s\",\"PAP_CHAP\"",apn,pdp_type,username,password);
+
+            err = at_send_command(cmd, NULL);
+            free(cmd);
+
+            asprintf(&cmd, "AT+GTRNDIS=1,%d", cus_cid);
+            err = at_send_command_timeout(cmd,&p_response,ODM_RMNET_CALL_TIME_OUT);
+            free(cmd);
+            if (err < 0 || p_response->success == 0)
+            {
+                goto error;
+            }
+        }
+        else
+        {
+            getSetAPN(cus_cid, pdp_type, apn);
+
+            asprintf(&cmd, "AT+GTRNDIS=1,%d", cus_cid);
+            err = at_send_command_timeout(cmd,&p_response,ODM_RMNET_CALL_TIME_OUT);
+            free(cmd);
+            if (err < 0 || p_response->success == 0)
+            {
+                goto error;
+            }
+        }
+        break;
+    }while(--retry);
+
+    if (retry == 0)
+    {
+        RLOGD("open ndis_fd fail!");
+        goto error;
+    }
+
+    if(cus_netifName_flag)
+    {
+        ECM_NetifName = strdup(cus_netifName);
+        ECM_local_ip  = strdup(cus_local_ip);
+        ECM_dns1      = strdup(cus_dns1);
+        ECM_dns2      = strdup(cus_dns2);
+        ECM_operstate = strdup(cus_operstate);
+    }
+    else if (GHT_MA510_GL == mode_flag || eth1_interface == 1)
+    {
+        ECM_NetifName = strdup("eth1");
+        ECM_local_ip  = strdup("net.eth1.local-ip");
+        ECM_dns1      = strdup("net.eth1.dns1");
+        ECM_dns2      = strdup("net.eth1.dns2");
+        ECM_operstate = strdup(ECM_OPERSTATE_PATH);
+    }
+    else
+    {
+        ECM_NetifName = strdup("usb0");
+        ECM_local_ip  = strdup("net.usb0.local-ip");
+        ECM_dns1      = strdup("net.usb0.dns1");
+        ECM_dns2      = strdup("net.usb0.dns2");
+        ECM_operstate = strdup(NDIS_OPERSTATE_PATH);
+    }
+
+    asprintf(&cmd, "busybox ifconfig %s up", ECM_NetifName);
+    RLOGD("%s",cmd);
+    system(cmd);
+    free(cmd);
+
+#ifdef ODM_ARM64
+#if 0
+#if defined GHT_FEATURE_ANDROID7X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+/*
+
+            asprintf(&cmd, "echo 1 > proc/sys/net/ipv4/ip_forward");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+
+            asprintf(&cmd, "/system/bin/ip route add default via 192.168.0.1");
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+
+            asprintf(&cmd, "/system/bin/ip rule add from all lookup main pref 1");   //Use this command only on 64-bit systems
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+*/
+#endif
+#endif
+
+    if(mode_flag == GHT_L716){
+                asprintf(&cmd, "echo 1 > proc/sys/net/ipv4/ip_forward");
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+
+                asprintf(&cmd, "/system/bin/ip route add default via 192.168.0.1");
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+
+                asprintf(&cmd, "/system/bin/ip rule add from all lookup main pref 1");   //Use this command only on 64-bit systems
+                RLOGD("%s",cmd);
+                system(cmd);
+                free(cmd);
+    }
+
+    ret = fibo_bring_up_interface_do_dhcp(ECM_NetifName);
+    if(ret)
+    {
+        RLOGE("Get DHCP info error.");
+        //goto error;
+    }
+
+    ret = fibo_get_ip(ECM_NetifName, bufsrc);
+    if(ret)
+    {
+        RLOGE("Get IP address error.");
+        //goto error;
+    }
+
+    property_set(ECM_local_ip, bufsrc);
+
+#else     //ARM32
+    if (GHT_MA510_GL == mode_flag)
+    {
+        asprintf(&cmd, "netcfg eth1 dhcp");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+        asprintf(&cmd, "ifconfig eth1 > /data/ODM_IP");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+        fd = open("/data/ODM_IP", O_RDONLY);
+        ret = read(fd, bufsrc, sizeof(bufsrc));
+        close(fd);
+
+        bufdest = strtok(bufsrc, " ");
+        bufdest = strtok(NULL, " ");
+        bufdest = strtok(NULL, " ");
+
+        property_set("net.eth1.local-ip", bufdest);
+    }
+    else
+    {
+        asprintf(&cmd, "netcfg usb0 dhcp");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+        asprintf(&cmd, "ifconfig usb0 > /data/ODM_IP");
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+        fd = open("/data/ODM_IP", O_RDONLY);
+        ret = read(fd, bufsrc, sizeof(bufsrc));
+        close(fd);
+
+        bufdest = strtok(bufsrc, " ");
+        bufdest = strtok(NULL, " ");
+        bufdest = strtok(NULL, " ");
+
+        property_set("net.usb0.local-ip", bufdest);
+    }
+#endif //End: #ifdef ODM_ARM64
+
+    if (PDP_IPV4 != g_apn_pdptype)
+    {
+        if (6 == network_type || 7 ==network_type || 13 ==network_type)
+        {
+            RLOGD("Not support 3GPP2");
+        }
+        else
+        {
+            ret = getIPV6Info(&ril_IPv6);
+            if(ret)
+            {
+                RLOGD("getIPV6Info error!");
+                goto error;
+            }
+
+            RLOGD("RIL IPV6 ipv6addr: [%s]",ril_IPv6.ipv6addr);
+            RLOGD("RIL IPV6 ipv6gateway: [%s]",ril_IPv6.ipv6gateway);
+            RLOGD("RIL IPV6 ipv6dns1: [%s]",ril_IPv6.ipv6dns1);
+            RLOGD("RIL IPV6 ipv6dns2: [%s]",ril_IPv6.ipv6dns2);
+            //Get_NetProperties();
+            setIPv6(ril_IPv6);
+        }
+    }
+    else
+    {
+        at_send_command_singleline("AT+GTRNDIS?", "+GTRNDIS:", NULL);
+    }
+
+    do
+    {
+        // Waitting for dhcpcd sucessfully
+
+        fd = open(ECM_operstate, O_RDONLY);
+
+        RLOGD("interface:%s",ECM_NetifName);
+
+        if (fd >= 0)
+        {
+            RLOGD("open ecm_operstate_path ok");
+            buffer[0] = 0;
+            read(fd, buffer, sizeof(buffer));
+            close(fd);
+            if(!strncmp(buffer, "up", strlen("up")) || !strncmp(buffer, "unknown", strlen("unknown")))
+            {
+                local_ip[0] = 0;
+
+                property_get(ECM_local_ip, local_ip, "");
+                property_get(ECM_dns1, local_pdns, "");
+                property_get(ECM_dns2, local_sdns, "");
+
+                RLOGD("local_ip:%s",local_ip);
+                RLOGD("local_pdns:%s",local_pdns);
+                RLOGD("local_sdns:%s",local_sdns);
+
+                if(GHT_MC919 == mode_flag)
+                {
+                    RLOGD("Manually add an sdns for MC919.");
+                    property_set(ECM_dns2, "8.8.8.8");
+                }
+
+                if((!strcmp(local_ip, "")) || (!strcmp(local_ip, "0.0.0.0")) || (!strcmp(local_ip, "0:0:0:0"))  )
+                {
+                    RLOGD("ECM link is up but no local IP is assigned. Will retry %d times after %d seconds", \
+                            retry, POLL_NDIS_SYSFS_SECONDS);
+                }
+                else
+                {
+                    RLOGD("ECM link is up with local IP address %s", local_ip);
+                    *response_local_ip = local_ip;
+                    break;
+                }
+
+            }
+            else
+            {
+                RLOGD("ECM link status in /sys/class/net/%s/operstate is %s. Will retry %d times",ECM_NetifName, buffer, retry);
+            }
+        }
+        else
+        {
+            RLOGD("Can not detect ECM state in/sys/class/net/%s/operstate. Will retry %d times after %d seconds",ECM_NetifName, retry-1, POLL_NDIS_SYSFS_SECONDS);
+        }
+        sleep(POLL_NDIS_SYSFS_SECONDS-1);
+    }while(--retry);
+
+    if(retry == 0)
+    {
+        goto ecm_error;
+    }
+
+    fibocom_pingflag = 1;     //Data dialing succeeded. Ping can begin!
+
+    at_response_free(p_response);
+    return SUCCESS;
+error:
+    at_response_free(p_response);
+    return ERROR;
+ecm_error:
+    at_response_free(p_response);
+    return NDIS_ERROR;
+}
+
+void get_cgdcont0()
+{
+    RLOGD("*********Enter %s***********", __FUNCTION__);
+    char cgdcont0_char[PROPERTY_VALUE_MAX]  = {0};
+    int ret;
+
+    //0: Do not set APN for cid0
+    //1: Set the APN for cid0
+    ret = property_get("ril.fibocom.cgdcont0", cgdcont0_char, "");
+
+    if(ret > MAX_CGDCONT0_PROPERTY_LENGTH)
+    {
+        RLOGD("[%s,%d]The length of the property:ril.fibocom.cgdcont0 is too long:%d, %d characters maximum allowed.", __FUNCTION__, __LINE__, ret, MAX_CGDCONT0_PROPERTY_LENGTH);
+    }
+    else if(ret > 0)
+    {
+        RLOGD("[%s,%d]get ril.fibocom.cgdcont0:%s, ret:%d", __FUNCTION__, __LINE__, cgdcont0_char, ret);
+        cus_cgdcont0 = atoi(cgdcont0_char);
+        if(cus_cgdcont0 == NEED_CGDCONT0_YES || cus_cgdcont0 == NEED_CGDCONT0_NO)
+        {
+            RLOGD("[%s,%d]cus_cgdcont0:%d", __FUNCTION__, __LINE__, cus_cgdcont0);
+        }
+        else
+        {
+            RLOGD("[%s,%d]cgdcont0:%d is expected to range from %d to %d", __FUNCTION__, __LINE__, cus_cgdcont0, NEED_CGDCONT0_NO, NEED_CGDCONT0_YES);
+            cus_cgdcont0 = 0;
+        }
+
+    }
+    else
+    {
+        RLOGD("[%s,%d]ril.fibocom.cgdcont0 property not set, ret:%d", __FUNCTION__, __LINE__, ret);
+    }
+
+    RLOGD("*********Leave %s***********", __FUNCTION__);
+
+}
+
+
+void get_Current_Apn(int target_cid, char *out_pdp_type, char *out_apn_name, char *out_ip_addr)
+{
+    ATResponse *p_response = NULL;
+    ATLine *p_cur;
+    int err;
+    int n = 0;
+    char *out;
+    char *line;
+    int cid;
+
+    err = at_send_command_multiline ("AT+CGDCONT?", "+CGDCONT:", &p_response);
+    if (err != 0 || p_response->success == 0) {
+        RLOGD("%s,%d,err[%d]", __FUNCTION__,__LINE__,err);
+        goto error;
+    }
+
+    for(p_cur = p_response->p_intermediates; p_cur !=NULL; p_cur = p_cur->p_next)
+    {
+        line = p_cur->line;
+
+        //RLOGD("line:%s", line);
+        err = at_tok_start(&line);
+        if (err < 0)
+            goto error;
+
+        err = at_tok_nextint(&line, &cid);
+        if (err < 0)
+            goto error;
+
+        if(cid != target_cid)
+        {
+            continue;
+        }
+        else
+        {
+            // apn type
+            err = at_tok_nextstr(&line, &out);
+            if (err < 0)
+                goto error;
+            if(out_pdp_type != NULL)
+            {
+                strcpy(out_pdp_type, out);
+            }
+
+            //apn name
+            err = at_tok_nextstr(&line, &out);
+            if (err < 0)
+                goto error;
+            if(out_apn_name != NULL)
+            {
+                strcpy(out_apn_name, out);
+            }
+
+            //ip address
+            err = at_tok_nextstr(&line, &out);
+            if (err < 0)
+                goto error;
+            if(out_ip_addr != NULL)
+            {
+                strcpy(out_ip_addr, out);
+                RLOGD("[%s,%d]AT+CGDCONT: out:%s out_ip_addr:%s", __FUNCTION__, __LINE__, out, out_ip_addr);
+            }
+
+            break;
+        }
+    }
+
+error:
+    at_response_free(p_response);
+    p_response = NULL;
+    return;
+}
+
+int APNInfoChange(char *New_Pdp_Type, char *New_APN_Name, char *Old_PDP_type, char *Old_APN_Name)
+{
+    int ret = false;
+
+    if(New_Pdp_Type == NULL && New_APN_Name == NULL)
+    {
+        RLOGD("New_Pdp_Type and New_APN_Name are empty, so the upper layer does not want to change the APN information");
+        return ret;
+    }
+
+    RLOGD("[%s,%d]Old_PDP_type:%s, New_Pdp_Type:%s", __FUNCTION__, __LINE__, Old_PDP_type, New_Pdp_Type);
+    RLOGD("[%s,%d]Old_APN_Name:%s, New_APN_Name:%s", __FUNCTION__, __LINE__, Old_APN_Name, New_APN_Name);
+
+    if((0 != strcmp(Old_PDP_type, New_Pdp_Type)) || (0 != strcmp(Old_APN_Name, New_APN_Name)))
+    {
+        if(0 != strcmp(Old_PDP_type, New_Pdp_Type))
+        {
+            RLOGD("[%s,%d]pdp_type has been changed", __FUNCTION__, __LINE__);
+        }
+
+        if(0 != strcmp(Old_APN_Name, New_APN_Name))
+        {
+            RLOGD("[%s,%d]apn_name has been changed", __FUNCTION__, __LINE__);
+        }
+
+        ret = true;
+    }
+
+    return ret;
+}
+
+void getSetAPN(int cid, char *pdp_type, char *apn)
+{
+    int err;
+    char *cmd = NULL;
+
+    //Before setting the APN, obtain the current APN
+    get_Current_Apn(cid, Cur_Pdp_Type, Cur_APN_Name, NULL);
+    RLOGD("Current PDP_type:%s, Current APN_Name:%s, get cid:%d", Cur_Pdp_Type, Cur_APN_Name, cid);
+
+    err = APNInfoChange(pdp_type, apn, Cur_Pdp_Type, Cur_APN_Name);
+    RLOGD("APNInfoChange err:%d", err);
+    
+    if (err)            //We need to update the APN information
+    {
+        asprintf(&cmd, "AT+CGDCONT=%d,\"%s\",\"%s\"", cid, pdp_type, apn);
+        at_send_command(cmd, NULL);
+        free(cmd);
+
+        strncpy(Cur_Pdp_Type,pdp_type,strlen(pdp_type));
+        strncpy(Cur_APN_Name,apn,strlen(apn));
+        g_apn_pdptype = odm_get_pdptype(Cur_Pdp_Type);
+
+#if 0
+        if (!(GHT_FG621 == mode_flag))
+        {
+            onDeactiveDataCallList();
+            at_send_command("AT+CFUN=4", NULL);
+            at_send_command("AT+CFUN=1", NULL);
+        }
+#endif
+    }
+}
+
+void requestSetInitialAttachAPN(void *data, size_t datalen __unused, RIL_Token t)
+{
+    RLOGD("%s E", __FUNCTION__);
+    /* compatibility code android-5.1 l710/h3x/l8x tangsh 2016.9.21 e */
+    const char *apn =NULL;
+    const char *user = NULL;
+    const char *password = NULL;
+    char *cmd = NULL;
+    const char *pdp_type = NULL;
+    const char *auth_type = NULL; //added by lisf 20190201
+    int err = 0;
+
+    apn = ((const char **)data)[0];
+    pdp_type = ((const char **)data)[1];
+    auth_type = ((const char **)data)[2]; // added by lisf 20190201
+    user = ((const char **)data)[3];
+    password = ((const char **)data)[4];
+    RLOGD("[%s] apn:%s, pdp_type:%s", __FUNCTION__, apn, pdp_type);
+    //RLOGD("debug : auth_type:%s, user:%s, password:%s",auth_type,user,password);
+
+    if((apn != NULL) && (pdp_type!= NULL))
+    {
+        if(cus_cgdcont0 == NEED_CGDCONT0_YES)
+        {
+            char *cmd0 = NULL;
+
+            asprintf(&cmd0, "AT+CGDCONT=0,\"%s\",\"%s\"", pdp_type, apn);
+            at_send_command(cmd0, NULL);
+            free(cmd0);
+        }
+        RLOGD("[%s] cur_oper:%d, g_cops_lte:%d", __FUNCTION__, cur_oper, g_cops_lte);
+
+        getSetAPN(cus_cid, pdp_type, apn);
+    }
+    else
+    {
+        RLOGD("!!!apn, pdp_type parameters may be null Pointers");
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        return;
+    }
+
+    //RLOGD("auth_type= '%s'(%d), username= '%s', password= '%s'",auth_type, auth_type, user,password);
+    if(auth_type == NULL)
+    {   // 0  Authentication protocol is not used (NONE)
+        asprintf(&cmd, "AT+MGAUTH=1,0");
+        at_send_command(cmd, NULL);
+        free(cmd);
+    }
+    else if((user!= NULL) && (password!= NULL))
+    {
+        asprintf(&cmd, "AT+MGAUTH=1,%d,\"%s\",\"%s\"", auth_type, user, password);
+        at_send_command(cmd, NULL);
+        free(cmd);
+    }
+    else
+    {
+        RLOGD("!!!user,password  parameters may be null Pointers");
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        return;
+    }
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+int get_Current_Usbmode()
+{
+    int err, responsenet;
+    ATResponse *p_response;
+    char *line, usbmode_str[8] = {0};
+
+    err = at_send_command_singleline("AT+GTUSBMODE?", "+GTUSBMODE:", &p_response);
+
+    if (err < 0 || p_response->success == 0)
+    {
+        RLOGD("The module does not support this command");
+        goto error;
+    }
+    else
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0)
+        {
+            goto error;
+        }
+        err = at_tok_nextint(&line, &responsenet);
+        if (err < 0)
+        {
+            goto error;
+        }
+    }
+
+    sprintf(usbmode_str, "%d", responsenet);
+    property_set(PROPERTY_CURRENT_USBMODE, usbmode_str);
+    return responsenet;
+
+error:
+    return RET_FAIL;
+}
+
+int setUsbmode(int usbmode)
+{
+    int ret;
+    char cmd[100] = {0}, usbmode_str[8] = {0};
+    ATResponse *p_response;
+
+    sprintf(cmd, "AT+GTUSBMODE=%d", usbmode);
+
+    ret = at_send_command_timeout(cmd, &p_response, ATSEND_TIMEOUT_MSEC);
+    if (ret < 0 || p_response->success == FALSE)
+    {
+        RLOGD("An error occurred while executing GTUSBMODE command!");
+        return RET_FAIL;
+    }
+    else
+    {
+        //MC919 automatically restarts, so skip this step
+        if(GHT_MC919 != mode_flag)
+        {
+            sleep(1);
+            at_send_command_timeout("AT+CFUN=15", NULL, ATSEND_TIMEOUT_MSEC);
+        }
+
+        sprintf(usbmode_str, "%d", usbmode);
+        property_set(PROPERTY_CURRENT_USBMODE, usbmode_str);
+        return RET_SUCCESS;
+    }
+
+}
+
+void getSetUsbmode()
+{
+    ENTER_FUNC;
+    int cur_usbmode = 0, ret;
+    char cmd[100] = {0};
+    ATResponse *p_response;
+
+    cur_usbmode = get_Current_Usbmode();
+    if(RET_FAIL ==cur_usbmode)
+    {
+        RLOGE("This module does not support GTUSBMODE command!");
+        return;
+    }
+
+    get_Cus_Usbmode();  //Gets the USBMODE specified by the customer
+    RLOGD("current usbmode:%d, cus_usbmode:%d", cur_usbmode, cus_usbmode);
+
+    if(NO_CUS_USBMODE == cus_usbmode)
+    {
+        if(dialmode == DIAL_RAS_MOD)
+        {
+            if(mode_flag == GHT_NL668)
+            {
+                if(cur_usbmode != 17 && cur_usbmode != 18)
+                {
+                    setUsbmode(17);
+                }
+            }
+            else if(mode_flag == GHT_MC919)
+            {
+                if(cur_usbmode != 72)
+                {
+                    setUsbmode(72);
+                }
+            }
+            else if(mode_flag == GHT_MC66x)
+            {
+                if(cur_usbmode != 73)
+                {
+                    setUsbmode(73);
+                }
+            }
+        }
+        else if (DIAL_ECM_MOD == dialmode)
+        {
+            if(mode_flag == GHT_L610)
+            {
+                if(cur_usbmode != 32)
+                {
+                    setUsbmode(32);
+                }
+            }
+            else if(mode_flag == GHT_FG650)
+            {
+                //The 38 or 39 of the FG650 corresponds to RNDIS, which is not available on Android
+                if(cur_usbmode == 39 || cur_usbmode == 38)
+                {
+                    setUsbmode(37);
+                }
+            }
+            else if(mode_flag == GHT_MC919)
+            {
+                if(cur_usbmode != 70)
+                {
+                    setUsbmode(70);
+                }
+            }
+            else if(mode_flag == GHT_NL668)
+            {
+                if(cur_usbmode != 18)
+                {
+                    setUsbmode(18);
+                }
+            }
+            else if(mode_flag == GHT_MC66x)
+            {
+                if(cur_usbmode != 74)
+                {
+                    setUsbmode(74);
+                }
+            }
+        }
+    }
+    else if(cur_usbmode != cus_usbmode)    //cus_usbmode != 0 && cur_usbmode != cus_usbmode
+    {
+        setUsbmode(cus_usbmode);
+    }
+    else  //cus_usbmode is non-zero, but is the same as the current USBMODE, so you don't need to change it
+    {
+        RLOGD("Do not change USBMODE");
+    }
+
+    LEAVE_FUNC;
+    return ;
+}
+
+void get_Cus_Usbmode()
+{
+    RLOGD("*********Enter %s***********", __FUNCTION__);
+    char usbmode_char[PROPERTY_VALUE_MAX]  = {0};
+    int ret;
+
+    //get netif name by proprity specified by user.
+    ret = property_get("ril.fibocom.usbmode", usbmode_char, "");
+
+    if(ret > MAX_USBMODE_PROPERTY_LENGTH)
+    {
+        RLOGD("[%s,%d]The length of the property:ril.fibocom.usbmode is too long:%d, %d characters maximum allowed.", __FUNCTION__, __LINE__, ret, MAX_USBMODE_PROPERTY_LENGTH);
+    }
+    else if(ret > 0)
+    {
+        RLOGD("[%s,%d]get ril.fibocom.usbmode:%s, ret:%d", __FUNCTION__, __LINE__, usbmode_char, ret);
+        cus_usbmode = atoi(usbmode_char);
+        if(cus_usbmode >= MIN_USBMODE_NUM && cus_usbmode <= MAX_USBMODE_NUM)
+        {
+            RLOGD("[%s,%d]cus_usbmode:%d", __FUNCTION__, __LINE__, cus_usbmode);
+        }
+        else
+        {
+            RLOGD("[%s,%d]usbmode:%d is expected to range from %d to %d", __FUNCTION__, __LINE__, cus_usbmode, MIN_USBMODE_NUM, MAX_USBMODE_NUM);
+            cus_usbmode = NO_CUS_USBMODE;
+        }
+
+    }
+    else
+    {
+        RLOGD("[%s,%d]ril.fibocom.usbmode property not set, ret:%d", __FUNCTION__, __LINE__, ret);
+    }
+
+    RLOGD("*********Leave %s***********", __FUNCTION__);
+}
+
+void getNetifName()
+{
+    RLOGD("*********Enter %s***********", __FUNCTION__);
+
+    //get netif name by proprity specified by user.
+    cus_netifName_flag = property_get("ril.fibocom.NetifName", cus_netifName, "");
+
+    if(cus_netifName_flag > 100)
+    {
+        RLOGD("[%s,%d]The length of the property:%d is too long, 100 characters maximum allowed.", __FUNCTION__, __LINE__, cus_netifName_flag);
+    }
+    else if(cus_netifName_flag > 0)
+    {
+        RLOGD("[%s,%d]get ril.fibocom.NetifName:%s, ret:%d", __FUNCTION__, __LINE__, cus_netifName, cus_netifName_flag);
+
+        //get final name of IFNAME gw, IP, dns and so on...
+        sprintf(cus_gw, "net.%s.gw", cus_netifName);
+        sprintf(cus_local_ip, "net.%s.local-ip", cus_netifName);
+        sprintf(cus_dns1, "net.%s.dns1", cus_netifName);
+        sprintf(cus_dns2, "net.%s.dns2", cus_netifName);
+        sprintf(cus_operstate, "/sys/class/net/%s/operstate", cus_netifName);
+
+        RLOGD("[%s,%d]cus_gw:%s", __FUNCTION__, __LINE__, cus_gw);
+        RLOGD("[%s,%d]cus_local_ip:%s", __FUNCTION__, __LINE__, cus_local_ip);
+        RLOGD("[%s,%d]cus_dns1:%s", __FUNCTION__, __LINE__, cus_dns1);
+        RLOGD("[%s,%d]cus_dns2:%s", __FUNCTION__, __LINE__, cus_dns2);
+        RLOGD("[%s,%d]cus_operstate:%s", __FUNCTION__, __LINE__, cus_operstate);
+    }
+    else
+    {
+        RLOGD("[%s,%d]ril.fibocom.NetifName property not set, ret:%d", __FUNCTION__, __LINE__, cus_netifName_flag);
+    }
+
+    RLOGD("*********Leave %s***********", __FUNCTION__);
+
+}
+
+void get_cid()
+{
+    RLOGD("*********Enter %s***********", __FUNCTION__);
+    char cid_char[PROPERTY_VALUE_MAX]  = {0};
+    int ret;
+
+    //get netif name by proprity specified by user.
+    ret = property_get("ril.fibocom.cid", cid_char, "");
+
+    if(ret > MAX_CID_PROPERTY_LENGTH)
+    {
+        RLOGD("[%s,%d]The length of the property:ril.fibocom.cid is too long:%d, %d characters maximum allowed.", __FUNCTION__, __LINE__, ret, MAX_CID_PROPERTY_LENGTH);
+    }
+    else if(ret > 0)
+    {
+        RLOGD("[%s,%d]get ril.fibocom.cid:%s, ret:%d", __FUNCTION__, __LINE__, cid_char, ret);
+        cus_cid = atoi(cid_char);
+        if(cus_cid >= MIN_CID_NUM && cus_cid <= MAX_CID_NUM)
+        {
+            RLOGD("[%s,%d]cus_cid:%d", __FUNCTION__, __LINE__, cus_cid);
+        }
+        else
+        {
+            RLOGD("[%s,%d]cid:%d is expected to range from %d to %d", __FUNCTION__, __LINE__, cus_cid, MIN_CID_NUM, MAX_CID_NUM);
+            cus_cid = 1;
+        }
+
+    }
+    else
+    {
+        RLOGD("[%s,%d]ril.fibocom.cid property not set, ret:%d", __FUNCTION__, __LINE__, ret);
+    }
+
+    RLOGD("*********Leave %s***********", __FUNCTION__);
+
+}
+
+void requestSetupDataCall(void *data, size_t datalen, RIL_Token t)
+{
+    const char *apn;
+
+    //add by gaopjing test at+ecm begin
+
+    const char *pdp_type =NULL;
+    const char *username =NULL;
+    const char *password =NULL;
+    const char *auth_type =NULL;
+    int err;
+    int setup_data_call_result = 0;
+
+    ATResponse *p_response = NULL;
+    int response = 0;
+    int responsenet=0;
+    char *line;
+
+   
+    RLOGD("******** SHUT UP SELINUX ********");
+    char *cmd = NULL;
+    asprintf(&cmd, "setenforce 0");
+    RLOGD("%s",cmd);
+    system(cmd); 
+    free(cmd);
+    RLOGD("******** Enter requestSetupDataCall ********");
+    apn = ((const char **)data)[2];
+    username = ((const char **)data)[3];
+    password = ((const char **)data)[4];
+    auth_type = ((const char **)data)[5];
+
+    if (datalen > 6 * sizeof(char *))
+    {
+        pdp_type = ((const char **)data)[6];
+    }
+    else
+    {
+        pdp_type = "IP";
+    }
+
+#ifndef SIGNAL_MODEM
+    setup_data_call_result = setupDataCallDefault(apn);
+    if(setup_data_call_result == 1)
+    {
+        goto error;
+    }
+#else
+
+    char*response_local_ip[16];
+    if(dialmode == DIAL_RAS_MOD)
+    {
+        if(pppd)
+        {
+            RLOGD("Stop existing PPPd before activating PDP");
+            at_send_command("ATH", NULL);
+            property_set("ctl.stop", SERVICE_PPPD_GPRS);
+            if(ppp_fd > 0)
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+            pppd = 0;
+        }
+
+        //add by zhengjianrong for MA510 RIL BEGIN
+        if(mode_flag == GHT_M910_GL || mode_flag == GHT_MA510_GL){
+        //add by zhengjianrong for MA510 RIL END
+            setup_data_call_result = setupDataCallRASModeM910(response_local_ip,apn,auth_type,username,password,pdp_type);
+        }
+        else{
+            setup_data_call_result = setupDataCallRASMode(response_local_ip,apn,auth_type,username,password,pdp_type);
+        }
+    }
+    else if(dialmode == DIAL_NDIS_MOD)
+    {
+        setup_data_call_result = setupDataCallNDISMode(response_local_ip,apn,auth_type,username,password,pdp_type);
+    }
+	//added for NL678-E-00
+    else if(dialmode == DIAL_ECM_MOD)
+    {
+        setup_data_call_result = setupDataCallECMMode(response_local_ip,apn,auth_type,username,password,pdp_type);
+        RLOGD("setupDataCallECMMode ret:%d%s",setup_data_call_result, setup_data_call_result == 0? "":"(failure)");
+    }
+
+    if(setup_data_call_result ==1)
+    {
+        goto error;
+    }
+    else if(setup_data_call_result == 2)
+    {
+        goto ppp_ndis_error;
+    }
+#endif
+
+    requestOrSendDataCallList(&t);
+    return;
+
+ppp_ndis_error:
+    /* PDP activated successfully, but PPP connection can't be setup. So deactivate PDP context */
+    /* If PPPd is already launched, stop it */
+    if(dialmode == DIAL_RAS_MOD)
+    {
+        if(pppd)
+        {
+            at_send_command("ATH", NULL);
+            property_set("ctl.stop", SERVICE_PPPD_GPRS);
+            if(ppp_fd > 0)
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+            pppd = 0;
+        }
+    }
+    else if(dialmode == DIAL_NDIS_MOD)
+    {
+        /*begin:modified "AT$QCRMCALL=0,1" timeout 45s by lisf 20190418 for mantis 0019714*/
+       // err = at_send_command("AT$QCRMCALL=0,1", NULL);	
+        err = at_send_command_timeout("AT$QCRMCALL=0,1",NULL, ATSEND_TIMEOUT_MSEC*4+5000);
+       /*end:modified "AT$QCRMCALL=0,1" timeout 45s by lisf 20190418 for mantis 0019714*/
+        if(ndis_fd > 0)
+        {
+            close(ndis_fd);
+            ndis_fd = -1;
+        }
+	}
+    else if(dialmode == DIAL_ECM_MOD)
+    {
+        asprintf(&cmd, "AT+GTRNDIS=0,%d", cus_cid);
+        at_send_command_timeout(cmd, NULL, 30000);
+        free(cmd);
+    }
+    // fall through
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+
+void requestDeactivateDataCall(void *data, size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    char *cmd = NULL;
+
+    if(dialmode == DIAL_RAS_MOD)
+    {
+        char * cid;
+
+        ATResponse *p_response =NULL;
+        cid =((char **)data)[0];
+        if(pppd)
+        {
+	    gPid_pppd_died = get_pid("pppd");
+           RLOGD("Stop existing PPPd, pid [%d]", gPid_pppd_died);
+            err = at_send_command("ATH", NULL);
+            err = property_set("ctl.stop", SERVICE_PPPD_GPRS);
+		/*begin: added for NL678-E ppp dial by lisf 20190111*/
+		if(mode_flag  == GHT_NL678_E)
+	      {
+	      		ril_kill_pppd(0); 
+        	}
+		/*end: added for NL678-E ppp dial by lisf 20190111*/
+            if(ppp_fd > 0)
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+            if (err < 0)
+            {
+                RLOGD("Can not stop PPPd");
+                goto error;
+            }
+            pppd = 0;
+        }
+        asprintf(&cmd, "AT+CGACT=0,%s", cid);
+        err =at_send_command(cmd, &p_response);
+
+        at_response_free(p_response);
+        free(cmd);
+        cmd = NULL;
+    }
+    else if(dialmode == DIAL_NDIS_MOD)
+    {
+        /*begin:modified "AT$QCRMCALL=0,1" timeout 45s by lisf 20190418 for mantis 0019714*/
+      //  err = at_send_command("AT$QCRMCALL=0,1", NULL);
+        err = at_send_command_timeout("AT$QCRMCALL=0,1",NULL, ATSEND_TIMEOUT_MSEC*4+5000);
+        /*end:modified "AT$QCRMCALL=0,1" timeout 45s by lisf 20190418 for mantis 0019714*/
+        if (err < 0)
+        {
+            RLOGD("Can not down the ndis link");
+            goto error;
+        }
+    }
+    else if(dialmode == DIAL_ECM_MOD)
+    {
+
+        asprintf(&cmd, "AT+GTRNDIS=0,%d", cus_cid);
+        err = at_send_command_timeout(cmd, NULL, 30000);
+        free(cmd);
+        if (err < 0)
+        {
+            RLOGD("Can not down the ECM link");
+            goto error;
+        }
+
+        if(ANDROID_8 == Ght_Android_Version)
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 8 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            if(GHT_FG650 == mode_flag)
+            {
+                setRadioState(RADIO_STATE_OFF);
+                at_send_command("AT+CFUN=4", NULL);
+                at_send_command("AT+CFUN=1", NULL);
+                RLOGD("the module need to redial again!!!");
+            }
+        }
+
+        #if 0
+        #if defined GHT_FEATURE_ANDROID8X
+        if(GHT_FG650 == mode_flag)
+        {
+             setRadioState(RADIO_STATE_OFF);
+             at_send_command("AT+CFUN=4", NULL);
+             at_send_command("AT+CFUN=1", NULL);
+             RLOGD("the module need to redial again!!!");
+        }
+        #endif
+        #endif
+
+        RLOGD("%s: ECM_NetifName:%s", __FUNCTION__, ECM_NetifName);
+        if(mode_flag == GHT_L716)
+        {
+            asprintf(&cmd, "/system/bin/ip route del default dev %s", ECM_NetifName);
+            RLOGD("%s",cmd);
+            system(cmd);
+            free(cmd);
+        }
+
+        asprintf(&cmd, "/system/bin/busybox ifconfig %s down", ECM_NetifName);
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+
+    }
+
+    fibocom_pingflag = 0;
+
+    //bug41351,2020-02-24
+   // RIL_onUnsolicitedResponse (RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0); //added for debug 20181122
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+
+    return;
+
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+
+}
+
+
+void requestGetPreferredNetworkType(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    ATResponse *p_response = NULL;
+    int response = 0;
+    int responsenet=0;
+    char *line;
+	
+    if(mode_flag < GHT_NL668)
+    {
+        err = at_send_command_singleline("AT+MODODR?", "+MODODR:", &p_response);
+        if (err < 0 || p_response->success == 0)
+        {
+            goto error;
+        }
+    }
+    else if (((mode_flag >= GHT_NL668) && (mode_flag <= GHT_NL678_E)) ||(mode_flag == GHT_FG650)||(mode_flag == GHT_L716))//modified support for NL668 NORMAL by lisf 20190318
+    {
+        err = at_send_command_singleline("AT+GTRAT?", "+GTRAT:", &p_response);
+        if (err < 0 || p_response->success == 0)
+        {
+            goto error;
+        }	
+    }
+    line = p_response->p_intermediates->line;
+    err = at_tok_start(&line);
+    if (err < 0)
+    {
+        goto error;
+    }
+    err = at_tok_nextint(&line, &responsenet);
+    if (err < 0)
+    {
+        goto error;
+    } 
+    if(mode_flag < GHT_NL668)
+    {
+    switch(responsenet)
+    {
+        case 1:
+            response = PREF_NET_TYPE_WCDMA;
+            break;
+        case 2:
+            response = PREF_NET_TYPE_LTE_GSM_WCDMA;
+            break;
+        case 3:
+            response = PREF_NET_TYPE_GSM_ONLY;
+            break;
+        case 4:
+            response = PREF_NET_TYPE_GSM_WCDMA;
+            break;
+        case 5:
+            response = PREF_NET_TYPE_LTE_ONLY;
+            break;
+        case 6:
+            response = PREF_NET_TYPE_WCDMA;
+            break;
+        case 7:
+            response = PREF_NET_TYPE_WCDMA;
+            break;
+        case 8:
+            response = PREF_NET_TYPE_CDMA_ONLY;
+            break;
+        case 9:
+            response = PREF_NET_TYPE_CDMA_EVDO_AUTO;
+            break;
+        case 10:
+            response = PREF_NET_TYPE_EVDO_ONLY;
+            break;
+        default:
+            goto error;
+            break;
+        }
+     }
+	 else if(((mode_flag >= GHT_NL668) && (mode_flag <= GHT_NL678_E)) ||(mode_flag == GHT_FG650)||(mode_flag == GHT_L716))//modified support for NL668 NORMAL by lisf 20190318
+	 {
+        switch(responsenet)
+        {
+         case 0:        /*GSM*/
+             response = PREF_NET_TYPE_GSM_ONLY;
+             break;
+         case 1:        /*GSM/UMTS*/
+             response = PREF_NET_TYPE_GSM_WCDMA;
+             break;
+         case 2:        /*UMTS*/
+             response = PREF_NET_TYPE_WCDMA;
+             break;
+         case 3:        /*LTE*/
+             response = PREF_NET_TYPE_LTE_ONLY;
+             break;
+         case 4:        /*LTE/UMTS*/
+             response = PREF_NET_TYPE_LTE_WCDMA;
+             break;
+         case 5:        /*LTE/GSM*/
+             response = PREF_NET_TYPE_LTE_GSM_WCDMA;
+             break;
+         case 6:        /*LTE/UMTS/GSM*/
+             response = PREF_NET_TYPE_LTE_GSM_WCDMA;
+             break;
+         case 7:        /*TD-SCDMA*/
+             response = PREF_NET_TYPE_WCDMA;
+             break;
+         case 8:        /*eMTC*/
+         case 9:        /*NB-IoT*/
+             response = PREF_NET_TYPE_LTE_ONLY;
+             break;
+         case 10:       /*Automatic*/
+             response = PREF_NET_TYPE_LTE_GSM_WCDMA;
+             break;
+         case 11:       /*CDMA*/
+             response = PREF_NET_TYPE_CDMA_ONLY;
+             break;
+         case 12:       /*CDMA/EVDO*/
+             response = PREF_NET_TYPE_CDMA_EVDO_AUTO;
+             break;
+         case 13:       /*EVDO*/
+             response = PREF_NET_TYPE_EVDO_ONLY;
+             break;/* 
+         case 14:
+            response = PREF_NET_TYPE_NR_RAN;
+            break;
+        case 15:
+            response = PREF_NET_TYPE_NR_RAN_WCDMA;
+            break;
+        case 16:
+            response = PREF_NET_TYPE_NR_RAN_LTE;
+            break;
+        case 20:
+            response = PREF_NET_TYPE_NR_RAN_LTE_WCDMA;
+            break;  */ //modify stephen
+         default:
+             goto error;
+             break;
+         }
+    
+    }
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(int));
+    at_response_free(p_response);
+    return;
+error:
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+
+static void networkSkipWhiteSpace(char **p_cur)
+{
+    if (*p_cur == NULL) return;
+
+    while (**p_cur != '\0' && isspace(**p_cur)) {
+        (*p_cur)++;
+    }
+}
+
+
+int getPreferredNetworkType(char *old_str_mode)
+{
+    int err=0;
+    int mode = 3;
+    char *line;
+    ATResponse *p_response = NULL;
+	//added for NL678-E-00
+    if (mode_flag < GHT_NL668)
+    {
+	    err = at_send_command_singleline("AT+MODODR?", "+MODODR:", &p_response);
+	    if (err < 0|| p_response->success == 0)
+	      goto  error;
+	}
+	else if((mode_flag <= GHT_NL678_E && mode_flag >= GHT_NL668) || (mode_flag == GHT_FG650)|| (mode_flag == GHT_L716))//modified support for NL668 NORMAL by lisf 20190318 add L716 by gr 20220831
+	{
+		err = at_send_command_singleline("AT+GTRAT?", "+GTRAT:", &p_response);
+		if (err < 0|| p_response->success == 0)
+			goto error;
+	}
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0)
+      goto  error;
+
+    
+    networkSkipWhiteSpace(&line);
+    strncpy(old_str_mode, line, strlen(line));
+    err = at_tok_nextint(&line, &mode);
+    if (err < 0)
+      goto error;
+
+    at_response_free(p_response);
+    return mode;
+    
+    error:
+        at_response_free(p_response);
+        return 0;
+}
+
+void requestSetPreferredNetworkType(void *data, size_t datalen __unused, RIL_Token t)
+{
+
+    int err = 0;
+    int setmode = 0,mode = 0;
+    char *cmd = NULL;
+    char *str_mode = NULL;
+    setmode = ((int *)data)[0];
+    RLOGD("requestSetPreferredNetworkType setmode=%d",setmode);
+
+    if(0 == Net_3G_Support_Flag)
+    {
+        //The project generally only supports 4G and 3G networks. If 3G is not supported, it means 4G ONLY
+        if(GHT_L610 == mode_flag || GHT_MC66x == mode_flag)
+        {
+            RLOGD("The project only supports 4G networks, so change setmode to 11");
+            setmode = 11;
+        }
+    }
+
+    if(mode_flag < GHT_NL668)
+    {
+       switch(setmode)
+       {
+    /* BEGIN: Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+        case 22:  /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo */
+        case 12:    /* LTE/WCDMA */
+    /* END:   Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+        case 10:    /* LTE, CDMA, EvDo, GSM/WCDMA */
+        case 8:     /* LTE, CDMA and EvDo */
+        case 9:     /* LTE, GSM/WCDMA */
+            mode = 2;
+            break;
+        case 6:     /* EvDo only */
+        case 2:     /* WCDMA  */
+        case 0:     /* GSM/WCDMA (WCDMA preferred) */
+        case 3:     /* GSM/WCDMA (auto mode, according to PRL) */
+        case 4:     /* CDMA and EvDo (auto mode, according to PRL) */
+        case 7:     /* GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL) */
+            {
+                if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                {
+                    mode = 9;
+                }
+                else if(ODM_CM_OPERATOR == cur_oper)
+                {
+                    mode = 6;
+                }
+                else if(ODM_CU_OPERATOR == cur_oper)
+                {
+                    mode = 1;
+                }
+            }
+            break;
+        case 1:    /* GSM only */
+        case 5:    /* CDMA only */
+            {
+                if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                {
+                    mode = 8;
+                }
+                else if(ODM_CM_OPERATOR == cur_oper)
+                {
+                    mode = 3;
+                }
+                else if(ODM_CU_OPERATOR == cur_oper)
+                {
+                    mode = 3;
+                }
+                else
+                {
+                    mode =2;
+                }
+            }
+            break;
+        case 11:    /* LTE only */
+            mode = 5;
+            break;
+	/* BEGIN: Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+	#if 0
+	case 18:  /* TD-SCDMA, GSM/WCDMA */
+	     mode =4;
+	     break;
+	 #endif
+	/* END:   Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+        default:
+            mode = 2;
+            break;
+    }
+	 }
+     /*begin:added support for NL668 NORMAL by lisf 20190318*/
+       else if((mode_flag <= GHT_MDM_NORMAL) && (mode_flag >= GHT_NL668))
+       {
+           switch(setmode)
+	    {
+	        case 22:  /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo */
+	        case 10:    /* LTE, CDMA, EvDo, GSM/WCDMA */
+	        case 9:     /* LTE, GSM/WCDMA */
+	        case 12:    /* LTE/WCDMA */
+	        case 8:     /* LTE, CDMA and EvDo */
+                    mode = 10;
+	            break;
+	        case 0:     /* GSM/WCDMA (WCDMA preferred) */
+	        case 3:     /* GSM/WCDMA (auto mode, according to PRL) */
+	        case 7:     /* GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL) */
+	        case 21:    /*TD-SCDMA,EvDo,CDMA,GSM/WCDMA*/
+	        case 18:    /* TD-SCDMA, GSM/WCDMA */
+	        case 16:    /* TD-SCDMA and GSM */
+                if(ODM_CU_OPERATOR == cur_oper)
+                {
+                    /* BEGIN: Added by guorui, 2022/08/01  */
+                    str_mode = "2";
+                    /* END: Added by guorui, 2022/08/01  */
+                }
+                else if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                {
+                    mode = 12;
+                }
+                else
+                {
+                    mode = 1;
+                }
+                break;
+            case 6:     /* EvDo only */
+                mode = 13;
+                break;
+            case 2:     /* WCDMA  */
+            case 14:    /* TD-SCDMA and WCDMA */
+                mode = 2;
+                break;
+            case 4:     /* CDMA and EvDo (auto mode, according to PRL) */
+                mode = 12;
+                break;
+            case 19:    /* TD-SCDMA, WCDMA and LTE */
+            case 15:    /* TD-SCDMA and LTE */
+                mode = 4;
+                break;
+            case 13:    /* TD-SCDMA only */
+                mode = 7;
+                break;
+            case 17:    /* TD-SCDMA,GSM and LTE */
+            case 20:    /* TD-SCDMA, GSM/WCDMA and LTE */
+                mode = 6;
+                break;
+            /* BEGIN: Added by guorui, 2022/08/01  */
+            case 1:    /* GSM only */
+                if(ODM_CM_OPERATOR == cur_oper)
+                {
+                    str_mode = "0";
+                }
+                else if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                {
+                    mode = 11;
+                }
+                else
+                {
+                    mode = 0;
+                }
+                break;
+            case 5:    /* CDMA only */
+                mode = 11;
+                break;
+            case 11:    /* LTE only */
+                mode = 3;
+                break;
+            default:
+                mode = 10;
+                break;
+        }
+       }
+     else if(mode_flag  == GHT_L716)
+     {
+        switch(setmode)
+        {
+            case 22:  /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo */
+            case 10:    /* LTE, CDMA, EvDo, GSM/WCDMA */
+            case 9:     /* LTE, GSM/WCDMA */
+            case 12:    /* LTE/WCDMA */
+            case 8:     /* LTE, CDMA and EvDo */
+                    mode = 10;
+                break;
+            case 0:     /* GSM/WCDMA (WCDMA preferred) */
+            case 3:     /* GSM/WCDMA (auto mode, according to PRL) */
+            case 7:     /* GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL) */
+            case 21:    /*TD-SCDMA,EvDo,CDMA,GSM/WCDMA*/
+            case 18:    /* TD-SCDMA, GSM/WCDMA */
+            case 16:    /* TD-SCDMA and GSM */
+                if(ODM_CU_OPERATOR == cur_oper)
+                {
+                    str_mode = "2";
+                }
+                else if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                {
+                    mode = 12;
+                }
+                else
+                {
+                    mode = 1;
+                }
+                break;
+            case 6:     /* EvDo only */
+                mode = 13;
+                break;
+            case 2:     /* WCDMA  */
+            case 14:    /* TD-SCDMA and WCDMA */
+                mode = 2;
+                break;
+            case 4:     /* CDMA and EvDo (auto mode, according to PRL) */
+                mode = 12;
+                break;
+            case 19:    /* TD-SCDMA, WCDMA and LTE */
+            case 15:    /* TD-SCDMA and LTE */
+                mode = 4;
+                break;
+            case 13:    /* TD-SCDMA only */
+                mode = 7;
+                break;
+            case 17:    /* TD-SCDMA,GSM and LTE */
+            case 20:    /* TD-SCDMA, GSM/WCDMA and LTE */
+                mode = 6;
+                break;
+            case 1:    /* GSM only */
+                if(ODM_CM_OPERATOR == cur_oper)
+                {
+                    str_mode = "0";
+                }
+                else if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                {
+    /* END: Added by guorui, 2022/08/01 */
+                    mode = 11;
+                }
+                else
+                {
+                    mode = 0;
+                }
+                break;
+            case 5:    /* CDMA only */
+                mode = 11;
+                break;
+            case 11:    /* LTE only */
+                mode = 3;
+                break;
+            default:
+                mode = 10;
+                break;
+        }
+       }
+       /*end:added support for NL668 NORMAL by lisf 20190318*/
+     else if(mode_flag  == GHT_L610)  //NOTE: MC669 and MC919 do not support this branch!
+     {
+	    switch(setmode)
+	    {
+	    /* BEGIN: Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+	        case 22:  /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo */
+	        case 12:    /* LTE/WCDMA */
+	    /* END:   Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+	        case 10:    /* LTE, CDMA, EvDo, GSM/WCDMA */
+	        case 8:     /* LTE, CDMA and EvDo */
+	        case 9:     /* LTE, GSM/WCDMA */
+	            mode = 10;
+	            break;
+	        case 1:    /* GSM only */
+	        case 5:    /* CDMA only */
+	            mode = 0;
+	            break;
+	        case 11:    /* LTE only */
+	            mode = 3;
+	            break;
+	        default:
+	            mode = 10;
+	            break;
+	    }
+	 }
+	 else if(mode_flag  == GHT_FG621 )
+	 {
+	    switch(setmode)
+	    {
+	    /* BEGIN: Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+	        case 22:  /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo */
+	        case 12:    /* LTE/WCDMA */
+	    /* END:   Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+	        case 10:    /* LTE, CDMA, EvDo, GSM/WCDMA */
+	        case 8:     /* LTE, CDMA and EvDo */
+	        case 9:     /* LTE, GSM/WCDMA */
+	            mode = 10;
+	            break;
+	        case 2:     /* WCDMA  */
+	        case 14:    /* TD-SCDMA and WCDMA */
+	            mode = 2;
+	            break;
+	        case 19:    /* TD-SCDMA, WCDMA and LTE */
+	        case 15:    /* TD-SCDMA and LTE */
+	            mode = 4;
+	            break;
+	        case 11:    /* LTE only */
+	            mode = 3;
+	            break;
+	        default:
+	            mode = 10;
+	            break;
+	    }
+	 }
+        else if(mode_flag == GHT_FG650)
+        {
+
+            RLOGD("GHT_FG650[%s,%d]setmode=[%d]",__FUNCTION__, __LINE__, setmode);
+            switch(setmode)
+            {
+                case 28: /*NETWORK_MODE_NR_LTE_WCDMA*/
+                    str_mode = "20,6,3";
+                    break;
+				case 10:  /* LTE, CDMA, EvDo, GSM/WCDMA */
+				case 8:   /* LTE, CDMA and EvDo */
+				case 20:  /* TD-SCDMA,GSM/WCDMA and LTE*/
+                case 19:  /* TD-SCDMA,WCDMA and LTE*/
+                case 17:  /* TD-SCDMA,GSM and LTE*/
+				case 15:  /* TD-SCDMA and LTE*/
+                case 12:  /* LTE/WCDMA */
+                      str_mode = "4,3";
+                      break;
+                case 11:  /* LTE only */
+//                      mode = 3;
+                      str_mode = "3";
+                      break;
+                case 21:  /* TD-SCDMA,GSM/WCDMA, CDMA, and EvDo */
+                case 18:  /* TD-SCDMA,GSM/WCDMA*/
+                case 14:  /* TD-SCDMA and WCDMA*/
+                case 7:   /* GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL) */
+                case 3:   /* GSM/WCDMA  (auto mode, according to PRL) */
+                case 2:   /* WCDMA  */
+                case 0:   /* GSM/WCDMA (WCDMA preferred) */
+                case 16:  /* TD-SCDMA and GSM*/   
+                case 13:  /* TD-SCDMA only*/
+                case 6:   /* EvDo only */
+                case 5:   /* CDMA only */
+                case 4:   /* CDMA and EvDo (auto mode, according to PRL) */
+                      RLOGD("GHT_FG650 cur_oper:[%d]", cur_oper);
+                      //FM650 only supports Unicom 3G network
+                      if(ODM_CU_OPERATOR == cur_oper)
+                      {
+//                          mode = 2;
+                          str_mode = "2";
+                      }
+                      else
+                      {
+//                          mode = 20;
+                          str_mode = "20,6,3";
+                      }
+                      break;
+                default:
+//                      mode = 20;
+                      str_mode = "20,6,3";
+                      break;
+            }
+        }
+	 else if(mode_flag  == GHT_NL678_E)
+	 {
+	    switch(setmode)
+	    {
+	    /* BEGIN: Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+	        case 22:  /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo */
+	        case 12:    /* LTE/WCDMA */
+	    /* END:   Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+	        case 10:    /* LTE, CDMA, EvDo, GSM/WCDMA */
+	        case 8:     /* LTE, CDMA and EvDo */
+	        case 9:     /* LTE, GSM/WCDMA */
+	            mode = 10;
+	            break;
+	        case 6:     /* EvDo only */
+	        case 2:     /* WCDMA  */
+	        case 0:     /* GSM/WCDMA (WCDMA preferred) */
+	        case 3:     /* GSM/WCDMA (auto mode, according to PRL) */
+	        case 4:     /* CDMA and EvDo (auto mode, according to PRL) */
+	        case 7:     /* GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL) */
+	            {
+	                if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+	                {
+	                    mode = 12;
+	                }
+	                else if(ODM_CM_OPERATOR == cur_oper)
+	                {
+	                    mode = 2;
+	                }
+	                else if(ODM_CU_OPERATOR == cur_oper)
+	                {
+	                    mode = 2;
+	                }
+	            }
+	            break;
+	        case 1:    /* GSM only */
+	        case 5:    /* CDMA only */
+	            {
+	                if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+	                {
+	                    mode = 11;
+	                }
+	                else if(ODM_CM_OPERATOR == cur_oper)
+	                {
+	                    mode = 2;
+	                }
+	                else if(ODM_CU_OPERATOR == cur_oper)
+	                {
+	                    mode = 2;
+	                }
+	                else
+	                {
+	                    mode =10;
+	                }
+	            }
+	            break;
+	        case 11:    /* LTE only */
+	            mode = 3;
+	            break;
+	        default:    /* GSM only */
+	            mode = 10;
+	            break;
+	    }
+	 }
+     else if(GHT_H330S == mode_flag){
+         RLOGD("GHT_H330S[%s,%d]setmode=[%d]",__FUNCTION__, __LINE__, setmode);
+         switch(setmode)
+         {
+         case 1:    /* GSM only */
+            mode = 0;
+            break;
+         default:
+            mode = 2;
+            break;
+         }
+
+/*         if(ODM_CM_OPERATOR == cur_oper)
+             mode = 0;
+         else if(ODM_CU_OPERATOR == cur_oper)
+             mode = 2;
+         else if(ODM_CT_OPERATOR_3G == cur_oper || ODM_CT_OPERATOR_4G == cur_oper)
+         {
+             RLOGD("error : The H330S does not support telecom cards");
+             goto error;
+         }
+         else
+         {
+             RLOGD("error : Unknown SIM card");    //This code should never be executed
+             goto error;
+         }*/
+    }
+    else
+    {
+        RLOGD("Unknown module, cannot set preferred network");
+        goto error;
+    }
+
+    char old_str_mode[100] = {0};
+    int NetworkType;
+    ATResponse *outResponse;
+
+    NetworkType = getPreferredNetworkType(old_str_mode);
+    RLOGD("debug: NetworkType:%d, old_str_mode:%s, str_mode:%s",NetworkType, old_str_mode,str_mode);
+    if((GHT_FG650 == mode_flag && strcmp(old_str_mode,str_mode)) || (GHT_FG650 != mode_flag && mode != NetworkType))
+    {
+        RLOGD("requestSetPreferredNetworkType setmode=%d, mode=%d, str_mode=%s",setmode, mode, str_mode);
+        if(mode_flag < GHT_NL668)
+        {
+            asprintf(&cmd,"AT+MODODR=%d",mode);
+        }
+        /* BEGIN: Added by guorui, 2022/08/01  */
+        else if(((mode_flag <= GHT_MDM_NORMAL) && (mode_flag >= GHT_NL668)) || (mode_flag == GHT_L716))
+        {
+            if(str_mode != NULL){
+                asprintf(&cmd, "AT+GTRAT=%s", str_mode);
+            }
+            else
+            {
+                asprintf(&cmd,"AT+GTRAT=%d",mode);
+            }
+        }
+        else if(((mode_flag >= GHT_L610) && (mode_flag <= GHT_NL678_E))  || (GHT_H330S == mode_flag))//modified support for NL668 NORMAL by lisf 20190318
+        {
+        /* END: Added by guorui, 2022/08/01  */
+            asprintf(&cmd,"AT+GTRAT=%d",mode);
+        }
+        else if(mode_flag == GHT_FG650)
+        {
+            asprintf(&cmd, "AT+GTRAT=%s", str_mode);
+        }
+        err = at_send_command(cmd, &outResponse);
+        free(cmd);
+        cmd = NULL;
+
+        /* BEGIN: Added by eric.li, 2019/2/19   PN:free more mem on time  */
+        if (err < 0 )
+        {
+            goto error;
+        }
+        /* END:   Added by eric.li, 2019/2/19   PN:free more mem on time  */
+
+        /*BEGIN: Added by wujiabao in 2022/05/27, only when the GTRAT command is successfully executed, the data_call is deactivated*/
+        if(true == outResponse->success)
+        /*END:   Added by wujiabao in 2022/05/27, only when the GTRAT command is successfully executed, the data_call is deactivated*/
+        {
+            /*begin:added by lisf for switch cdma & evdo*/
+            if(((mode_flag >= GHT_NL668) && (mode_flag <= GHT_NL678_E))||mode_flag == GHT_L716)
+            {
+                if(mode ==12 || 11 ==mode)
+                {
+                    RIL_onUnsolicitedResponse (RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0);
+                    RIL_onUnsolicitedResponse( RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);
+                }
+            }
+            onDeactiveDataCallList();
+            /*end:added by lisf for switch cdma & evdo*/
+        }
+    }
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    return;
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+
+void requestSetNetworkSelectionManual(void *data, size_t datalen __unused, RIL_Token t)
+{
+    const char *operator = NULL;
+    char *cmd = NULL;
+    int err = 0;
+    ATResponse *p_response = NULL;
+
+    operator = (const char *)data;
+    // <!--[ODM]lindong@2017.11.24 for manual select network
+    RLOGD("[%s,%d]operator[%p]",__FUNCTION__, __LINE__, operator);
+    if(NULL == operator)
+    {
+        goto error;
+    }
+    RLOGD("[%s,%d],operator[%s]",__FUNCTION__, __LINE__, operator);
+    // --!>
+    asprintf(&cmd, "AT+COPS=1,2,\"%s\" ", operator);
+
+/* BEGIN: Modified by eric.li, 2018/11/5   PN:fix bug 11301 that at+cops timeout on NL668-AM */
+    //err = at_send_command(cmd, &p_response);
+    err = at_send_command_timeout(cmd, &p_response, TIME_OUT_COPS );//wait long timeout by trento
+/* END:   Modified by eric.li, 2018/11/5   PN:fix bug 11301 that at+cops timeout on NL668-AM */
+    free(cmd);
+    if (err < 0 || p_response->success == 0)
+    {
+        // err = at_send_command("AT+COPS=0", NULL);
+        // if(err < 0)
+// <!--added by wangmengying@2017.12.13 for register network failed still need to send cops=0
+        g_SetNetworkSelectionManual = 1;
+// end-->
+        goto error;
+    }
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    at_response_free(p_response);
+
+    return;
+error:
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    sleep(1);
+    onDeactiveDataCallList();
+}
+
+void requestNeighboringCellIds(void * data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    ATResponse *p_response = NULL;
+    char *line, *p;
+    int commas;
+    int skip;
+    int i;
+    int count = 3;
+    int lac = 0,cid = 0;
+    int ber;
+    int rssi;
+
+    RIL_NeighboringCell **pp_cellIds;
+    RIL_NeighboringCell *p_cellIds;
+
+    pp_cellIds = (RIL_NeighboringCell **)alloca(sizeof(RIL_NeighboringCell *));
+    p_cellIds = (RIL_NeighboringCell *)alloca(sizeof(RIL_NeighboringCell));
+    pp_cellIds[0]=p_cellIds;
+
+    err = 1;
+    for (i=0; i<4 && err != 0; i++)
+        err = at_send_command_singleline("AT+CREG?", "+CREG:", &p_response);
+
+    if (err < 0 || p_response->success == 0 ) goto error;
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+    /* Ok you have to be careful  here
+     * The solicited version of the CREG response is
+     * +CREG: n, stat, [lac, cid]
+     * and the unsolicited version is
+     * +CREG: stat, [lac, cid]
+     * The <n> parameter is basically "is unsolicited creg on?"
+     * which it should always be
+     *
+     * Now we should normally get the solicited version here,
+     * but the unsolicited version could have snuck in
+     * so we have to handle both
+     *
+     * Also since the LAC and CID are only reported when registered,
+     * we can have 1, 2, 3, or 4 arguments here
+     *
+     * finally, a +CGREG: answer may have a fifth value that corresponds
+     * to the network type, as in;
+     *
+     *   +CGREG: n, stat [,lac, cid [,networkType]]
+     */
+
+    /* count number of commas */
+    commas = 0;
+    for (p = line ; *p != '\0' ;p++) {
+        if (*p == ',') commas++;
+    }
+    switch (commas) 
+    {
+        case 0: /* +CREG: <stat> */
+        case 1: /* +CREG: <n>, <stat> */
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            break;
+            //goto error;
+        case 2: /* +CREG: <stat>, <lac>, <cid> */
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &lac);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &cid);
+            if (err < 0) goto error;
+            break;
+        case 3: /* +CREG: <n>, <stat>, <lac>, <cid> */
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &lac);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &cid);
+            if (err < 0) goto error;
+            break;
+        case 4: /* +CGREG: <n>, <stat>, <lac>, <cid>, <networkType> */
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &skip);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &lac);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &cid);
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &skip);
+            if (err < 0) goto error;
+            count = 4;
+            break;
+        default:
+            goto error;
+    }
+
+    RLOGD("request neighboring cellID : lac : %x, cid : %x", lac, cid);
+    at_response_free(p_response);
+
+    err = at_send_command_singleline("AT+CSQ", "+CSQ:", &p_response);
+
+     if (err < 0 || p_response->success == 0) {
+         goto error;
+     }
+
+     line = p_response->p_intermediates->line;
+
+     err = at_tok_start(&line);
+     if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &rssi);
+      if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &ber);
+      if (err < 0) goto error;
+
+    p_cellIds[0].cid = (char*) alloca(16);
+    sprintf(p_cellIds[0].cid, "%04x%04x", lac & 0xFFFF, cid & 0xFFFF );
+    p_cellIds[0].rssi = rssi;
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, pp_cellIds, sizeof(pp_cellIds));
+    at_response_free(p_response);
+    p_response = NULL;
+    return;
+
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    if (p_response)
+    {
+        at_response_free(p_response);
+    }
+    return ;
+}
+
+void requestGetCellInfoList(void * data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err,i = 0;
+    ATResponse *atResponse = NULL;
+    char *line;
+    int resp[15]={0};  //mode,type,<MCC>,<MNC>,<LAC>,<CI>,<scrambling_code>....
+    int ber = 99;
+    int sig_strength = 99;
+    int rsrp = 0;
+    int rsrq = 0;
+#define CELL_NUM 20              //We expect to store data for up to 19 neighboring cells
+    //RLOGE("requestGetCellInfoList:");
+
+    RIL_CellInfo *p_cellInfo;
+    int cellInfo_len = sizeof(RIL_CellInfo);
+
+    if(ANDROID_10 == Ght_Android_Version || ANDROID_7 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        cellInfo_len = sizeof(RIL_CellInfo_v12);
+    }
+    p_cellInfo = (RIL_CellInfo *)malloc(CELL_NUM * sizeof(RIL_CellInfo) + 128);
+    RLOGD("version_check sizeof(RIL_CellInfo):%d, sizeof(RIL_CellInfo_v12):%d", sizeof(RIL_CellInfo), sizeof(RIL_CellInfo_v12));
+
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+    RLOGD("RIL_CellInfo_v12");
+    RIL_CellInfo_v12 p_cellInfo[CELL_NUM];
+#else
+    RLOGD("not RIL_CellInfo_v12");
+    RIL_CellInfo p_cellInfo[CELL_NUM];
+//    p_cellInfo = (RIL_CellInfo *)alloca(sizeof(RIL_CellInfo));
+#endif
+#endif
+
+    err = at_send_command_singleline("AT+CSQ", "+CSQ:", &atResponse);
+
+    if (err < 0 || atResponse->success == 0)
+    {
+        RLOGD("at_send_command_singleline(AT+CSQ) return err[%d]", err);
+        goto error;
+    }
+    line = atResponse->p_intermediates->line;
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+    err = at_tok_nextint(&line, &sig_strength);
+    if (err < 0) goto error;
+    err = at_tok_nextint(&line, &ber);
+    if (err < 0) goto error;
+
+    at_response_free(atResponse);
+    atResponse = NULL;
+
+    err = at_send_command_multiline_timeout("AT+GTCCINFO?","", 2 * ATSEND_TIMEOUT_MSEC, &atResponse);
+
+    if (err < 0 || atResponse->success == 0)
+    {
+        RLOGD("requestGetCellInfoList: at_send_command_singleline(AT+CELLINFO?) return err[%d]", err);
+        goto error;
+    }
+    else
+    {
+    ATLine *p_cur;
+    int CurretService = 0;
+
+    for (p_cur = atResponse->p_intermediates
+            ; p_cur != NULL && i < CELL_NUM
+            ; p_cur = p_cur->p_next)
+    {
+        char *line = p_cur->line;
+
+        if (!at_tok_hasmore(&line))
+        {
+            RLOGD("That`s all.");
+            continue;
+        }
+        if(!(strncmp(line,"GSM service cell:",strlen("GSM service cell:"))) ||
+            !(strncmp(line,"UMTS service cell:",strlen("UMTS service cell:"))) ||
+            !(strncmp(line,"LTE service cell:",strlen("LTE service cell:"))) ||
+            !(strncmp(line,"CDMA service cell:",strlen("CDMA service cell:"))) ||
+            !(strncmp(line,"EVDO service cell:",strlen("EVDO service cell:"))) ||
+            !(strncmp(line,"eMTC service cell:",strlen("eMTC service cell:"))) ||
+            !(strncmp(line,"NB-IoT service cell:",strlen("NB-IoT service cell:"))))
+        {
+            RLOGD("[%d]service cell:%s",__LINE__,line);
+            CurretService = 1;
+            p_cur = p_cur->p_next;
+            line = p_cur->line;
+            RLOGD("[%d]cell:%s",__LINE__,line);
+            err = at_tok_nextint(&line, &resp[0]); //IsServiceCell
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &resp[1]);///rat
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &resp[2]);//MCC
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &resp[3]);//MNC
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &resp[4]);//LAC   //tac
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &resp[5]);//CID
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &resp[6]);//LTE:earfcn;GSM:arfcn;UMTS:uarfcn
+            if (err < 0) goto error;
+            err = at_tok_nexthexint(&line, &resp[7]);//LTE:physicalcellId;GSM:basic;UMTS:psc
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &resp[8]);//band
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &resp[9]);//bandwidth
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &resp[10]);//rssnr_value
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &resp[11]);//rxlev
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &resp[12]);//rsrp
+            if (err < 0) goto error;
+            err = at_tok_nextint(&line, &resp[13]);//rsrq
+            if (err < 0) goto error;
+            
+            rsrp = resp[12];
+            rsrq = resp[13];
+            
+            rsrp = (140 - rsrp);
+            rsrq = (rsrq / 2 -3);
+switch(resp[1]){
+        //GSM
+        case 1:
+            RLOGE("GTCCINFO GSM:MCC=%d , MNC=%d , LAC=%d , CID=%d , SCRAM_CODE=%d...",resp[2],resp[3],resp[4],resp[5],resp[6]);
+            RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d , SCRAM_CODE1=%d...",g_mcc,g_mnc,g_lac,g_cid,resp[6]);
+            p_cellInfo[0].cellInfoType = RIL_CELL_INFO_TYPE_GSM;
+            p_cellInfo[0].registered = 1;
+            p_cellInfo[0].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+            p_cellInfo[0].timeStamp = 0;
+            p_cellInfo[0].CellInfo.gsm.cellIdentityGsm.mcc = ((g_mcc!=0xffff)?g_mcc:resp[2]);  //MCC
+            p_cellInfo[0].CellInfo.gsm.cellIdentityGsm.mnc = ((g_mnc!=0xffff)?g_mnc:resp[3]);  //MNC
+            p_cellInfo[0].CellInfo.gsm.cellIdentityGsm.lac = ((g_lac!=0xffff)?g_lac:resp[4]);  //LAC
+            p_cellInfo[0].CellInfo.gsm.cellIdentityGsm.cid = ((g_cid!=0xffff)?g_cid:resp[5]);  //CID
+
+            if(ANDROID_10 == Ght_Android_Version || ANDROID_7 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                ((RIL_CellInfo_v12 *)p_cellInfo)[0].CellInfo.gsm.cellIdentityGsm.arfcn = resp[6];    //arfcn
+                ((RIL_CellInfo_v12 *)p_cellInfo)[0].CellInfo.gsm.cellIdentityGsm.bsic = resp[7];     //basic
+            }
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+            p_cellInfo[0].CellInfo.gsm.cellIdentityGsm.arfcn = resp[6];    //arfcn
+            p_cellInfo[0].CellInfo.gsm.cellIdentityGsm.bsic = resp[7];     //basic
+#endif
+#endif
+            p_cellInfo[0].CellInfo.gsm.signalStrengthGsm.signalStrength = sig_strength;
+            p_cellInfo[0].CellInfo.gsm.signalStrengthGsm.bitErrorRate = ber;
+
+            if(ANDROID_10 == Ght_Android_Version || ANDROID_7 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                ((RIL_CellInfo_v12 *)p_cellInfo)[0].CellInfo.gsm.signalStrengthGsm.timingAdvance = INT_MAX;  //0xffff
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+            p_cellInfo[0].CellInfo.gsm.signalStrengthGsm.timingAdvance = INT_MAX;  //0xffff
+#endif
+#endif
+
+            break;
+        //WCDMA
+        case 2:
+            RLOGE("GTCCINFO WCDMA:MCC=%d , MNC=%d , LAC=%d , CID=%d , SCRAM_CODE=%d...",resp[2],resp[3],resp[4],resp[5],resp[6]);
+            RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d , SCRAM_CODE1=%d...",g_mcc,g_mnc,g_lac,g_cid,resp[6]);
+            p_cellInfo[0].cellInfoType = RIL_CELL_INFO_TYPE_WCDMA;
+            p_cellInfo[0].registered = 1;
+            p_cellInfo[0].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+            p_cellInfo[0].timeStamp = 0;
+            p_cellInfo[0].CellInfo.wcdma.cellIdentityWcdma.mcc = ((g_mcc!=0xffff)?g_mcc:resp[2]);  //MCC
+            p_cellInfo[0].CellInfo.wcdma.cellIdentityWcdma.mnc = ((g_mnc!=0xffff)?g_mnc:resp[3]);  //MNC
+            p_cellInfo[0].CellInfo.wcdma.cellIdentityWcdma.lac = ((g_lac!=0xffff)?g_lac:resp[4]);  //LAC
+            p_cellInfo[0].CellInfo.wcdma.cellIdentityWcdma.cid = ((g_cid!=0xffff)?g_cid:resp[5]);  //CID
+            p_cellInfo[0].CellInfo.wcdma.cellIdentityWcdma.psc = resp[7];
+
+            if(ANDROID_10 == Ght_Android_Version || ANDROID_7 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                ((RIL_CellInfo_v12 *)p_cellInfo)[0].CellInfo.wcdma.cellIdentityWcdma.uarfcn = resp[6];
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+            p_cellInfo[0].CellInfo.wcdma.cellIdentityWcdma.uarfcn = resp[6];
+#endif
+#endif
+
+            p_cellInfo[0].CellInfo.wcdma.signalStrengthWcdma.signalStrength = sig_strength;
+            p_cellInfo[0].CellInfo.wcdma.signalStrengthWcdma.bitErrorRate = ber;
+            break;
+//#ifndef GHT_FEATURE_ANDROID4X
+        //TDSCDMA
+        case 3:
+            if(Ght_Android_Version != ANDROID_4)
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d != 4 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                RLOGE("GTCCINFO TDSCDMA:MCC=%d , MNC=%d , LAC=%d , CID=%d , SCRAM_CODE=%d...",resp[2],resp[3],resp[4],resp[5],resp[6]);
+                RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d , SCRAM_CODE1=%d...",g_mcc,g_mnc,g_lac,g_cid,resp[6]);
+                p_cellInfo[0].cellInfoType = RIL_CELL_INFO_TYPE_TD_SCDMA;
+                p_cellInfo[0].registered = 1;
+                p_cellInfo[0].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+                p_cellInfo[0].timeStamp = 0;
+                p_cellInfo[0].CellInfo.tdscdma.cellIdentityTdscdma.mcc = ((g_mcc!=0xffff)?g_mcc:resp[2]);  //MCC
+                p_cellInfo[0].CellInfo.tdscdma.cellIdentityTdscdma.mnc = ((g_mnc!=0xffff)?g_mnc:resp[3]);  //MNC
+                p_cellInfo[0].CellInfo.tdscdma.cellIdentityTdscdma.lac = ((g_lac!=0xffff)?g_lac:resp[4]);  //LAC
+                p_cellInfo[0].CellInfo.tdscdma.cellIdentityTdscdma.cid = ((g_cid!=0xffff)?g_cid:resp[5]);  //CID
+                p_cellInfo[0].CellInfo.tdscdma.signalStrengthTdscdma.rscp = sig_strength;
+                break;
+            }
+//#endif
+        //LTE/NB-IoT/eMTC
+        case 4:
+        case 5:
+        case 6:
+            RLOGE("GTCCINFO LTE:MCC=%d , MNC=%d , CID=%d ...",resp[2],resp[3],resp[4]);
+            RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d ...",g_mcc,g_mnc,g_lac,g_cid);
+            p_cellInfo[0].cellInfoType = RIL_CELL_INFO_TYPE_LTE;
+            p_cellInfo[0].registered = 1;
+            p_cellInfo[0].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+            p_cellInfo[0].timeStamp = 0;
+            p_cellInfo[0].CellInfo.lte.cellIdentityLte.mcc = ((g_mcc!=0xffff)?g_mcc:resp[2]);  //MCC
+            p_cellInfo[0].CellInfo.lte.cellIdentityLte.mnc = ((g_mnc!=0xffff)?g_mnc:resp[3]);  //MNC
+            p_cellInfo[0].CellInfo.lte.cellIdentityLte.tac = resp[4];  //tac
+            p_cellInfo[0].CellInfo.lte.cellIdentityLte.ci = ((g_cid!=0xffff)?g_cid:resp[5]);  //CID
+
+            if(ANDROID_10 == Ght_Android_Version || ANDROID_7 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                ((RIL_CellInfo_v12 *)p_cellInfo)[0].CellInfo.lte.cellIdentityLte.earfcn = resp[6];  //earfcn
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+            p_cellInfo[0].CellInfo.lte.cellIdentityLte.earfcn = resp[6];  //earfcn
+#endif
+#endif
+            p_cellInfo[0].CellInfo.lte.cellIdentityLte.pci = ((g_pci!=0xffff)?g_pci:resp[7]);  //pci
+
+
+            p_cellInfo[0].CellInfo.lte.signalStrengthLte.signalStrength = sig_strength;
+            p_cellInfo[0].CellInfo.lte.signalStrengthLte.rsrp = rsrp;    //rsrp
+            p_cellInfo[0].CellInfo.lte.signalStrengthLte.rsrq = rsrq;    //rsrq
+            p_cellInfo[0].CellInfo.lte.signalStrengthLte.rssnr = resp[10];   //rssnr_value      //INT_MAX or 0?
+            p_cellInfo[0].CellInfo.lte.signalStrengthLte.cqi=INT_MAX;         //INT_MAX or 0 ?
+            p_cellInfo[0].CellInfo.lte.signalStrengthLte.timingAdvance = INT_MAX;   //INT_MAX or 0 ?
+
+            break;
+        //CDMA,EVDO
+        case 7:
+        case 8:
+            RLOGE("GTCCINFO CDMA:MCC=%d , MNC=%d , LAC=%d , CID=%d , SCRAM_CODE=%d...",resp[2],resp[3],resp[4],resp[5],resp[6]);
+            RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d , SCRAM_CODE1=%d...",g_mcc,g_mnc,g_lac,g_cid,resp[6]);
+            p_cellInfo[0].cellInfoType = RIL_CELL_INFO_TYPE_CDMA;
+            p_cellInfo[0].registered = 1;
+            p_cellInfo[0].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+            p_cellInfo[0].timeStamp = 0;
+            p_cellInfo[0].CellInfo.cdma.cellIdentityCdma.networkId = resp[3];
+            p_cellInfo[0].CellInfo.cdma.cellIdentityCdma.systemId = resp[2];
+            p_cellInfo[0].CellInfo.cdma.cellIdentityCdma.basestationId = resp[4];
+            p_cellInfo[0].CellInfo.cdma.cellIdentityCdma.longitude = resp[9];
+            p_cellInfo[0].CellInfo.cdma.cellIdentityCdma.latitude = resp[10];
+            if (7 == resp[1])
+            {
+                p_cellInfo[0].CellInfo.cdma.signalStrengthCdma.dbm = sig_strength;
+                p_cellInfo[0].CellInfo.cdma.signalStrengthCdma.ecio = ber;
+            }
+            else
+            {
+                p_cellInfo[0].CellInfo.cdma.signalStrengthEvdo.dbm = sig_strength;
+                p_cellInfo[0].CellInfo.cdma.signalStrengthEvdo.ecio = ber;
+            }
+            break;
+        default:
+            RLOGE("GTCCINFO type not defined..");
+            break;
+        }
+        i++;
+
+            continue;
+        }
+        else if(!(strncmp(line,"GSM neighbor cell:",strlen("GSM neighbor cell:"))) ||
+            !(strncmp(line,"UMTS neighbor cell:",strlen("UMTS neighbor cell:"))) ||
+            !(strncmp(line,"LTE neighbor cell:",strlen("LTE neighbor cell:"))) ||
+            !(strncmp(line,"CDMA neighbor cell:",strlen("CDMA neighbor cell:"))) ||
+            !(strncmp(line,"EVDO neighbor cell:",strlen("EVDO neighbor cell:"))) ||
+            !(strncmp(line,"eMTC neighbor cell:",strlen("eMTC neighbor cell:"))) ||
+            !(strncmp(line,"NB-IoT neighbor cell:",strlen("NB-IoT neighbor cell:")))||
+            !(strncmp(line,"NB-IoT neighbor cell:",strlen("NB-IoT neighbor cell:")))||
+            !(strncmp(line,"+GTCCINFO:",strlen("+GTCCINFO:"))) ||
+            !(strncmp(line,"+CREG:",strlen("+CREG:"))) ||
+            !(strncmp(line,"+CGREG:",strlen("+CREG:"))) ||
+            !(strncmp(line,"+CEREG:",strlen("+CREG:"))))
+            {
+                RLOGD("[%d]useless Line:%s",__LINE__,line);
+                continue;
+            }
+
+                line = p_cur->line;
+                RLOGD("[%d]neighbor cell:%s",__LINE__,line);
+                err = at_tok_nextint(&line, &resp[0]); //IsServiceCell
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[1]);///rat
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[2]);//MCC
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[3]);//MNC
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[4]);//LAC   //tac
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[5]);//CID
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[6]);//LTE:earfcn;GSM:arfcn;UMTS:uarfcn
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[7]);//LTE:physicalcellId;GSM:basic;UMTS:psc
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[8]);//bandwidth;GSM:c1
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[9]);//rxlev;GSM:c2
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[10]);//rsrp;GSM:c31
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[11]);//rsrq;GSM:c32
+                if (err < 0) goto error;
+                        
+                rsrp = resp[10];
+                rsrq = resp[11];
+                        
+                rsrp = (140 - rsrp);
+                rsrq = (rsrq / 2 -3);
+switch(resp[1])
+            {
+                //GSM
+                case 1:
+                        RLOGE("GTCCINFO:MCC=%d , MNC=%d , LAC=%d , CID=%d , SCRAM_CODE=%d...",resp[2],resp[3],resp[4],resp[5],resp[6]);
+                        RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d , SCRAM_CODE1=%d...",g_mcc,g_mnc,g_lac,g_cid,resp[6]);
+                        p_cellInfo[i].cellInfoType = RIL_CELL_INFO_TYPE_GSM;
+                        p_cellInfo[i].registered = 1;
+                        p_cellInfo[i].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+                        p_cellInfo[i].timeStamp = 0;
+                        p_cellInfo[i].CellInfo.gsm.cellIdentityGsm.mcc = ((g_mcc!=0xffff)?g_mcc:resp[2]);  //MCC
+                        p_cellInfo[i].CellInfo.gsm.cellIdentityGsm.mnc = ((g_mnc!=0xffff)?g_mnc:resp[3]);  //MNC
+                        p_cellInfo[i].CellInfo.gsm.cellIdentityGsm.lac = ((g_lac!=0xffff)?g_lac:resp[4]);  //LAC
+                        p_cellInfo[i].CellInfo.gsm.cellIdentityGsm.cid = ((g_cid!=0xffff)?g_cid:resp[5]);  //CID
+
+                        if(ANDROID_10 == Ght_Android_Version || ANDROID_7 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+                        {
+                            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                            ((RIL_CellInfo_v12 *)p_cellInfo)[i].CellInfo.gsm.cellIdentityGsm.arfcn = resp[6];    //arfcn
+                            ((RIL_CellInfo_v12 *)p_cellInfo)[i].CellInfo.gsm.cellIdentityGsm.bsic = resp[7];     //basic
+                        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+                        p_cellInfo[i].CellInfo.gsm.cellIdentityGsm.arfcn = resp[6];    //arfcn
+                        p_cellInfo[i].CellInfo.gsm.cellIdentityGsm.bsic = resp[7];     //basic
+#endif
+#endif
+                        p_cellInfo[i].CellInfo.gsm.signalStrengthGsm.signalStrength = sig_strength;
+                        p_cellInfo[i].CellInfo.gsm.signalStrengthGsm.bitErrorRate = ber;
+                        if(ANDROID_10 == Ght_Android_Version || ANDROID_7 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+                        {
+                            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                            ((RIL_CellInfo_v12 *)p_cellInfo)[i].CellInfo.gsm.signalStrengthGsm.timingAdvance = INT_MAX;  //0xffff
+                        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+                        p_cellInfo[i].CellInfo.gsm.signalStrengthGsm.timingAdvance = INT_MAX;  //0xffff
+#endif
+#endif
+                        break;
+                //WCDMA
+                case 2:
+                        RLOGE("GTCCINFO:MCC=%d , MNC=%d , LAC=%d , CID=%d , SCRAM_CODE=%d...",resp[2],resp[3],resp[4],resp[5],resp[6]);
+                        RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d , SCRAM_CODE1=%d...",g_mcc,g_mnc,g_lac,g_cid,resp[6]);
+                        p_cellInfo[i].cellInfoType = RIL_CELL_INFO_TYPE_WCDMA;
+                        p_cellInfo[i].registered = 1;
+                        p_cellInfo[i].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+                        p_cellInfo[i].timeStamp = 0;
+                        p_cellInfo[i].CellInfo.wcdma.cellIdentityWcdma.mcc = ((g_mcc!=0xffff)?g_mcc:resp[2]);  //MCC
+                        p_cellInfo[i].CellInfo.wcdma.cellIdentityWcdma.mnc = ((g_mnc!=0xffff)?g_mnc:resp[3]);  //MNC
+                        p_cellInfo[i].CellInfo.wcdma.cellIdentityWcdma.lac = ((g_lac!=0xffff)?g_lac:resp[4]);  //LAC
+                        p_cellInfo[i].CellInfo.wcdma.cellIdentityWcdma.cid = ((g_cid!=0xffff)?g_cid:resp[5]);  //CID
+                        p_cellInfo[i].CellInfo.wcdma.cellIdentityWcdma.psc = resp[7];
+
+                        if(ANDROID_10 == Ght_Android_Version || ANDROID_7 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+                        {
+                            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                            ((RIL_CellInfo_v12 *)p_cellInfo)[i].CellInfo.wcdma.cellIdentityWcdma.uarfcn = resp[6];
+                        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+                        p_cellInfo[i].CellInfo.wcdma.cellIdentityWcdma.uarfcn = resp[6];
+#endif
+#endif
+                        p_cellInfo[i].CellInfo.wcdma.signalStrengthWcdma.signalStrength = sig_strength;
+                        p_cellInfo[i].CellInfo.wcdma.signalStrengthWcdma.bitErrorRate = ber;
+                        break;
+//#ifndef GHT_FEATURE_ANDROID4X
+                //TDSCDMA
+                case 3:
+                    if(Ght_Android_Version != ANDROID_4)
+                    {
+                        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d != 4 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                        RLOGE("GTCCINFO:MCC=%d , MNC=%d , LAC=%d , CID=%d , SCRAM_CODE=%d...",resp[2],resp[3],resp[4],resp[5],resp[6]);
+                        RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d , SCRAM_CODE1=%d...",g_mcc,g_mnc,g_lac,g_cid,resp[6]);
+                        p_cellInfo[i].cellInfoType = RIL_CELL_INFO_TYPE_TD_SCDMA;
+                        p_cellInfo[i].registered = 1;
+                        p_cellInfo[i].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+                        p_cellInfo[i].timeStamp = 0;
+                        p_cellInfo[i].CellInfo.tdscdma.cellIdentityTdscdma.mcc = ((g_mcc!=0xffff)?g_mcc:resp[2]);  //MCC
+                        p_cellInfo[i].CellInfo.tdscdma.cellIdentityTdscdma.mnc = ((g_mnc!=0xffff)?g_mnc:resp[3]);  //MNC
+                        p_cellInfo[i].CellInfo.tdscdma.cellIdentityTdscdma.lac = ((g_lac!=0xffff)?g_lac:resp[4]);  //LAC
+                        p_cellInfo[i].CellInfo.tdscdma.cellIdentityTdscdma.cid = ((g_cid!=0xffff)?g_cid:resp[5]);  //CID
+                        p_cellInfo[i].CellInfo.tdscdma.signalStrengthTdscdma.rscp = sig_strength;
+                        break;
+                    }
+//#endif
+                    //LTE/NB-IoT/eMTC
+                case 4:
+                case 5:
+                case 6:
+                        RLOGE("GTCCINFO neighbor cell:MCC=%d , MNC=%d , CID=%d ...",resp[2],resp[3],resp[4]);
+//                        RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d ...",g_mcc,g_mnc,g_lac,g_cid);
+                        p_cellInfo[i].cellInfoType = RIL_CELL_INFO_TYPE_LTE;
+                        p_cellInfo[i].registered = 0;
+                        p_cellInfo[i].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+                        p_cellInfo[i].timeStamp = 0;
+                        p_cellInfo[i].CellInfo.lte.cellIdentityLte.mcc = ((g_mcc!=0xffff)?g_mcc:resp[2]);  //MCC
+                        p_cellInfo[i].CellInfo.lte.cellIdentityLte.mnc = ((g_mnc!=0xffff)?g_mnc:resp[3]);  //MNC
+                        p_cellInfo[i].CellInfo.lte.cellIdentityLte.tac = resp[4];  //tac
+                        p_cellInfo[i].CellInfo.lte.cellIdentityLte.ci = ((g_cid!=0xffff)?g_cid:resp[5]);  //CID
+
+                        if(ANDROID_10 == Ght_Android_Version || ANDROID_7 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+                        {
+                            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                            ((RIL_CellInfo_v12 *)p_cellInfo)[i].CellInfo.lte.cellIdentityLte.earfcn = resp[6];  //earfcn
+                        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+                        p_cellInfo[i].CellInfo.lte.cellIdentityLte.earfcn = resp[6];  //earfcn
+#endif
+#endif
+                        p_cellInfo[i].CellInfo.lte.cellIdentityLte.pci = ((g_pci!=0xffff)?g_pci:resp[7]);  //pci
+            
+            
+//                        p_cellInfo[i].CellInfo.lte.signalStrengthLte.signalStrength = sig_strength;
+                        p_cellInfo[i].CellInfo.lte.signalStrengthLte.rsrp = rsrp;    //rsrp
+                        p_cellInfo[i].CellInfo.lte.signalStrengthLte.rsrq = rsrq;    //rsrq
+                        p_cellInfo[i].CellInfo.lte.signalStrengthLte.rssnr = INT_MAX;   //rssnr_value      //INT_MAX or 0?
+                        p_cellInfo[i].CellInfo.lte.signalStrengthLte.cqi=INT_MAX;         //INT_MAX or 0 ?
+                        p_cellInfo[i].CellInfo.lte.signalStrengthLte.timingAdvance = INT_MAX;   //INT_MAX or 0 ?
+
+                        break;
+                    //CDMA,EVDO
+                    case 7:
+                    case 8:
+                        RLOGE("GTCCINFO:MCC=%d , MNC=%d , LAC=%d , CID=%d , SCRAM_CODE=%d...",resp[2],resp[3],resp[4],resp[5],resp[6]);
+                        RLOGE("GTCCINFO from cops cgreg:MCC1=%d , MNC1=%d , LAC1=%d , CID1=%d , SCRAM_CODE1=%d...",g_mcc,g_mnc,g_lac,g_cid,resp[6]);
+                        p_cellInfo[i].cellInfoType = RIL_CELL_INFO_TYPE_CDMA;
+                        p_cellInfo[i].registered = 1;
+                        p_cellInfo[i].timeStampType = RIL_TIMESTAMP_TYPE_JAVA_RIL;
+                        p_cellInfo[i].timeStamp = 0;
+                        p_cellInfo[i].CellInfo.cdma.cellIdentityCdma.networkId = resp[3];
+                        p_cellInfo[i].CellInfo.cdma.cellIdentityCdma.systemId = resp[2];
+                        p_cellInfo[i].CellInfo.cdma.cellIdentityCdma.basestationId = resp[4];
+                        p_cellInfo[i].CellInfo.cdma.cellIdentityCdma.longitude = resp[9];
+                        p_cellInfo[i].CellInfo.cdma.cellIdentityCdma.latitude = resp[10];
+                        if (7 == resp[1])
+                        {
+                            p_cellInfo[i].CellInfo.cdma.signalStrengthCdma.dbm = sig_strength;
+                            p_cellInfo[i].CellInfo.cdma.signalStrengthCdma.ecio = ber;
+                        }
+                        else
+                        {
+                            p_cellInfo[i].CellInfo.cdma.signalStrengthEvdo.dbm = sig_strength;
+                            p_cellInfo[i].CellInfo.cdma.signalStrengthEvdo.ecio = ber;
+                        }
+                        break;
+                    default:
+                        RLOGE("GTCCINFO type not defined..");
+                        break;
+                    }
+                    i++;
+    }
+    if(CurretService != 1)  goto error;
+    }
+
+    RLOGD("Current cell number:%d", i);
+    if(i == CELL_NUM)
+    {
+        RLOGE("Note that RIL can currently only fetch the first %d cells!", CELL_NUM);
+    }
+
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, p_cellInfo, i * cellInfo_len);
+    int k = 0;
+    for(k ; k < i ; k++)
+    {
+        RLOGD("cellInfo[%d]:cellinfoType:%d,registered:%d,timeStampType:%d,timestamp:%d,mcc:%d,mnc:%d,ci:%x,pci:%x,tac:%x,signalStrength:%d,rsrp:%d,rsrq:%d,rssnr:%d,cqi:%x,timeAdvance:%x",k,\
+               p_cellInfo[k].cellInfoType, p_cellInfo[k].registered, p_cellInfo[k].timeStampType, p_cellInfo[k].timeStamp, p_cellInfo[k].CellInfo.lte.cellIdentityLte.mcc, p_cellInfo[k].CellInfo.lte.cellIdentityLte.mnc,\
+               p_cellInfo[k].CellInfo.lte.cellIdentityLte.ci, p_cellInfo[k].CellInfo.lte.cellIdentityLte.pci, p_cellInfo[k].CellInfo.lte.cellIdentityLte.tac, \
+               p_cellInfo[k].CellInfo.lte.signalStrengthLte.signalStrength, p_cellInfo[k].CellInfo.lte.signalStrengthLte.rsrp, p_cellInfo[k].CellInfo.lte.signalStrengthLte.rsrq, p_cellInfo[k].CellInfo.lte.signalStrengthLte.rssnr,\
+               p_cellInfo[k].CellInfo.lte.signalStrengthLte.cqi, p_cellInfo[k].CellInfo.lte.signalStrengthLte.timingAdvance);
+        if(ANDROID_7 == Ght_Android_Version || ANDROID_10 == Ght_Android_Version || ANDROID_11 == Ght_Android_Version)
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d ==7 or == 10 or == 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            RLOGD("cellInfo[%d]: earfcn:%d", k, ((RIL_CellInfo_v12 *)p_cellInfo)[k].CellInfo.lte.cellIdentityLte.earfcn);
+        }
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID10X || defined GHT_FEATURE_ANDROID7X
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, p_cellInfo, i * sizeof(RIL_CellInfo_v12));
+    int k = 0;
+    for(k ; k < i ; k++)
+    {
+        RLOGD("cellInfo[%d]:cellinfoType:%d,registered:%d,timeStampType:%d,timestamp:%d,mcc:%d,mnc:%d,ci:%x,pci:%x,tac:%x,earfcn:%d,signalStrength:%d,rsrp:%d,rsrq:%d,rssnr:%d,cqi:%x,timeAdvance:%x",k,\
+               p_cellInfo[k].cellInfoType,p_cellInfo[k].registered,p_cellInfo[k].timeStampType,p_cellInfo[k].timeStamp,p_cellInfo[k].CellInfo.lte.cellIdentityLte.mcc,p_cellInfo[k].CellInfo.lte.cellIdentityLte.mnc,\
+               p_cellInfo[k].CellInfo.lte.cellIdentityLte.ci,p_cellInfo[k].CellInfo.lte.cellIdentityLte.pci,p_cellInfo[k].CellInfo.lte.cellIdentityLte.tac,p_cellInfo[k].CellInfo.lte.cellIdentityLte.earfcn,\
+               p_cellInfo[k].CellInfo.lte.signalStrengthLte.signalStrength,p_cellInfo[k].CellInfo.lte.signalStrengthLte.rsrp,p_cellInfo[k].CellInfo.lte.signalStrengthLte.rsrq,p_cellInfo[k].CellInfo.lte.signalStrengthLte.rssnr,\
+               p_cellInfo[k].CellInfo.lte.signalStrengthLte.cqi,p_cellInfo[k].CellInfo.lte.signalStrengthLte.timingAdvance);
+
+    }
+#else
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, p_cellInfo, i * sizeof(RIL_CellInfo));
+    RLOGD("CellInfo:cellinfoType:%d,registered:%d,timeStamp:%d",p_cellInfo->cellInfoType,p_cellInfo->registered,p_cellInfo->timeStamp);
+#endif
+#endif
+
+    at_response_free(atResponse);
+//    free(p_cellInfo);
+    RLOGE("requestGetCellInfoList: Done.");
+    return;
+
+error:
+    RLOGE("requestGetCellInfoList, err = %d", err);
+    RLOGE("GTCCINFO:resp[0]=%d, resp[1]=%d, MCC=%d, MNC=%d, LAC=%d, CID=%d, SCRAM_CODE=%d...",resp[0], resp[1], resp[2],resp[3],resp[4],resp[5],resp[6]);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+
+    if (atResponse)
+    {
+        at_response_free(atResponse);
+    }
+    return ;
+
+}
+
+
+void requestSetNetworkSelectionAutomatic(RIL_Token t)
+{
+    int err;
+    ATResponse *p_response = NULL;
+    int mode;
+    char *line = NULL;
+
+    RLOGD("[%s] entered\r\n",__func__);
+
+// <!--added by wangmengying@2017.12.13 for register network failed still need to send cops=0
+    if (g_SetNetworkSelectionManual == 1)
+    {
+        at_send_command_timeout("AT+COPS=0",NULL, TIME_OUT_COPS);
+        g_SetNetworkSelectionManual = 0;
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    }
+// end-->
+
+// <!--added by wangmengying@2017.12.13 for cops=0 need to send only mode == 1
+    err = at_send_command_singleline("AT+COPS?", "+COPS:", &p_response);
+
+    if (err < 0 || p_response->success == 0)
+    {
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0)
+    {
+        goto error;
+    }
+
+    err = at_tok_nextint(&line, &mode);
+    if (err < 0)
+    {
+        goto error;
+    }
+    RLOGD("[%s] mode[%d]\r\n",__func__,mode);
+
+    if(1 == mode)
+// end-->
+    {
+// <!--added by wangmengying@2017.12.13 for  cops=0 need long timeout
+        at_send_command_timeout("AT+COPS=0",NULL, TIME_OUT_COPS);
+// end-->
+    }
+    at_response_free(p_response);
+    //onDeactiveDataCallList();
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    return;
+error:
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    return;
+}
+
+/* added by  nodecom aron begin */
+void requestSetLocationUpdates(void * data, size_t datalen __unused, RIL_Token t)
+{
+    /**
+     * "data" is int *
+     * ((int *)data)[0] is == 1 for updates enabled (+CREG=2)
+     * ((int *)data)[0] is == 0 for updates disabled (+CREG=1)
+     */
+    int err;
+    if( ((int *)data)[0] == 1 )
+    {
+        err = at_send_command("AT+CREG=2",NULL);
+    }
+    else if(((int *)data)[0] == 0)
+    {
+        err = at_send_command("AT+CREG=1",NULL);
+    }
+    else
+    {
+        goto error;
+    }
+    if (err < 0)
+        goto error;
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    return;
+
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    return;
+}
+void requestScreenState(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    /*
+       if ((((int *)data)[0]) == 1)
+       {
+    //Screen on
+    //at_send_command("AT+SIGNALIND=1", NULL);
+    at_send_command("AT+NWTYPEIND=1", NULL);
+    at_send_command("AT+PSDIALIND=1", NULL);
+    }
+    else
+    {
+    //Screen off
+    //at_send_command("AT+SIGNALIND=0", NULL);
+    at_send_command("AT+NWTYPEIND=0", NULL);
+    at_send_command("AT+PSDIALIND=0", NULL);
+    }
+    */
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+/* added by  nodecom aron end */
+
+
+/*add by fibo replace syscall call for ndis dial 20181208*/
+int fibo_bring_up_interface_do_dhcp(const char * iname)
+{
+    int retry = DHCP_MAX_RETRY_NUM;
+    int ret = 0;
+
+    do
+    {
+        RLOGD("%s init", __FUNCTION__);
+        ifc_init();
+        ifc_up(iname);
+        ret = do_dhcp(iname);
+        ifc_close();
+        RLOGD("%s ret = %d, retry = %d", __FUNCTION__, ret, retry);
+    }while (ret && retry--);
+
+    if(ret == -1 && retry == 0)
+    {
+        RLOGE("We tried %d times, but did not get DHCP information!", DHCP_MAX_RETRY_NUM);
+        return RET_FAIL;
+    }
+
+    return RET_SUCCESS;
+}
+
+int fibo_get_ip(const char *interface, char *ip)
+{
+#define ETH_ALEN 6
+    //ENTER_FUNC;
+    int sock, err, i;
+    char hwaddr[ETH_ALEN] = {0};
+    struct sockaddr_in sin;
+    struct ifreq ifr;
+    if(interface == NULL || strlen(interface) == 0
+    || ip == NULL ){
+        RLOGD("fibo %s \r\n","please input interface");
+    return -1;
+    }
+    sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if (sock == -1)
+    {
+        RLOGD("fibo %s\r\n","socket");
+        return -1;
+    }
+    strncpy(ifr.ifr_name,interface,IFNAMSIZ);
+    ifr.ifr_name[IFNAMSIZ - 1] = 0;
+
+    err = ioctl(sock, SIOCGIFADDR, &ifr);
+    if (err < 0)
+    {
+        RLOGD("fibo getip ioctl failure! err:%d, %s", err, strerror(err));
+        strncpy(ip,DEFAULTIP,sizeof(DEFAULTIP));
+        close(sock);
+        return -1;
+    }
+
+    memcpy(&sin, &ifr.ifr_addr, sizeof(sin));
+    strncpy(ip,inet_ntoa(sin.sin_addr),strlen(inet_ntoa(sin.sin_addr)));
+    RLOGD( "fibo get ip %s, if_name:%s, strlen(ifr.ifr_name):%d", inet_ntoa(sin.sin_addr), ifr.ifr_name == NULL?"NULL":ifr.ifr_name, strlen(ifr.ifr_name));
+
+    if (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0) {
+        RLOGD("%s: get hwaddr error!", __FUNCTION__);
+        return -1;
+    }
+    memcpy(hwaddr, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
+
+    for(i = 0 ; i < ETH_ALEN; i++)
+    {
+        RLOGD("%s: get hwaddr[%d]:%02x", __FUNCTION__, i, hwaddr[i]);
+    }
+
+    close(sock);
+    return 0;
+}
+/*add end by fibo 20181208*/
+void *ndis_main_loop()
+{
+    int ret = 0;
+    for(;;)
+    {
+        if(ret  == 0) //
+        {
+            pthread_mutex_lock(&s_ndismutex);
+            ret = pthread_cond_wait(&s_ndiscond, &s_ndismutex);
+            pthread_mutex_unlock(&s_ndismutex);
+        }
+       
+        ret =  fibo_bring_up_interface_do_dhcp("usb0");  
+
+        sleep(1);
+    }
+    return ((void *)0);
+}
+
+/*Begin: Deleted by wujiabao in 2022/07/20, because we did not need it*/
+#if 0
+static int getPreferredNetworkTypeM910()
+{
+    int err=0;
+    int mode = 2;
+    char *line;
+    ATResponse *p_response = NULL;
+
+    if(mode_flag == GHT_757S)
+    {
+       err = at_send_command_singleline("AT+MODODR?", "+MODODR:", &p_response); 
+    }
+    else
+    {
+        err = at_send_command_singleline("AT+GTRAT?", "+GTRAT:", &p_response);
+    }
+    if (err < 0|| p_response->success == 0)
+      goto done;
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0)
+      goto done;
+
+    err = at_tok_nextint(&line, &mode);
+    if (err < 0)
+      goto done;
+done:
+    at_response_free(p_response);
+    return mode;
+}
+/*
+*  return   0 GSM Network;
+*           1 NB Network
+*/
+static int isNBPreferredNetwork(void)
+{
+    int ret = 0;
+    int err = 0;
+    ATResponse *p_response = NULL;
+    int response = 0;
+    char *line;
+    char *presponse =NULL;
+
+    isNBCard = 0;
+    sleep(3);
+    err = at_send_command_singleline("AT+COPS?", "+COPS:", &p_response);
+    if (err < 0 || p_response->success == 0)
+    {
+        goto error;
+    }
+    line = p_response->p_intermediates->line;
+    err = at_tok_start(&line);
+    if (err < 0)goto error;
+    RLOGD("isNBPreferredNetwork line :[%s]",line);
+    err = at_tok_nextint(&line, &response);
+    if (err < 0)goto error;
+    RLOGD("isNBPreferredNetwork line1 :[%s] response :[%d]",line,response);
+    err = at_tok_nextint(&line, &response);
+    if (err < 0)goto error;
+    RLOGD("isNBPreferredNetwork line2 :[%s] response :[%d]",line,response);
+    err = at_tok_nextstr(&line, &(presponse));
+    if (err < 0) goto error;
+    RLOGD("isNBPreferredNetwork line3 :[%s] presponse :[%s]",line,presponse);
+    err = at_tok_nextint(&line, &response);
+    if (err < 0) goto error;
+    RLOGD("isNBPreferredNetwork line4 :[%s] response :[%d]",line,response);
+    
+    ret = 1;
+    isNBCard = 1;
+    at_response_free(p_response);
+    return ret;
+error:
+    at_response_free(p_response);
+    return ret;
+}
+
+static int trySet4GNBPreferred(void)
+{
+    int ret = 1;
+    int err = 0;
+    ATResponse *p_response = NULL;
+
+    err = at_send_command("AT+GTRAT=9",&p_response);
+    if (err < 0 || p_response->success == 0){
+        ret = 0;
+    }
+    RLOGD("networkTrySet4GNBPreferred err[%d] p_response :[%d]",err,p_response->success);
+    return ret;
+}
+
+void requestSetPreferredNetworkType_M910(void *data, size_t datalen __unused, RIL_Token t)
+{
+    int err = 0;
+    int tryNBPreferredSet=0;
+    int isNBNetwork= 0;
+    ATResponse *p_response = NULL;
+    int setmode = 0,mode = 0;
+    char *cmd = NULL;
+    setmode = ((int *)data)[0];
+
+    if(mode_flag == GHT_757S)
+    {
+        switch(setmode)
+        {
+           /* BEGIN: Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+               case 22:  /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo */
+               case 12:    /* LTE/WCDMA */
+           /* END:   Added by eric.li, 2018/10/17   PN:add support for android7 to handle prefered network */
+               case 10:    /* LTE, CDMA, EvDo, GSM/WCDMA */
+               case 8:     /* LTE, CDMA and EvDo */
+               case 9:     /* LTE, GSM/WCDMA */
+                   mode = 2;
+                   break;
+               case 6:     /* EvDo only */
+               case 2:     /* WCDMA  */
+               case 0:     /* GSM/WCDMA (WCDMA preferred) */
+               case 3:     /* GSM/WCDMA (auto mode, according to PRL) */
+               case 4:     /* CDMA and EvDo (auto mode, according to PRL) */
+               case 7:     /* GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL) */
+                   {
+                       if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                       {
+                           mode = 9;
+                       }
+                       else if(ODM_CM_OPERATOR == cur_oper)
+                       {
+                           mode = 6;
+                       }
+                       else if(ODM_CU_OPERATOR == cur_oper)
+                       {
+                           mode = 1;
+                       }
+                   }
+                   break;
+               case 1:    /* GSM only */
+               case 5:    /* CDMA only */
+                   {
+                       if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                       {
+                           mode = 8;
+                       }
+                       else if(ODM_CM_OPERATOR == cur_oper)
+                       {
+                           mode = 3;
+                       }
+                       else if(ODM_CU_OPERATOR == cur_oper)
+                       {
+                           mode = 3;
+                       }
+                       else
+                       {
+                           mode =2;
+                       }
+                   }
+                   break;
+               case 11:    /* LTE only */
+                   mode = 5;
+                   break;
+
+               default:
+                   mode = 2;
+                   break;
+       }
+    }
+    else if(mode_flag == GHT_M910_GL)
+    {
+        switch(setmode)
+        {
+            case 10:    /* LTE, CDMA, EvDo, GSM/WCDMA */
+            case 8:     /* LTE, CDMA and EvDo */
+                mode = 10;
+                break;
+            case 9:     /* LTE, GSM/WCDMA */
+                /*fix me how to different NB card from usim card*/
+                tryNBPreferredSet = trySet4GNBPreferred();
+                isNBNetwork = isNBPreferredNetwork();
+                if(tryNBPreferredSet && isNBNetwork){
+                        mode = 9;
+                }
+                else{
+                    if((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper)){
+                        mode = 3;
+                    }
+                    else{
+                        mode = 0;
+                    }
+                }
+                break;
+            case 6:     /* EvDo only */
+                mode = 13;
+                break;
+            case 2:     /* WCDMA  */
+                mode = 2;
+                break;
+            case 0:     /* GSM/WCDMA (WCDMA preferred) */
+            case 3:     /* GSM/WCDMA (auto mode, according to PRL) */
+                if((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                {
+                    mode = 3;
+                }
+                else
+                {
+                    mode = 0;
+                }
+                break;
+            case 4:     /* CDMA and EvDo (auto mode, according to PRL) */
+                mode = 12;
+                break;
+            case 7:     /* GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL) */
+                {
+                    if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                    {
+                        mode = 13;
+                    }
+                    else if(ODM_CM_OPERATOR == cur_oper)
+                    {
+                        mode = 7;
+                    }
+                    else if(ODM_CU_OPERATOR == cur_oper)
+                    {
+                        mode = 2;
+                    }
+                }
+                break;
+            case 1:    /* GSM only */
+                mode = 0;
+                break;
+            case 5:    /* CDMA only */
+                mode = 11;
+                break;
+            case 11:    /* LTE only */
+                mode = 3;
+                break;
+            default:
+                mode = 10;
+                break;
+        }
+    }
+    // <!--[ODM]wangmengying@2019.10.31 bug33035,switch RAT
+    else
+    {
+        switch(setmode)
+        {
+            case 10:    /* LTE, CDMA, EvDo, GSM/WCDMA */
+            case 8:     /* LTE, CDMA and EvDo */
+            case 9:     /* LTE, GSM/WCDMA */
+                mode = 10;
+                break;
+            case 0:     /* GSM/WCDMA (WCDMA preferred) */
+            case 3:     /* GSM/WCDMA (auto mode, according to PRL) */
+            case 1:    /* GSM only */
+            case 7:     /* GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL) */
+                mode = 0;
+                break;
+            case 11:    /* LTE only */
+                mode = 3;
+                break;
+            default:
+                mode = 10;
+                break;
+        }
+    }
+    // end-->
+    if(mode != getPreferredNetworkTypeM910())
+    {
+        RLOGD("requestSetPreferredNetworkType setmode=%d, mode=%d",setmode, mode);
+        // <!--[ODM]wangmengying@2019.10.31 bug29134,2G switch 4G, need to disconnect ppp first
+        if (GHT_MA510_GL == mode_flag)
+        {
+            onDeactiveDataCallList();
+        }
+        // end-->
+
+        if(mode_flag == GHT_757S)
+        {
+            asprintf(&cmd,"AT+MODODR=%d",mode);
+        }
+        else
+        {
+            asprintf(&cmd,"AT+GTRAT=%d",mode);
+        }
+        err = at_send_command(cmd,&p_response);
+        free(cmd);
+        onDeactiveDataCallList();
+        if (err < 0 || p_response->success == 0)
+        {
+            goto error;
+        }
+    }
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, sizeof(int));
+    at_response_free(p_response);
+    return;
+error:
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+
+}
+
+void requestGetPreferredNetworkTypeM910(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    ATResponse *p_response = NULL;
+    int response = 0;
+    int responsenet=0;
+    char *line;
+
+    if(mode_flag == GHT_757S)
+    {
+        err = at_send_command_singleline("AT+MODODR?", "+MODODR:", &p_response);
+    }
+    else
+    {
+        err = at_send_command_singleline("AT+GTRAT?", "+GTRAT:", &p_response); 
+    }
+   
+    if (err < 0 || p_response->success == 0)
+    {
+        goto error;
+    }
+    line = p_response->p_intermediates->line;
+    err = at_tok_start(&line);
+    if (err < 0)
+    {
+        goto error;
+    }
+    err = at_tok_nextint(&line, &responsenet);
+    if (err < 0)
+    {
+        goto error;
+    }
+    switch(responsenet)
+    {
+        case 0:        /*GSM*/
+            response = PREF_NET_TYPE_GSM_ONLY;
+            break;
+        case 1:        /*GSM/UMTS*/
+            response = PREF_NET_TYPE_GSM_WCDMA;
+            break;
+        case 2:        /*UMTS*/
+            response = PREF_NET_TYPE_WCDMA;
+            break; 
+        case 3:        /*LTE*/
+            response = PREF_NET_TYPE_LTE_ONLY;
+            break;
+        case 4:        /*LTE/UMTS*/
+            response = PREF_NET_TYPE_LTE_WCDMA;
+            break;
+        case 5:        /*LTE/GSM*/
+            response = PREF_NET_TYPE_LTE_GSM_WCDMA;
+            break;
+        case 6:        /*LTE/UMTS/GSM*/
+            response = PREF_NET_TYPE_LTE_GSM_WCDMA;
+            break;
+        case 7:        /*TD-SCDMA*/
+            response = PREF_NET_TYPE_WCDMA;
+            break;
+        case 8:        /*eMTC*/
+        case 9:        /*NB-IoT*/ 
+            response = PREF_NET_TYPE_LTE_ONLY;
+            break;
+        case 10:       /*Automatic*/
+            response = PREF_NET_TYPE_LTE_CMDA_EVDO_GSM_WCDMA;
+            break;
+        case 11:       /*CDMA*/
+            response = PREF_NET_TYPE_CDMA_ONLY;
+            break;
+        case 12:       /*CDMA/EVDO*/
+            response = PREF_NET_TYPE_CDMA_EVDO_AUTO;
+            break;
+        case 13:       /*EVDO*/
+            response = PREF_NET_TYPE_EVDO_ONLY;
+            break;
+        default:
+            goto error;
+            break;
+    }
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(int));
+    at_response_free(p_response);
+    return;
+error:
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+
+}
+
+void requestRegistrationStateM910(int request, void *data __unused,size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    int *registration = NULL;
+    char **responseStr = NULL;
+    ATResponse *p_response = NULL;
+    const char *cmd;
+    const char *prefix;
+    char *line;
+    int j, numElements = 0;
+    int count = 3;
+    int type = 0;
+    int startfrom;
+
+    if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE) {
+        if ((g_cops_lte == 7)||(g_cops_lte == 12)||(g_cops_lte == 11))
+        {
+            cmd = "AT+CEREG?";
+            prefix = "+CEREG:";
+        }
+        //add by zhengjianrong for MA510 Ril begin
+        else if((g_cops_lte == 9) && (mode_flag == GHT_MA510_GL))
+        {
+            cmd = "AT+CEREG?";
+            prefix = "+CEREG:";
+        }
+        //add by zhengjianrong for MA510 Ril end
+        else if((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+        {
+            cmd = "AT+CGREG?";
+            prefix = "+CGREG:";
+        }
+        else
+        {
+            cmd = "AT+CREG?";
+            prefix = "+CREG:";
+        }
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        numElements = 15;
+#else
+        numElements = 4;
+#endif
+    } 
+    else if (request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+        if ((g_cops_lte == 7)||(g_cops_lte == 12)||(g_cops_lte == 11))
+        {
+            cmd = "AT+CEREG?";
+            prefix = "+CEREG:";
+        }
+        //add by zhengjianrong for MA510 Ril begin
+        else if((g_cops_lte == 9) && (mode_flag == GHT_MA510_GL))
+        {
+            cmd = "AT+CEREG?";
+            prefix = "+CEREG:";
+        }
+        //add by zhengjianrong for MA510 Ril end
+        else
+        {
+            if (mode_flag == GHT_MA510_GL)
+            {
+                cmd = "AT+CREG?";
+                prefix = "+CREG:";
+            }
+            else
+            {
+                cmd = "AT+CGREG?";
+                prefix = "+CGREG:";
+            }
+        }
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        numElements = 6;
+#else
+        numElements = 4;
+#endif
+    } else {
+        assert(0);
+        goto error;
+    }
+
+    err = at_send_command_singleline(cmd, prefix, &p_response);
+
+    if ((err != 0) || (p_response->success == 0) ) goto error;
+
+    line = p_response->p_intermediates->line;
+
+    if (parseRegistrationState(line, &type, &count, &registration)) goto error;
+
+    responseStr = malloc(numElements * sizeof(char *));
+    if (!responseStr) goto error;
+    memset(responseStr, 0, numElements * sizeof(char *));
+    /**
+     * The first '4' bytes for both registration states remain the same.
+     * But if the request is 'DATA_REGISTRATION_STATE',
+     * the 5th and 6th byte(s) are optional.
+     */
+    startfrom = 0;
+    asprintf(&responseStr[1], "%x", registration[1]);
+    asprintf(&responseStr[2], "%x", registration[2]);
+    if (count > 3) {
+        switch(registration[3])
+        {
+             /* AT response */
+             // 0 GSM 
+             // 2 UTRAN 
+             // 3 GSM w/EGPRS 
+             // 4 UTRAN w/HSDPA 
+             // 5 UTRAN w/HSUPA 
+             // 6 UTRAN w/HSDPA and HSUPA 
+             case 0:
+                 registration[3] = RADIO_TECH_GPRS;
+                 break;
+             case 1:
+                 registration[3] = RADIO_TECH_GPRS;
+                 break;
+             case 2:
+                 registration[3] = RADIO_TECH_UMTS;
+                 break;
+             case 3:
+                 registration[3] = RADIO_TECH_EDGE;
+                 break;
+             case 4:
+                 registration[3] = RADIO_TECH_HSDPA;
+                 break;
+             case 5:
+                 registration[3] = RADIO_TECH_HSUPA;
+                 break;
+             case 6:
+                 registration[3] = RADIO_TECH_HSPA;
+                 break;
+             case 7:
+             case 9:
+             case 12:
+             // <!--added by wangmengying@2018.8.28 for add EMTC networktype
+             case 11:
+             // end--!>
+                 registration[3] = RADIO_TECH_LTE;
+
+                 break;
+             case 8:
+                 registration[3] = RADIO_TECH_HSPAP;
+             default:
+                 registration[3] = RADIO_TECH_UNKNOWN;
+                 break;
+        }
+       asprintf(&responseStr[3], "%d", registration[3]);
+       RLOGD("registration[3] == %d\r\n",registration[3]);
+    }
+    if (request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+    {
+        if (registration[0] == 6)
+        {
+            registration[0] = 1;
+            RLOGD("registration[0] ==  %d \r\n",registration[0] );
+        }
+    }
+    asprintf(&responseStr[0], "%d", registration[0]);
+    RLOGD("registration[0] == %d\r\n",registration[0]);
+    free(registration);
+    registration = NULL;
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    if(request == RIL_REQUEST_DATA_REGISTRATION_STATE) {
+        asprintf(&responseStr[4],"%d", 0);
+        asprintf(&responseStr[5],"%d",1);
+    }
+    else if(request == RIL_REQUEST_VOICE_REGISTRATION_STATE)
+    {
+         for(j = 4 ; j < numElements;j++)
+         {
+            asprintf(&responseStr[j],"%d", 0);
+         }
+    }
+#else
+    for (j = startfrom; j < numElements; j++)
+    {
+        if (!responseStr[j])
+        {
+            //RLOGD("[%s,%d],j[%d]\r",__FUNCTION__, __LINE__, j);
+            //goto error;
+            asprintf(&responseStr[j],"%d", 0);
+        }
+    }
+#endif
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, responseStr, numElements*sizeof(responseStr));
+    for (j = 0; j < numElements; j++ ) {
+        free(responseStr[j]);
+        responseStr[j] = NULL;
+    }
+    free(responseStr);
+    responseStr = NULL;
+    at_response_free(p_response);
+    return;
+
+error:
+    if (responseStr) {
+        for (j = 0; j < numElements; j++) {
+            free(responseStr[j]);
+            responseStr[j] = NULL;
+        }
+        free(responseStr);
+        responseStr = NULL;
+    }
+    RLOGD("RequestRegistrationState must never return an error when radio is on");
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+
+}
+
+static int parseRegistrationStateM910(char *str, int *type __unused, int *items, int **response)
+{
+    int err;
+    char *line = str, *p;
+    int *resp = NULL;
+    int skip;
+    int count = 3;
+    int commas;
+
+    RLOGD("parseRegistrationState. Parsing: %s",str);
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    /* Ok you have to be careful here
+     * The solicited version of the CREG response is
+     * +CREG: n, stat, [lac, cid]
+     * and the unsolicited version is
+     * +CREG: stat, [lac, cid]
+     * The <n> parameter is basically "is unsolicited creg on?"
+     * which it should always be
+     *
+     * Now we should normally get the solicited version here,
+     * but the unsolicited version could have snuck in
+     * so we have to handle both
+     *
+     * Also since the LAC and CID are only reported when registered,
+     * we can have 1, 2, 3, or 4 arguments here
+     *
+     * finally, a +CGREG: answer may have a fifth value that corresponds
+     * to the network type, as in;
+     *
+     *   +CGREG: n, stat [,lac, cid [,networkType]]
+     */
+    /* count number of commas */
+    commas = 0;
+    for (p = line ; *p != '\0' ;p++) {
+        if (*p == ',') commas++;
+    }
+    RLOGD("parseRegistrationState. commas: %d",commas);
+    resp = (int *)calloc(commas + 1, sizeof(int));
+    if (!resp) goto error;
+    switch (commas) {
+        case 0: /* +CREG: <stat> */
+            err = at_tok_nextint(&line, &resp[0]);
+            if (err < 0) goto error;
+            resp[1] = -1;
+            resp[2] = -1;
+            break;
+            
+            case 1: /* +CREG: <n>, <stat> */
+                err = at_tok_nextint(&line, &skip);
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[0]);
+                if (err < 0) goto error;
+                resp[1] = -1;
+                resp[2] = -1;
+                if (err < 0) goto error;
+                break;
+                
+            case 2: /* +CREG: <stat>, <lac>, <cid> */
+                err = at_tok_nextint(&line, &resp[0]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[1]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[2]);
+                if (err < 0) goto error;
+                break;
+            case 3: /* +CREG: <n>, <stat>, <lac>, <cid> */
+                err = at_tok_nextint(&line, &skip);
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[0]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[1]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[2]);
+                if (err < 0) goto error;
+                break;
+            /* special case for CGREG, there is a fourth parameter
+             * that is the network type (unknown/gprs/edge/umts)
+             */
+            case 4: /* +CGREG: <n>, <stat>, <lac>, <cid>, <networkType> */
+            //case 5: /* +CGREG: <n>, <stat>, <lac>, <cid>, <networkType> */
+                err = at_tok_nextint(&line, &skip);
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[0]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[1]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[2]);
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[3]);
+                if (err < 0) goto error;
+                count = 4;
+                break;
+            case 5: /* +CEREG: <n>, <stat>, <lac>, <mmd>, <cid>, <networkType> */
+                err = at_tok_nextint(&line, &skip);
+                if (err < 0) goto error;
+                err = at_tok_nextint(&line, &resp[0]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[1]);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &skip);
+                if (err < 0) goto error;
+                err = at_tok_nexthexint(&line, &resp[2]);
+                if (err < 0) goto error;
+//#ifdef GHT_FEATURE_ANDROID8X
+                err = at_tok_nexthexint(&line, &resp[3]);
+                if (err < 0) goto error;
+//#else
+//                err = at_tok_nextint(&line, &resp[3]);
+//                if (err < 0) goto error;
+//#endif
+                count = 4;
+                
+                RLOGD("resp[] == %d, %d, %d, %d",resp[0], resp[1], resp[2], resp[3]);
+                break;
+            default:
+                goto error;
+            }
+    if (response)
+        *response = resp;
+    if (items)
+        *items = commas + 1;
+    return 0;
+error:
+    free(resp);
+    return -1;
+}
+
+int odm_get_current_network_type_m910()
+{
+    int err;
+    int response = 0;
+    const char *cmd;
+    const char *prefix;
+    char *line;
+    int *registration = NULL;
+    int count = 0;
+    int type = 0;
+    ATResponse *p_response = NULL;
+
+// <!--added by wangmengying@2018.8.28 for add EMTC networktype
+    if ((g_cops_lte == 7)||(g_cops_lte == 12)||(g_cops_lte == 11))
+// end--!>
+    {
+        cmd = "AT+CEREG?";
+        prefix = "+CEREG:";
+    }
+    //add by zhengjianrong for MA510 Ril begin
+    else if((g_cops_lte == 9) && (mode_flag == GHT_MA510_GL))
+    {
+        cmd = "AT+CEREG?";
+        prefix = "+CEREG:";
+    }
+    //add by zhengjianrong for MA510 Ril end
+    else
+    {
+        if (mode_flag == GHT_MA510_GL)
+        {
+            cmd = "AT+CREG?";
+            prefix = "+CREG:";
+        }
+        else
+        {
+            cmd = "AT+CGREG?";
+            prefix = "+CGREG:";
+        }
+    }
+    err = at_send_command_singleline(cmd, prefix, &p_response);
+
+    if ((err != 0) || (p_response->success == 0) ) goto error;
+
+    line = p_response->p_intermediates->line;
+
+    if (parseRegistrationStateM910(line, &type, &count, &registration)) goto error;
+
+    if (NULL == registration)
+    {
+        goto error;
+    }
+
+    if(count > 3){
+        switch(registration[3])
+        {
+             /* AT response */
+             // 0 GSM 
+             // 2 UTRAN 
+             // 3 GSM w/EGPRS 
+             // 4 UTRAN w/HSDPA 
+             // 5 UTRAN w/HSUPA 
+             // 6 UTRAN w/HSDPA and HSUPA 
+             case 0:
+                 response = RADIO_TECH_GPRS;
+                 break;
+             case 1:
+                 response = RADIO_TECH_GPRS;
+                 break;
+             case 2:
+                 response = RADIO_TECH_UMTS;
+                 break;
+             case 3:
+                 response = RADIO_TECH_EDGE;
+                 break;
+             case 4:
+                 response = RADIO_TECH_HSDPA;
+                 break;
+             case 5:
+                 response = RADIO_TECH_HSUPA;
+                 break;
+             case 6:
+                 response = RADIO_TECH_HSPA;
+                 break;
+             case 7:
+             case 9:
+             case 12:
+             // <!--added by wangmengying@2018.8.28 for add EMTC networktype
+             case 11:
+             // end--!>
+                 response = RADIO_TECH_LTE;
+
+                 break;
+             case 8:
+                 response = RADIO_TECH_HSPAP;
+             default:
+                 response = RADIO_TECH_UNKNOWN;
+                 break;
+        }
+    }
+    free(registration);
+    registration = NULL;
+    at_response_free(p_response);
+    
+    RLOGD("network type %d",response);
+    return response;
+
+error:
+    at_response_free(p_response);
+    return 0;
+}
+
+//<!--added by wangmengying@2019.11.26 for fix bug34926 MA510 query network registration status
+int odm_get_current_network_type_ma510()
+{
+    int err;
+    int response = 0;
+    char *line;
+    int registration[4] = {0};
+    ATResponse *p_response = NULL;
+
+    err = at_send_command_singleline("AT+COPS?", "+COPS:", &p_response);
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &registration[0]);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &registration[1]);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &registration[2]);
+        if (err < 0) goto error;
+        err = at_tok_nextint(&line, &registration[3]);
+
+        switch(registration[3])
+        {
+             /* AT response */
+             // 0 GSM
+             // 2 UTRAN
+             // 3 GSM w/EGPRS
+             // 4 UTRAN w/HSDPA
+             // 5 UTRAN w/HSUPA
+             // 6 UTRAN w/HSDPA and HSUPA
+             case 0:
+                 response = RADIO_TECH_GPRS;
+                 break;
+             case 1:
+                 response = RADIO_TECH_GPRS;
+                 break;
+             case 2:
+                 response = RADIO_TECH_UMTS;
+                 break;
+             case 3:
+                 response = RADIO_TECH_EDGE;
+                 break;
+             case 4:
+                 response = RADIO_TECH_HSDPA;
+                 break;
+             case 5:
+                 response = RADIO_TECH_HSUPA;
+                 break;
+             case 6:
+                 response = RADIO_TECH_HSPA;
+                 break;
+             case 7:
+             case 9:
+                 response = RADIO_TECH_LTE;
+                 break;
+             default:
+                 response = RADIO_TECH_UNKNOWN;
+                 break;
+        }
+    }
+    at_response_free(p_response);
+
+    RLOGD("network type %d",response);
+    return response;
+
+error:
+    at_response_free(p_response);
+    return 0;
+}
+//end--!>
+
+static int setupDataCallRASModeM910(char**response_local_ip,const char* apn,const char* auth_type,const char* username,const  char* password,const char* pdp_type)
+{
+#define SUCCESS 0
+#define ERROR 1
+#define PPP_ERROR 2
+    int fd;
+    char buffer[20];
+    char exit_code[PROPERTY_VALUE_MAX]={0};
+    static char local_ip[PROPERTY_VALUE_MAX]={0};
+    static char local_pdns[PROPERTY_VALUE_MAX]={0};
+    static char local_sdns[PROPERTY_VALUE_MAX]={0};
+    int retry = POLL_PPP_SYSFS_RETRY;
+    char apntype[PROPERTY_VALUE_MAX];
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char*cmd;
+    int network_type = 0;
+    char datachannel[PROPERTY_VALUE_MAX]={0};
+
+    property_get("ril.datachannel",datachannel,"");
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    ril_kill_pppd(0);      
+#else    
+    RLOGD("******** Enter setupDataCallRASMode ********");
+//<!--added by wangmengying@2018.8.22 for avoid ppp dial
+    asprintf(&cmd, "busybox pkill /system/bin/pppd");
+    RLOGD("setupDataCallRASMode :%s",cmd);
+    system(cmd);
+    free(cmd);
+// end--!>
+#endif
+    err = at_send_command("ATH", NULL);
+    property_set("ctl.stop", SERVICE_PPPD_GPRS);
+    //sleep(3);
+
+    if(isNBCard){
+        RLOGD("do nothing NB Card do not need apn settins");
+        asprintf(&cmd, "AT+CGDCONT=%d,\"ip\"", cus_cid);
+        err = at_send_command(cmd, NULL);
+        free(cmd);
+    }
+    else{
+        asprintf(&cmd, "AT+CGDCONT=%d,\"%s\",\"%s\",,0,0", cus_cid, pdp_type, apn);
+        err = at_send_command(cmd, NULL);
+        free(cmd);
+    }
+ 
+    if (ODM_CT_OPERATOR_3G == cur_oper)
+    {
+
+        asprintf(&cmd, "AT^PPPCFG=\"%s\",\"%s\"", username, password);
+        err = at_send_command(cmd, NULL);
+        free(cmd);
+    }
+    if((username != NULL ) && ( password != NULL))
+    {
+        if((username != NULL) && (password != NULL))
+        {
+            asprintf(&cmd, "AT$QCPDPP=1,%s,\"%s\",\"%s\"", auth_type, password, username);
+            err = at_send_command(cmd, NULL);
+            free(cmd);
+        }
+        property_set("net.ppp0.user", username);
+        property_set("net.ppp0.password", password);
+    }
+    // Start data on PDP context 1
+    //err = at_send_command("ATD*99***1#", &p_response);
+    RLOGD("@@setupDataCallRASMode DATA CALL DEBUG1 script_type %d",script_type);
+    // Setup PPP connection after PDP Context activated successfully
+    // The ppp service name is specified in /init.rc
+    property_set(PROPERTY_PPPD_EXIT_CODE, "");
+    if(0 == script_type)
+    {
+        do {
+            if(ppp_fd > 0)
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+            //ppp_fd = open(datachannel, O_RDWR);
+            ppp_fd = open(datachannel, O_RDWR | O_NONBLOCK | O_NOCTTY);
+            RLOGD("setupDataCallRASMode: ppp_fd=%d errno:[%d]", ppp_fd,errno);
+            if (ppp_fd > 0)
+            {
+                struct termios ios;
+                tcgetattr(ppp_fd, &ios);
+                ios.c_lflag = 0;
+                ios.c_oflag &= (~ONLCR);
+                ios.c_iflag &= (~(ICRNL | INLCR));
+                ios.c_iflag |= (IGNCR | IXOFF);
+                ios.c_cc[VTIME] = 10;
+                ios.c_cc[VMIN] = 0;
+                tcsetattr(ppp_fd, TCSANOW, &ios);
+                tcflush(ppp_fd, TCIOFLUSH);
+
+                if (GHT_MA510_GL == mode_flag)
+                {
+                    network_type = odm_get_current_network_type_ma510();
+                }
+                else
+                {
+                    network_type = odm_get_current_network_type_m910();
+                }
+                if(!network_type)
+                {
+                    RLOGD("No service,can not setup data call");
+                    if(ppp_fd > 0)
+                    {
+                        close(ppp_fd);
+                        ppp_fd = -1;
+                    }
+                    goto error;
+                }
+                else if(6 == network_type||7 == network_type || 13 == network_type)
+                {
+                    err = at_send_command_dial(ppp_fd, "ATD#777");
+                }
+                else
+                {
+                    err = at_send_command_dial(ppp_fd, "ATD*99#");
+                    err = dial_at_modem(ppp_fd);
+                }
+                if (err < 0 || err == 1)
+                {
+                    RLOGD("send dial command failed!");
+                    close(ppp_fd);
+                    sleep(1);
+                    continue;
+                }
+                break;
+            }
+            else
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+                RLOGD("retry %d after %d seconds", retry, POLL_PPP_SYSFS_SECONDS);
+                sleep(POLL_PPP_SYSFS_SECONDS);
+            }
+        }while(--retry);
+
+        if ((ppp_fd < 0) && (retry == 0))
+        {
+            close(ppp_fd);
+            ppp_fd = -1;
+            RLOGD("open ppp_fd fail!");
+            goto error;
+        }
+        if(!network_type)
+        {
+            RLOGD("No service,can not setup data call");
+            if(ppp_fd > 0)
+            {
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+            goto error;
+        }
+        else if(6 == network_type||7 == network_type || 13 == network_type)
+        {
+            sleep(1);
+            if (0 == strcmp(auth_type,"1"))
+            {
+                asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts user %s password %s usepeerdns debug ipcp-accept-local ipcp-accept-remote defaultroute -chap",datachannel,username,password);
+            }
+            else
+            {
+                asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts user %s password %s usepeerdns debug ipcp-accept-local ipcp-accept-remote defaultroute",datachannel,username,password);
+            }
+        }
+        else
+        {
+            sleep(1);
+            if((username != NULL) && (password != NULL))
+            {
+              asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts user %s password %s usepeerdns debug ipcp-accept-local ipcp-accept-remote defaultroute",datachannel,username,password);
+            }
+            else
+            {
+              asprintf(&cmd, "/system/bin/pppd %s 115200 nocrtscts usepeerdns debug ipcp-accept-local ipcp-accept-remote defaultroute",datachannel);
+            }
+        }
+        RLOGD("%s",cmd);
+        system(cmd);
+        free(cmd);
+        gPid_pppd_live = get_pid("pppd");
+        if (gPid_pppd_died  == gPid_pppd_live){
+            RLOGD("!!!!!!!!!!!pppd call failed as kill pppd failed, gPid_pppd_died[%d]", gPid_pppd_died);
+        }
+        else{
+            RLOGD(" gPid_pppd_died[%d], gPid_pppd_live[%d]", gPid_pppd_died, gPid_pppd_live);
+        }
+    }
+    
+    // <!--modified by wangyi@2018.07.14 for optimizing RIL function modules
+    // set 'pppd' flag here, ppp main loop will detect PPP OperState in parallel with Dial procedure, it risk and no point.
+    // move the setting after retrieving IP address seems better.
+    //pppd = 1;
+    // end-->
+    sleep(3);
+    retry = 3;
+
+    // Wait for PPP interface ready
+    do
+    {
+        // Check whether PPPD exit abnormally
+        property_get(PROPERTY_PPPD_EXIT_CODE, exit_code, "");
+        if(strcmp(exit_code, "") != 0)
+        {
+            RLOGD("PPPd exit with code %s", exit_code);
+            retry = 0;
+            break;
+        }
+
+        fd  = open(PPP_OPERSTATE_PATH, O_RDONLY);
+        if (fd >= 0)
+        {
+            memset(buffer,0,sizeof(buffer));
+            read(fd, buffer, sizeof(buffer));       
+            close(fd);
+            if(!strncmp(buffer, "up", strlen("up")) || !strncmp(buffer, "unknown", strlen("unknown")))
+            {
+                // Should already get local IP address from PPP link after IPCP negotation
+                // system property net.ppp0.local-ip is created by PPPD in "ip-up" script
+                local_ip[0] = 0;
+
+                property_get("net.ppp0.local-ip", local_ip, "");
+                property_get("net.ppp0.dns1", local_pdns, "");
+                property_get("net.ppp0.dns2", local_sdns, "");
+                RLOGD("local_pdns:%s",local_pdns);
+                RLOGD("local_sdns:%s",local_sdns);
+                RLOGD("local_ip:%s",local_ip);
+
+
+                if ((!strcmp(apntype, "mms")))
+                {
+                    if((!strcmp(local_ip, "")))
+                    {
+                        RLOGD("PPP link is up but no local IP is assigned. Will retry %d times after %d seconds", \
+                                retry, POLL_PPP_SYSFS_SECONDS);
+                    }
+                    else
+                    {
+                        RLOGD("PPP link is up with local IP address %s", local_ip);
+                        // other info like dns will be passed to framework via property (set in ip-up script)
+                        //response[2] = local_ip;
+                        *response_local_ip = local_ip;
+                        // now we think PPPd is ready
+                        break;
+                    }
+                }
+                else
+                {
+                    if((!strcmp(local_ip, "")) || (!strcmp(local_ip, "0.0.0.0")))
+
+                        //end-->
+                    {
+                        RLOGD("PPP link is up but no local IP is assigned. Will retry %d times after %d seconds", \
+                                retry, POLL_PPP_SYSFS_SECONDS);
+                    }
+                    else
+                    {
+                        RLOGD("PPP link is up with local IP address %s", local_ip);
+                        // other info like dns will be passed to framework via property (set in ip-up script)
+                        //response[2] = local_ip;
+                        *response_local_ip = local_ip;
+                        // now we think PPPd is ready
+                        break;
+                    }
+                }
+
+            }
+            else
+            {
+                RLOGD("PPP link status in %s is %s. Will retry %d times", \
+                        PPP_OPERSTATE_PATH, buffer, retry);
+            }
+        }
+        else
+        {
+            RLOGD("Can not detect PPP state in %s. Will retry %d times after %d seconds", \
+                    PPP_OPERSTATE_PATH, retry-1, POLL_PPP_SYSFS_SECONDS);
+        }
+        sleep(POLL_PPP_SYSFS_SECONDS-1);
+    }while (--retry);
+
+    
+    // <!--modified by wangyi@2018.07.14 for optimizing RIL function modules
+    // no matter IP address abtain successfully or fail, set pppd flag, thread protect is not necessary
+    pppd = 1;
+    // end-->
+
+    if(retry == 0)
+    {
+        goto ppp_error;
+    }
+
+    close(ppp_fd);
+    ppp_fd = -1;
+
+    at_response_free(p_response);
+    return SUCCESS;
+error:
+    close(ppp_fd);
+    ppp_fd = -1;
+    at_response_free(p_response);
+    return ERROR;
+ppp_error:
+    close(ppp_fd);
+    ppp_fd = -1;
+    at_response_free(p_response);
+    return PPP_ERROR;
+
+}
+
+void requestSetInitialAttachAPNM910(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+void requestOperatorM910(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    int i;
+    int skip;
+    ATLine *p_cur;
+    char *response[3];
+    int network_debounce_time = 20;
+#if 1 //fibocom
+    __requestOperator_restart:
+#endif
+    memset(response, 0, sizeof(response));
+
+    ATResponse *p_response = NULL;
+
+    err = at_send_command_multiline(
+            "AT+COPS=3,0;+COPS?;+COPS=3,1;+COPS?;+COPS=3,2;+COPS?",
+            "+COPS:", &p_response);
+
+    /* we expect 3 lines here:
+     * +COPS: 0,0,"T - Mobile"
+     * +COPS: 0,1,"TMO"
+     * +COPS: 0,2,"310170"
+     */
+
+    if ( err < 0 || p_response->success == 0) goto error;
+
+    for (i = 0, p_cur = p_response->p_intermediates
+            ; p_cur != NULL
+            ; p_cur = p_cur->p_next, i++
+        )
+    {
+        char *line = p_cur->line;
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+
+        err = at_tok_nextint(&line, &skip);
+        if (err < 0) goto error;
+
+        // If we're unregistered, we may just get
+        // a "+COPS: 0" response
+        if (!at_tok_hasmore(&line))
+        {
+            response[i] = NULL;
+            g_cops_lte = -1;
+            continue;
+        }
+
+        err = at_tok_nextint(&line, &skip);
+        if (err < 0) goto error;
+
+        // a "+COPS: 0, n" response is also possible
+        if (!at_tok_hasmore(&line))
+        {
+            response[i] = NULL;
+            g_cops_lte = -1;
+            continue;
+        }
+
+        err = at_tok_nextstr(&line, &(response[i]));
+        if (err < 0) goto error;
+
+        err = at_tok_nextint(&line, &g_cops_lte);
+        if (err < 0) goto error;
+    }
+
+    if (i != 3)
+    {
+        /* expect 3 lines exactly */
+        goto error;
+        g_cops_lte = -1;
+    }
+
+    RLOGD("requestOperator:[%s,%s,%s]",response[0],response[1],response[2]);
+#if 1
+    if(!response[0] && !response[1] && !response[2] && (network_debounce_time > 0)){
+        sleep(1);
+        network_debounce_time--;
+        at_response_free(p_response);
+        goto __requestOperator_restart;
+    }
+    network_debounce_time = 0;
+#endif
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, response, sizeof(response));
+    at_response_free(p_response);
+
+    return;
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+#else
+static int getPreferredNetworkTypeM910()
+{
+    return 0;
+}
+/*
+*  return   0 GSM Network;
+*           1 NB Network
+*/
+static int isNBPreferredNetwork(void)
+{
+    return 0;
+}
+
+static int trySet4GNBPreferred(void)
+{
+    return 0;
+}
+
+void requestSetPreferredNetworkType_M910(void *data, size_t datalen __unused, RIL_Token t)
+{
+}
+
+void requestGetPreferredNetworkTypeM910(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+}
+
+void requestRegistrationStateM910(int request, void *data __unused,size_t datalen __unused, RIL_Token t)
+{
+}
+
+static int parseRegistrationStateM910(char *str, int *type __unused, int *items, int **response)
+{
+    return 0;
+}
+
+int odm_get_current_network_type_m910()
+{
+    return 0;
+}
+
+//<!--added by wangmengying@2019.11.26 for fix bug34926 MA510 query network registration status
+int odm_get_current_network_type_ma510()
+{
+    return 0;
+}
+//end--!>
+
+static int setupDataCallRASModeM910(char**response_local_ip,const char* apn,const char* auth_type,const char* username,const  char* password,const char* pdp_type)
+{
+    return 0;
+}
+
+void requestSetInitialAttachAPNM910(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+
+}
+
+void requestOperatorM910(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+}
+
+#endif
+/*End: Deleted by wujiabao in 2022/07/20, because we did not need it*/
diff --git a/hardware/ril/youyou_ril/network.h b/hardware/ril/youyou_ril/network.h
new file mode 100755
index 0000000..80bba1f
--- /dev/null
+++ b/hardware/ril/youyou_ril/network.h
@@ -0,0 +1,102 @@
+#ifndef _NETWORK_H_
+#define _NETWORK_H_
+
+#define NO_SCRIPT
+
+//<!---Used by ril.fibocom.cid property
+#define MAX_CID_PROPERTY_LENGTH 1
+#define MIN_CID_NUM 1
+#define MAX_CID_NUM 7
+//-----Used by ril.fibocom.cid property--!>
+
+//<!---Used by ril.fibocom.cgdcont0 property
+#define MAX_CGDCONT0_PROPERTY_LENGTH 1
+#define NEED_CGDCONT0_YES 1
+#define NEED_CGDCONT0_NO  0
+//-----Used by ril.fibocom.cgdcont0 property--!>
+
+//<!-----Used by ril.fibocom.usbmode property
+#define MAX_USBMODE_PROPERTY_LENGTH 2
+#define MIN_USBMODE_NUM 31
+#define MAX_USBMODE_NUM 75
+#define NO_CUS_USBMODE  0
+//-----!>
+
+#define DEFAULT_PDNS "8.8.8.8"
+#define DEFAULT_SDNS "8.8.4.4"
+
+#define DHCP_MAX_RETRY_NUM 1
+
+extern int fibocom_pingflag;
+
+void onDataCallListChanged(void *param);
+
+void requestDataCallList(void *data, size_t datalen, RIL_Token t);
+
+void requestQueryNetworkSelectionMode(void *data, size_t datalen, RIL_Token t);
+
+void requestQueryAvailableNetworks(void *data, size_t datalen, RIL_Token t);
+
+void requestSignalStrength(void *data, size_t datalen, RIL_Token t);
+
+void requestSignalStrength_Generic(void *data, size_t datalen, RIL_Token t);
+
+void requestRegistrationState(int request, void *data,size_t datalen, RIL_Token t);
+
+void OnRadioQuerryMdmNormalRegistration(int request, void *data,size_t datalen, RIL_Token t);
+
+void requestOperator(void *data, size_t datalen, RIL_Token t);
+
+void requestOperator_Generic(void *data, size_t datalen, RIL_Token t);
+
+void requestSetupDataCall(void *data, size_t datalen, RIL_Token t);
+
+void requestDeactivateDataCall(void *data, size_t datalen, RIL_Token t);
+
+void requestGetPreferredNetworkType(void *data, size_t datalen, RIL_Token t);
+
+void requestSetPreferredNetworkType(void *data, size_t datalen, RIL_Token t);
+
+void requestSetNetworkSelectionManual(void *data, size_t datalen, RIL_Token t);
+
+void requestNeighboringCellIds(void * data, size_t datalen, RIL_Token t);
+
+void requestGetCellInfoList(void * data, size_t datalen, RIL_Token t);
+
+void requestSetNetworkSelectionAutomatic(RIL_Token t);
+
+/* added by  nodecom aron begin */
+void requestSetLocationUpdates(void * data, size_t datalen, RIL_Token t);
+void requestScreenState(void *data, size_t datalen, RIL_Token t);
+/* added by  nodecom aron end */
+
+void onDeactiveDataCallList() ;
+
+void OnResumeLTENetwork();
+//added by lisf for debug 20181210
+int get_pid(char *name);
+void ril_kill_pppd(int flag);
+
+void requestSetPreferredNetworkType_M910(void *data, size_t datalen, RIL_Token t);
+void requestRegistrationStateM910(int request, void *data,size_t datalen, RIL_Token t);
+void requestSetInitialAttachAPNM910(void *data, size_t datalen, RIL_Token t);
+void requestGetPreferredNetworkTypeM910(void *data, size_t datalen, RIL_Token t);
+void requestOperatorM910(void *data, size_t datalen, RIL_Token t);
+static int setupDataCallRASModeM910(char**response_local_ip,const char* apn,const char* auth_type,const char* username,const  char* password,const char* pdp_type);
+
+int odm_get_current_network_type_m910();
+//<!--added by wangmengying@2019.11.26 for fix bug34926 MA510 query network registration status
+int odm_get_current_network_type_ma510();
+// end--!>
+
+void get_cid();
+void Get_NetProperties();
+void get_cgdcont0();
+void get_Cus_Usbmode();
+void getSetAPN(int, char*, char*);
+void odm_fix_gw(char *gw);
+
+
+
+#endif /*_NETWORK_H_*/
+
diff --git a/hardware/ril/youyou_ril/other_function.c b/hardware/ril/youyou_ril/other_function.c
new file mode 100755
index 0000000..8a94833
--- /dev/null
+++ b/hardware/ril/youyou_ril/other_function.c
@@ -0,0 +1,1287 @@
+/******************************************************************************
+  Copyright (C), 2019, Shenzhen G&T Industrial Development Co., Ltd
+
+  File:      other_function.c
+
+  Author:  Fibocom-diego
+  Version: 1.0
+  Date:  2019.04
+
+  Description:   otherfunction APIs
+
+** History:
+**Author (core ID)                Date          Number     Description of Changes
+**-----------------------------------------------------------------------------
+** NODECOM-Aron                30-10-2018         **   init version 
+** FIBOCOM-diego               10-01-2019         **   add requestDeviceIdentity support Androdi8.1
+** FIBOCOM-diego               15-04-2019         **   modify requestBasebandVersion support M910/757S devices
+** -----------------------------------------------------------------------------
+******************************************************************************/
+
+#include <telephony/ril.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <alloca.h>
+#include "atchannel.h"
+#include "at_tok.h"
+#include "misc.h"
+#include <getopt.h>
+#include <sys/socket.h>
+#include <cutils/sockets.h>
+#include <cutils/properties.h>
+#include <termios.h>
+
+#include "ril_common.h"
+#include "other_function.h"
+
+#define LOG_TAG GHT_RIL
+#include <utils/Log.h>
+
+
+extern int cur_oper;
+
+//<!---Start:Modified by Wujiabao in 2022/04/29, and change the initial value to GHT_L610
+product_model mode_flag = GHT_L610;
+//-----End:Modified by Wujiabao in 2022/04/29, and change the initial value to GHT_L610--->
+
+int if_get_mode_flag = 0;               //added by wujiabao to check if get mode flag
+extern int odm_get_current_network_type();
+
+/* BEGIN: Added by abby.wang, 2018/12/22 fix bug14209,bug13844 USSD has no return for a long time */
+extern unsigned int ussd_pending_index;
+extern const struct timeval ussd_timeout_timeval;
+
+/*Delete the Spaces on the left*/
+char *l_trim(char *szOutput, const char *szInput)
+{
+    assert(szInput != NULL);
+    assert(szOutput != NULL);
+    assert(szOutput != szInput);
+    for   (NULL; *szInput != '\0' && isspace(*szInput); ++szInput)
+    {
+        ;
+    }
+    return strcpy(szOutput, szInput);
+}
+
+/*Delete the Spaces on the right*/
+char *r_trim(char *szOutput, const char *szInput)
+{
+    char *p = NULL;
+    assert(szOutput != NULL);
+    assert(szOutput != szInput);
+    strcpy(szOutput, szInput);
+    for(p = szOutput + strlen(szOutput) - 1; p >= szOutput && isspace(*p); --p)
+    {
+        ;
+    }
+    *(++p) = '\0';
+    return szOutput;
+}
+
+/*Delete the left and right Spaces*/
+char *a_trim(char *szOutput, const char *szInput)
+{
+    char *p = NULL;
+    assert(szInput != NULL);
+    assert(szOutput != NULL);
+    l_trim(szOutput, szInput);
+    for   (p = szOutput + strlen(szOutput) - 1; p >= szOutput && isspace(*p); --p)
+    {
+        ;
+    }
+    *(++p) = '\0';
+    return szOutput;
+}
+
+int getProfileString(char *AppName, char *KeyName, char *KeyVal, char *DefaultVal)
+{
+    char appname[32], keyname[32];
+    char *buf, *c;
+    char buf_i[KEYVALLEN], buf_o[KEYVALLEN];
+    FILE *fp;
+    int found = 0; /* 1 AppName 2 KeyName */
+
+    strcpy(KeyVal, DefaultVal);
+    if( (fp = fopen( PROFILE_PATH, "r" )) == NULL )
+    {
+        RLOGE("GHT_PROFILE: openfile %s error: %s", PROFILE_PATH, strerror(errno));
+        return (RET_FAIL);
+    }
+    fseek( fp, 0, SEEK_SET );
+
+    if (!AppName || !KeyName)
+    {
+        RLOGE("GHT_PROFILE: AppName = \"%s\" or KeyName = \"%s\" is NULL!", AppName == NULL?"NULL":AppName, KeyName == NULL?"NULL":KeyName);
+        return RET_FAIL;
+    }
+    memset( appname, 0, sizeof(appname) );
+    sprintf( appname, "[%s]", AppName );
+
+    while( !feof(fp) && fgets( buf_i, KEYVALLEN - 1, fp ) != NULL )
+    {
+        l_trim(buf_o, buf_i);
+        //RLOGD("[%s,%d] buf_o:%s", __FUNCTION__, __LINE__, buf_o);
+        if( strlen(buf_o) <= 0 )
+        {
+            //RLOGD("[%s,%d] strlen(buf_o) <= 0, continue...", __FUNCTION__, __LINE__);
+            continue;
+        }
+        buf = NULL;
+        buf = buf_o;
+
+        if( found == 0 )
+        {
+            //RLOGD("[%s,%d] found is 0", __FUNCTION__, __LINE__);
+            if( buf[0] != '[' )
+            {
+                //RLOGD("[%s,%d] buf[0] is:%c not '[', continue...", __FUNCTION__, __LINE__, buf[0]);
+                continue;
+            }
+            else if ( strncmp(buf, appname, strlen(appname)) == 0 )
+            {
+                //RLOGD("[%s,%d] buf:%s, found appname!", __FUNCTION__, __LINE__, buf);
+                found = 1;
+                continue;
+            }
+            else
+            {
+                RLOGD("buf:%s, buf[0] is '[', but not match appname:%s, strlen(appname):%d", buf, appname, strlen(appname));
+            }
+
+        }
+        else if( found == 1 )
+        {
+            //RLOGD("[%s,%d] found is 1", __FUNCTION__, __LINE__);
+            if( buf[0] == '#' || buf[0] == ';' )
+            {
+                //RLOGD("[%s,%d] buf[0](%c) is '#' or ';', continue...", __FUNCTION__, __LINE__, buf[0]);
+                continue;
+            }
+            else if ( buf[0] == '[' )     //No content in this app
+            {
+                //RLOGD("[%s,%d] buf[0](%c) is '[', break!", __FUNCTION__, __LINE__, buf[0]);
+                break;
+            }
+            else
+            {
+                //RLOGD("[%s,%d] buf:%s", __FUNCTION__, __LINE__, buf);
+                if( (c = (char *)strchr(buf, '=')) == NULL )
+                {
+                    //RLOGD("[%s,%d] found '=', continue...", __FUNCTION__, __LINE__);
+                    continue;
+                }
+                memset( keyname, 0, sizeof(keyname) );
+
+                sscanf( buf, "%[^=|^ |^\t]", keyname );
+                //RLOGD("[%s,%d] keyname in file:%s", __FUNCTION__, __LINE__, keyname);
+
+                if( strcmp(keyname, KeyName) == 0 )
+                {
+                    //RLOGD("[%s,%d] keyname match successfully!", __FUNCTION__, __LINE__);
+
+                    sscanf( ++c, "%[^\n]", KeyVal );
+                    char *KeyVal_o = (char *)malloc(strlen(KeyVal) + 1);
+                    if(KeyVal_o != NULL)
+                    {
+                        memset(KeyVal_o, 0, sizeof(*KeyVal_o));
+                        a_trim(KeyVal_o, KeyVal);
+                        //RLOGD("[%s,%d] get KeyVal_o:%s", __FUNCTION__, __LINE__, KeyVal_o);
+
+                        if(KeyVal_o && strlen(KeyVal_o) > 0)
+                        {
+                            //RLOGD("[%s,%d] strcpy KeyVal_o to KeyVal!", __FUNCTION__, __LINE__);
+                            strcpy(KeyVal, KeyVal_o);
+                        }
+                        free(KeyVal_o);
+                        KeyVal_o = NULL;
+                    }
+                    found = 2;
+                    break;
+                }
+                else
+                {
+                    //RLOGD("[%s,%d] keyname not match!", __FUNCTION__, __LINE__);
+                    continue;
+                }
+            }
+        }
+    }
+
+    fclose( fp );
+    if( found == 2 )
+    {
+        RLOGD("GHT_PROFILE: Found [%s]%s = %s !", AppName, KeyName, KeyVal);
+        return (RET_SUCCESS);
+    }
+    else
+    {
+        RLOGE("GHT_PROFILE: Search for [%s]%s failed!, found_ret:%d", AppName, KeyName, found);
+        return (RET_FAIL);
+    }
+}
+
+
+bool getProfileBool(char *AppName, char *KeyName, bool DefaultVal) {
+    char KeyVal[32] = {0};
+    int ret = getProfileString(AppName, KeyName, KeyVal, "");
+    int len = strlen(KeyVal);
+
+    if (len == 1) {
+        char ch = KeyVal[0];
+        if (ch == '0' || ch == 'n') {
+            return false;
+        } else if (ch == '1' || ch == 'y') {
+            return true;
+        }
+    } else if (len > 1) {
+        if (!strcmp(KeyVal, "no") || !strcmp(KeyVal, "false") || !strcmp(KeyVal, "off")) {
+            return false;
+        } else if (!strcmp(KeyVal, "yes") || !strcmp(KeyVal, "true") || !strcmp(KeyVal, "on")) {
+            return true;
+        }
+    }
+
+    return DefaultVal;
+}
+
+// Convert string profiles to int (default if fails); return default value if out of bounds
+static intmax_t getProfileImax(char *AppName, char *KeyName, intmax_t lower_bound, intmax_t upper_bound,
+                                  intmax_t default_value) {
+    if (!AppName || !KeyName) {
+        return default_value;
+    }
+
+    intmax_t result = default_value;
+    char buf[KEYVALLEN] = {'\0'};
+    char *end = NULL;
+
+    getProfileString(AppName, KeyName, buf, "");
+    int len = strlen(buf);
+    if (len > 0) {
+        int tmp = errno;
+        errno = 0;
+
+        // Infer base automatically
+        result = strtoimax(buf, &end, /*base*/ 0);
+        if ((result == INTMAX_MIN || result == INTMAX_MAX) && errno == ERANGE) {
+            // Over or underflow
+            result = default_value;
+            RLOGD("[%s]%s = %s: overflow!", AppName, KeyName, buf);
+            //ALOGV("%s(%s,%" PRIdMAX ") - overflow", __FUNCTION__, KeyName, default_value);
+        } else if (result < lower_bound || result > upper_bound) {
+            // Out of range of requested bounds
+            result = default_value;
+            RLOGD("[%s]%s = %s: out of range!", AppName, KeyName, buf);
+            //ALOGV("%s(%s,%" PRIdMAX ") - out of range", __FUNCTION__, KeyName, default_value);
+        } else if (end == buf) {
+            // Numeric conversion failed
+            result = default_value;
+            RLOGD("[%s]%s = %s: numeric conversion failed!", AppName, KeyName, buf);
+            //ALOGV("%s(%s,%" PRIdMAX ") - numeric conversion failed", __FUNCTION__, KeyName,
+                  //default_value);
+        }
+
+        errno = tmp;
+    }
+
+    return result;
+}
+
+int64_t getProfileInt64(char *AppName, char *KeyName, int64_t default_value) {
+    return (int64_t)getProfileImax(AppName, KeyName, INT64_MIN, INT64_MAX, default_value);
+}
+
+int32_t getProfileInt32(char *AppName, char *KeyName, int32_t default_value) {
+    return (int32_t)getProfileImax(AppName, KeyName, INT32_MIN, INT32_MAX, default_value);
+}
+
+
+//Add this feature later
+#if 0
+// Convert string property to int (default if fails); return default value if out of bounds
+static intmax_t property_get_imax(const char *key, intmax_t lower_bound, intmax_t upper_bound,
+                                  intmax_t default_value) {
+    if (!key) {
+        return default_value;
+    }
+
+    intmax_t result = default_value;
+    char buf[PROPERTY_VALUE_MAX] = {'\0'};
+    char *end = NULL;
+
+    int len = property_get(key, buf, "");
+    if (len > 0) {
+        int tmp = errno;
+        errno = 0;
+
+        // Infer base automatically
+        result = strtoimax(buf, &end, /*base*/ 0);
+        if ((result == INTMAX_MIN || result == INTMAX_MAX) && errno == ERANGE) {
+            // Over or underflow
+            result = default_value;
+            ALOGV("%s(%s,%" PRIdMAX ") - overflow", __FUNCTION__, key, default_value);
+        } else if (result < lower_bound || result > upper_bound) {
+            // Out of range of requested bounds
+            result = default_value;
+            ALOGV("%s(%s,%" PRIdMAX ") - out of range", __FUNCTION__, key, default_value);
+        } else if (end == buf) {
+            // Numeric conversion failed
+            result = default_value;
+            ALOGV("%s(%s,%" PRIdMAX ") - numeric conversion failed", __FUNCTION__, key,
+                  default_value);
+        }
+
+        errno = tmp;
+    }
+
+    return result;
+}
+
+int64_t property_get_int64(const char *key, int64_t default_value) {
+    return (int64_t)property_get_imax(key, INT64_MIN, INT64_MAX, default_value);
+}
+
+int32_t property_get_int32(const char *key, int32_t default_value) {
+    return (int32_t)property_get_imax(key, INT32_MIN, INT32_MAX, default_value);
+}
+#endif
+
+static void onUssdResponse(char *mode) {
+    char *response[2];
+    response[0] = mode;
+
+    switch (mode[0] - '0') {
+        case 2:
+            response[1] = "USSD terminated by network";
+        break;
+        case 3:
+            response[1] = "Other local client has responded";
+        break;
+        case 4:
+            response[1] = "Operation not supported";
+        break;
+        case 5:
+        default:
+            response[1] = "Network time out";
+        break;
+    }
+    RIL_onUnsolicitedResponse(RIL_UNSOL_ON_USSD, response, sizeof(response[0]) + sizeof(response[1]));
+}
+
+static void onUssdTimedCallback(void *param) {
+    if (ussd_pending_index != *((unsigned int *) param))
+        return;
+    at_send_command("AT+CUSD=2", NULL); //cancel
+    onUssdResponse("5");
+}
+
+static char* getModelId()
+{
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char *line;
+    char *response = NULL;
+    char *res = NULL;
+
+    err = at_send_command_singleline("AT+CGMM?","+CGMM:",&p_response);
+    if(err<0 || p_response->success == 0)
+    {
+        RLOGE("[%s] at_send_command_singleline error",__FUNCTION__);
+        goto error;
+    }
+    else
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if(err){
+            RLOGE("[%s] at_tok_start error",__FUNCTION__);
+            goto error;
+        }
+        err = at_tok_nextstr(&line, &response);
+        if(err){
+            RLOGE("[%s] at_tok_nextstr error",__FUNCTION__);
+            goto error;
+        }
+    }
+    RLOGD("[%s] Model ID:[%s]",__FUNCTION__,response);
+    /*
+     *duplicate a string  Memory for the new string is obtained with malloc,
+     *and can be freed with free
+     */
+    res = strdup(response);
+error:
+    at_response_free(p_response);
+    return res;
+}
+
+/**
+ * RIL_REQUEST_SEND_USSD
+ *
+ * Send a USSD message
+ *
+ * If a USSD session already exists, the message should be sent in the
+ * context of that session. Otherwise, a new session should be created.
+ *
+ * The network reply should be reported via RIL_UNSOL_ON_USSD
+ *
+ * Only one USSD session may exist at a time, and the session is assumed
+ * to exist until:
+ *   a) The android system invokes RIL_REQUEST_CANCEL_USSD
+ *   b) The implementation sends a RIL_UNSOL_ON_USSD with a type code
+ *      of "0" (USSD-Notify/no further action) or "2" (session terminated)
+ *
+ * "data" is a const char * containing the USSD request in UTF-8 format
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  FDN_CHECK_FAILURE
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_CANCEL_USSD, RIL_UNSOL_ON_USSD
+ */
+void  requestSendUSSD(void *data, size_t datalen __unused, RIL_Token t)
+{
+    ATResponse   *p_response = NULL;
+    int err;
+    char *cmd = NULL;
+    const char *ussdRequest;
+    int mode = 0;
+
+#ifdef CUSD_USE_UCS2_MODE
+    int i = 0;
+    char ucs2[100];
+    ussdRequest = (char *)(data);
+    while (ussdRequest[i]) {
+        sprintf(ucs2+i*4, "%04X", ussdRequest[i]);
+        i++;
+    }
+    data = ucs2;
+#endif
+    ussdRequest = (char *)(data);
+    mode = 1;
+
+    asprintf(&cmd,"AT+CUSD=%d,\"%s\"",mode,ussdRequest);
+    err = at_send_command(cmd,&p_response);
+    if(err != 0 || p_response == NULL || p_response->success == 0)
+    {
+        goto error;
+    }
+
+#if 1 
+    ussd_pending_index++;
+    RIL_requestTimedCallback(onUssdTimedCallback, (void *)(&ussd_pending_index), &ussd_timeout_timeval);
+#endif
+    if(NULL != cmd)
+    {
+        free(cmd);
+        cmd = NULL;
+    }
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    return;
+error:
+    RLOGD("[Abby]ERROR: %s failed",__func__);
+    if(NULL != cmd)
+    {
+        free(cmd);
+        cmd = NULL;
+    }
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+/* END: Added by abby.wang, 2018/12/22 fix bug14209,bug13844 USSD has no return for a long time */
+
+void requestCancelUSSD(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    ATResponse *p_response = NULL;
+    int err = 0;
+
+    ussd_pending_index++;
+
+    err = at_send_command_numeric("AT+CUSD=2", &p_response);
+
+    if (err < 0 || p_response->success == 0)
+    {
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+    else
+    {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS,
+                p_response->p_intermediates->line, sizeof(char *));
+    }
+    at_response_free(p_response);
+
+}
+
+void requestOemHookStrings(void *data, size_t datalen, RIL_Token t)
+{
+    int i;
+    const char ** cur;
+
+    RLOGD("got OEM_HOOK_STRINGS: 0x%8p %lu", data, (long)datalen);
+
+    for (i = (datalen / sizeof (char *)), cur = (const char **)data ;
+            i > 0 ; cur++, i --)
+    {
+        RLOGD("> '%s'", *cur);
+    }
+
+    // echo back strings
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, data, datalen);
+}
+
+int eth1_interface = 0;
+
+void InitFlags()
+{
+    eth1_interface      = 0;
+    Voice_Support_Flag  = 1;
+    GTRAT_Support_Flag  = 1;
+    Net_3G_Support_Flag = 1;
+}
+
+static void setModeType_new(char *str)
+{
+    RLOGD("*********enter [%s]:GHT_%s*********",__FUNCTION__, str == NULL? "NULL":str);
+
+    if(str == NULL)
+    {
+        goto error;
+    }
+
+    //If only a module is replaced, you need to initialize the Flags left by the previous module.
+    InitFlags();
+
+    if((!strncmp(str,"L610",4)) || (!strncmp(str,"MC615",5)))
+    {
+        mode_flag = GHT_L610;
+        if(!strncmp(str,"MC615",5))
+        {
+            RLOGD("GHT [GHT_MC615]");
+        }
+        else
+        {
+            RLOGD("GHT [GHT_L610]");
+        }
+    }
+    else if(!strncmp(str,"FG650",5) || !strncmp(str,"FM650",5))
+    {
+        mode_flag = GHT_FG650;
+        RLOGD("GHT [GHT_FG650]");
+    }
+    else if(!strncmp(str,"FG621",5))
+    {
+        mode_flag = GHT_FG621;
+        RLOGD("GHT [GHT_FG621]");
+    }
+    else if(!strncmp(str,"NL668",5) || !strncmp(str,"MC116",5) )
+    {
+        mode_flag = GHT_NL668;
+        RLOGD("GHT [GHT_NL668]");
+    }
+    /* BEGIN: Added by guorui, 2022/08/01  */
+    else if(!strncmp(str,"L716",4) )
+    {
+        mode_flag = GHT_L716;
+        RLOGD("GHT [GHT_L716]");
+    }
+    /* END: Added by guorui, 2022/08/01  */
+    else if(!strncmp(str,"H330S",5))
+    {
+        mode_flag = GHT_H330S;
+        RLOGD("GHT [GHT_H330S]");
+    }
+    else if(!strncmp(str,"MC919",5))
+    {
+        mode_flag = GHT_MC919;
+        RLOGD("GHT [GHT_MC919]");
+    }
+    else if((!strncmp(str,"MC661",5)) || (!strncmp(str,"MC669",5)) || (!strncmp(str,"MC665",5)))
+    {
+        mode_flag = GHT_MC66x;
+        RLOGD("GHT [GHT_MC66x]");
+    }
+    else{
+        goto error;
+    }
+
+    //Check whether the module uses "eth1" network card for ECM dialing.
+    if(!strncmp(str, "L610-CN-62", strlen("L610-CN-62"))
+     ||!strncmp(str, "MC615", strlen("MC615"))
+     ||!strncmp(str, "MC669-CN", strlen("MC669-CN"))
+     ||!strncmp(str, "MC665-CN", strlen("MC665-CN"))
+     ||!strncmp(str, "MC661-CN", strlen("MC661-CN"))
+     ||!strncmp(str, "MC919", strlen("MC919")))
+    {
+        RLOGD("this module use eth1 Netif!");
+        eth1_interface = 1;
+    }
+
+    //Check whether the module supports dialing.
+    if(!strncmp(str, "MC669-CN", strlen("MC669-CN"))
+      ||!strncmp(str, "MC665-CN", strlen("MC665-CN"))
+      ||!strncmp(str, "MC661-CN", strlen("MC661-CN")))
+    {
+        RLOGD("This module does not support voice, GTRAT and 3G networks!");
+        Voice_Support_Flag   = 0;
+        GTRAT_Support_Flag   = 0;
+        Net_3G_Support_Flag  = 0;
+    }
+
+    if(!strncmp(str, "MC615-CN", strlen("MC615-CN")))
+    {
+        //MC615-CN project only supports 4G network and does not support AT+GTRAT=10 command
+        Net_3G_Support_Flag  = 0;
+    }
+
+    return;
+
+error:
+    //<!-- Start: Modified by Wujiabao in 2022/04/21, Change the default module model from GHT_MDM_NORMAL to GHT_L610,
+    //because up to now, we are only doing modules related to L610
+    mode_flag = GHT_L610;
+    RLOGD("GHT [The module is unrecognized and we default it to be GHT_L610]");
+    //End----!>
+
+    return;
+}
+
+
+static void setModeType(char *str)
+{
+    RLOGD("[setModeType] version is %s",str);
+    char *model_id = NULL;
+    if (0 == strncmp(str,"NL650",5))
+    {
+        mode_flag = GHT_NL650;
+    }
+    else if(0 == strncmp(str,"NL660",5))
+    {
+        mode_flag = GHT_NL660;
+        RLOGD("GHT [GHT_NL660]");
+    }
+    else if (0 == strncmp(str,"19006.1000.00.01.71",19) \
+        || !strncmp(str,"19006.1000.00.01.72",19) \
+        || !strncmp(str,"19006.1000.00.01.74",19) \
+        || !strncmp(str,"19006.1000.33.01.71",19) \
+        || !strncmp(str,"19006.1000.00.02.04",19) \
+        || !strncmp(str,"19006.1000.00.02.10",19) )
+    {
+        mode_flag = GHT_NL668;
+        RLOGD("GHT [GHT_NL668_CN_XX]");
+    }
+    else if(0 ==strncmp(str,"19006.1000.00.02.77",19) \
+        || !strncmp(str,"19006.1000.00.02.79",19) )
+    {
+        mode_flag = GHT_NL668_AM;
+        RLOGD("GHT [GHT_NL668_AM]");
+    }
+    else if(0 ==strncmp(str,"19006.1000.00.01.73",19) )
+    {
+        mode_flag = GHT_NL668_EAU;
+        RLOGD("GHT [GHT_NL668_EAU]");
+    }
+    //added for NL678-E-00
+    else if(!strncmp(str,"19208.1000.00.01.01",19)\
+    || !strncmp(str,"19208.1000.00.02.01",19))
+    {
+        mode_flag = GHT_NL678_E;
+        RLOGD("GHT [GHT_NL678_E]");
+    }
+    else if((!strncmp(str,"19006.1000.00.01.76",19)) \
+        || (!strncmp(str,"19006.1000.00.01.78",19)))
+    {
+        mode_flag = GHT_NL668_EU;
+        RLOGD("GHT [GHT_NL668_EU]");
+    }
+    else if((!strncmp(str,"19100.3000.00.11.01",19)))
+    {
+        mode_flag = GHT_757S;
+        RLOGD("GHT [GHT_757S]");
+    }
+    else if((!strncmp(str,"69100.1000.00.02.61",19)) \
+        || (!strncmp(str,"69100.1000.01.02.61",19)))
+    {
+        mode_flag = GHT_M910_GL;
+        RLOGD("GHT [GHT_M910_GL]");
+    }
+    //add by zhengjianrong for MA510 RIL BEGIN
+    else if((!strncmp(str,"69400.1000.00.00.00",19)))
+    {
+        mode_flag = GHT_MA510_GL;
+        RLOGD("GHT [GHT_MA510_GL]");
+    }
+    //add by zhengjianrong for MA510 RIL END
+    else if((!strncmp(str,"16000.1000.00.03.01",19)) \
+        || (!strncmp(str,"16000.1000.00.04.01",19)) \
+        || (!strncmp(str,"16000.1000.00.05.01",19)) \
+        || (!strncmp(str,"16000.1000.00.05.08",19)) \
+        || (!strncmp(str,"16000.1000.00.05.10",19)) \
+        || (!strncmp(str,"16000.1000.00.02.01",19)))
+    {
+        mode_flag = GHT_L610;
+        RLOGD("GHT [GHT_L610_XX]");
+    }
+    else if(!strncmp(str,"16121.1000.00.01.01",19))
+    {
+        mode_flag = GHT_FG621;
+        RLOGD("GHT [GHT_FG621_XX]");
+    }
+     else if(!strncmp(str,"86100.1000.00",13))
+    {
+        mode_flag = GHT_FG650;
+        RLOGD("GHT [GHT_FG650_XX]");
+    }
+    else
+    {
+        RLOGD(" getModelId Enter ");
+        model_id = getModelId();
+        setModeType_new(model_id);
+    }
+    get_Properties();
+
+    RLOGD("[%s] ====== Leave ",__FUNCTION__);
+
+}
+
+void get_Properties()
+{
+    //Specifies the name of the net interface to use at SETUP_DATA_CALL
+    getNetifName();
+
+    //Specifies which cid to use for data dialing
+    get_cid();
+
+    //Specifies whether to set the APN of cid0
+    get_cgdcont0();
+
+    //Gets and sets the USBMODE, if necessary
+    getSetUsbmode();
+
+}
+
+static char* getBasebandVersion()
+{
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char *line = NULL;
+    char *response = NULL;
+    char *res = NULL;
+
+    if(ANDROID_8 == Ght_Android_Version)
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 8 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        sleep(2);
+        at_send_command("ATE0", NULL);
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X
+    sleep(2);
+    at_send_command("ATE0", NULL);
+#endif
+#endif
+
+    err = at_send_command_singleline("AT+CGMR?","+CGMR:",&p_response);
+    if(err<0 || p_response->success == 0)
+    {
+        RLOGE("[%s] at_send_command_singleline error",__FUNCTION__);
+        goto error;
+    }
+    else
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+        if(err){
+            RLOGE("[%s] at_tok_start error",__FUNCTION__);
+            goto error;
+        }
+        err = at_tok_nextstr(&line, &response);
+        if(err){
+            RLOGE("[%s] at_tok_nextstr error",__FUNCTION__);
+            goto error;
+        }
+    }
+    RLOGD("[%s] basebandverison:[%s]",__FUNCTION__,response);
+    /*
+     *duplicate a string  Memory for the new string is obtained with malloc,
+     *and can be freed with free
+     */
+    res = strdup(response);
+
+error:
+    at_response_free(p_response);
+    return res;
+}
+void requestBasebandVersion(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    char *response = NULL;
+
+    RLOGD("[%s] ====== Enter ",__FUNCTION__);
+    response = getBasebandVersion();
+    if(response == NULL)
+    {
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+    else
+    {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, response, sizeof(char *));
+        setModeType(response);
+		if_get_mode_flag = 1;
+        free(response);
+    }
+
+    
+    return;
+}
+
+static int loadCommand(char *cmd,char *prefix,int request)
+{
+    int err = 0;
+    int network_type = 0;
+
+    switch (mode_flag)
+    {
+        case GHT_NL650:
+        case GHT_NL660:
+            if(request == 0){
+                network_type = odm_get_current_network_type();
+                if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+                {
+                    if(14 == network_type)
+                    {
+                        strcpy(cmd,"AT+LCTSN=0,7");
+                        strcpy(prefix,"+LCTSN:");
+                    }
+                    else
+                    {
+                        strcpy(cmd,"AT+LCTSN=0,9");
+                        strcpy(prefix,"+LCTSN:");
+                    }
+                }
+                else
+                {
+                    strcpy(cmd,"AT+LCTSN=0,7");
+                    strcpy(prefix,"+LCTSN:");
+                }
+            }
+            else if(request == 1){
+                    strcpy(cmd,"AT+LCTSN=0,7");
+                    strcpy(prefix,"+LCTSN:");
+            }
+            else{
+                RLOGE("[%s] unsupport request ",__FUNCTION__);
+                err = -1;
+            }
+            break;
+        case GHT_NL668:
+        case GHT_NL668_EAU:
+        case GHT_NL668_EU:
+        case GHT_NL668_AM:
+        case GHT_757S:
+        case GHT_M910_GL:
+        // <!--wangmengying@2019.7.26 for solve 7.x GET_IMEI return ERROR
+        case GHT_MA510_GL:
+        // end-->
+        case GHT_NL678_E:
+        case GHT_MDM_NORMAL:
+        case GHT_L610:
+        case GHT_MC919:
+        case GHT_MC66x:
+        case GHT_FG621:
+        case GHT_FG650:
+        case GHT_H330S:
+        case GHT_L716:
+                if(request == 0){
+                    strcpy(cmd,"AT+CGSN?");
+                    strcpy(prefix,"+CGSN:");
+                }
+                else if(request == 1){
+                    strcpy(cmd,"AT+CGSN=2");
+                    strcpy(prefix,"+CGSN:");
+                }
+                else{
+                    RLOGE("[%s] unsupport request ",__FUNCTION__);
+                    err = -1;
+                }
+            break;
+        default:
+            err = -1;
+            RLOGE("[%s] unsupport mode flag ",__FUNCTION__);
+            break;
+    }
+    return err;
+}
+
+static char *getIMEI()
+{
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char *line;
+    char *res = NULL;
+    char *responsenet = NULL;
+    char *cmd = NULL;
+    char *prefix = NULL;
+    char cmdbuf[15] = {0};
+    char prebuf[15] = {0};
+    int requestImei = 0;
+
+    err = loadCommand(cmdbuf,prebuf,requestImei);
+    if(err){
+       RLOGE("[%s] loadCommand error",__FUNCTION__);
+       goto done;
+    }
+    asprintf( &cmd, "%s",cmdbuf);
+    asprintf( &prefix, "%s",prebuf);
+
+    RLOGD("[%s] cmd: [%s]",__FUNCTION__,cmd);
+    RLOGD("[%s] prefix: [%s]",__FUNCTION__,prefix);
+
+    err = at_send_command_singleline(cmd,prefix, &p_response);
+    if (err < 0 || p_response->success == 0){
+       RLOGE("[%s] at_send_command_singleline err",__FUNCTION__);
+       goto done;
+    }
+
+    line = p_response->p_intermediates->line;
+    err = at_tok_start(&line);
+    if(err){
+       RLOGE("[%s] at_tok_start err",__FUNCTION__);
+       goto done;
+    }
+    err = at_tok_nextstr(&line, &responsenet);
+    if(err){
+       RLOGE("[%s] at_tok_nextstr err",__FUNCTION__);
+       goto done;
+    }
+    RLOGD("[%s] imei: %s",__FUNCTION__,responsenet);
+    res = strdup(responsenet);  //duplicate a string
+
+done:
+    at_response_free(p_response);
+    return res;
+}
+void requestGetIMEI(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    char *response = NULL;
+
+    RLOGD("[%s] ====== Enter ",__FUNCTION__);
+    
+    response = getIMEI();
+    if(response == NULL)
+    {
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+    else
+    {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS,response, sizeof(char *));
+        free(response);
+    }
+    RLOGD("[%s] ====== Leave ",__FUNCTION__);
+    return;
+}
+
+static char *getIMEISV()
+{
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char *line;
+    char *res = NULL;
+    char *responsenet = NULL;
+    char *cmd = NULL;
+    char *prefix = NULL;
+    char cmdbuf[15] = {0};
+    char prebuf[15] = {0};
+    int requestImeisv = 1;
+
+    err = loadCommand(cmdbuf,prebuf,requestImeisv);
+    if(err){
+       RLOGE("[%s] loadCommand error",__FUNCTION__);
+       goto done;
+    }
+    asprintf( &cmd, "%s",cmdbuf);
+    asprintf( &prefix, "%s",prebuf);
+
+    RLOGD("[%s] cmd: [%s]",__FUNCTION__,cmd);
+    RLOGD("[%s] prefix: [%s]",__FUNCTION__,prefix);
+
+    err = at_send_command_singleline(cmd,prefix, &p_response);
+    if (err < 0 || p_response->success == 0){
+       RLOGE("[%s] at_send_command_singleline err",__FUNCTION__);
+       goto done;
+    }
+
+    line = p_response->p_intermediates->line;
+    err = at_tok_start(&line);
+    if(err){
+       RLOGE("[%s] at_tok_start err",__FUNCTION__);
+       goto done;
+    }
+    err = at_tok_nextstr(&line, &responsenet);
+    if(err){
+       RLOGE("[%s] at_tok_nextstr err",__FUNCTION__);
+       goto done;
+    }
+    RLOGD("[%s] imei: %s",__FUNCTION__,responsenet);
+    res = strdup(responsenet);  //duplicate a string
+
+done:
+    at_response_free(p_response);
+    return res;
+}
+
+void requestGetIMEISV(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    char imeisv_str[3];
+    int len = 0;
+    char *strIMEI = NULL;
+
+    RLOGD("[%s] ====== Enter ",__FUNCTION__);
+    strIMEI = getIMEISV();
+    len = strlen(strIMEI);
+    
+    if((strIMEI == NULL) || (len < 2))
+    {
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+    else
+    {
+        imeisv_str[0] = strIMEI[len-2];
+        imeisv_str[1] = strIMEI[len-1];
+        imeisv_str[2] = 0;
+        RLOGD("requestGetIMEISV imeisv [%s]", imeisv_str);
+        RIL_onRequestComplete(t, RIL_E_SUCCESS,imeisv_str, sizeof(char *));
+        free(strIMEI);
+    }
+    RLOGD("[%s] ====== Leave ",__FUNCTION__);
+    return; 
+}
+
+static void setOperator(char *src)
+{
+    if(src == NULL){
+        RLOGE("[%s] parameter error",__FUNCTION__);
+        goto done;
+    }
+    if(-1 == cur_oper)
+    {
+        *(src+5) = '\0';
+        if((0 == strcmp(src,"46003")) || (0 == strcmp(src,"20404")))
+        {
+            cur_oper = ODM_CT_OPERATOR_3G;
+        }
+        else if(0 == strcmp(src,"46011"))
+        {
+            cur_oper = ODM_CT_OPERATOR_4G;
+        }
+        else if((0 == strcmp(src,"46000")) || (0 == strcmp(src,"46002")) ||
+                (0 == strcmp(src,"46007")) || (0 == strcmp(src,"46004")) ||
+				(0 == strcmp(src,"46008")))
+        {
+            cur_oper = ODM_CM_OPERATOR;
+        }
+        else if((0 == strcmp(src,"46001"))||(0 == strcmp(src,"46006")) ||
+		        (0 == strcmp(src,"46009")))
+        {
+            cur_oper = ODM_CU_OPERATOR;
+        }
+        else
+        {
+            RLOGE("Fibocom unkonw mcc and mnc,line = %s\r",src);
+            cur_oper = ODM_CM_OPERATOR;
+        }
+    }
+
+done:
+    RLOGD("[%s]  cur_oper :[%d]",__FUNCTION__,cur_oper);
+    return;
+}
+
+static char * getIMSI()
+{
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char *line;
+    char *res = NULL;
+    char *response = NULL;
+    int nRetry = 10;
+	int get_imsi_flag = 0;
+
+    do
+    {
+        err = at_send_command_singleline("AT+QCIMI?","+QCIMI:",&p_response);
+        if (err < 0 || p_response->success == 0){
+            RLOGE("[%s] at_send_command_singleline QCIMI error",__FUNCTION__);
+            //err = at_send_command_singleline("AT+CIMI?","+CIMI:", &p_response);
+            err = at_send_command_singleline_timeout("AT+CIMI?", "+CIMI", NUMERIC_AT_TIMEOUT_MSEC, &p_response);
+            if (err < 0 || p_response->success == 0){
+                RLOGE("[%s] at_send_command_singleline CIMI error",__FUNCTION__);
+            }
+            else{
+                RLOGD("[%s] at_send_command_singleline CIMI sucess",__FUNCTION__);
+				get_imsi_flag = 1;
+                break;
+            }
+        }
+        else{
+            RLOGD("[%s] at_send_command_singleline QCIMI sucess",__FUNCTION__);
+			get_imsi_flag = 1;
+            break;
+        }
+        sleep(1);
+    }while(nRetry--);
+
+	if(get_imsi_flag == 0)
+		goto done;
+
+    line = p_response->p_intermediates->line;
+    err = at_tok_start(&line);
+    if(err){
+        RLOGE("[%s] at_tok_start err",__FUNCTION__);
+        goto done;
+    }
+    err = at_tok_nextstr(&line, &response);
+    if(err)
+    {
+        RLOGE("[%s] at_tok_nextstr err",__FUNCTION__);
+        goto done; 
+    }
+
+    RLOGD("[%s] getIMSI :%s",__FUNCTION__,response);
+
+    /*
+     *duplicate a string  Memory for the new string is obtained with malloc, 
+     *and can be freed with free
+     */
+    res = strdup(response);  
+done:
+    at_response_free(p_response);
+    return res;    
+}
+void requestGetIMSI(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+
+    char *response = NULL;
+
+    RLOGD("[%s] ====== Enter ",__FUNCTION__);
+    
+    response = getIMSI();
+    if (response == NULL)
+    {
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+    else
+    {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS,response, sizeof(char *));
+        setOperator(response);
+        free(response);
+    }
+    RLOGD("[%s] ====== Leave ",__FUNCTION__);
+    return;
+}
+
+/* added by nodecom begin */
+void requestQueryClip(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    /**
+     * Queries the status of the CLIP supplementary service
+     *
+     * (for MMI code "*#30#")
+     *
+     * "data" is NULL
+     * "response" is an int *
+     * (int *)response)[0] is 1 for "CLIP provisioned"
+     *                           and 0 for "CLIP not provisioned"
+     *                           and 2 for "unknown, e.g. no network etc"
+     */
+
+    int err;
+    int* response[1];
+
+    ATResponse *p_response = NULL;
+    char *line;
+
+    err = at_send_command_singleline("AT+CLIP?","+CLIP:",&p_response);
+    if(err < 0 ||p_response->success == 0)
+        goto error;
+    line = p_response->p_intermediates->line;
+    err = at_tok_start(&line);
+    if(err < 0)
+        goto error;
+    err = at_tok_nextint(&line,response[0]);
+    if(err < 0)
+        goto error;
+
+    RIL_onRequestComplete(t,RIL_E_SUCCESS, response, sizeof(response));
+    at_response_free(p_response);
+    return;
+
+error:
+    RIL_onRequestComplete(t,RIL_E_GENERIC_FAILURE,NULL,0);
+    at_response_free(p_response);
+
+}
+
+/* added by nodecom end */
+
+//#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+/*Begin: Wujiabao changed it to '#if 1' in 2022/07/20*/
+#if 1
+/*End:   Wujiabao changed it to '#if 1' in 2022/07/20*/
+void requestDeviceIdentity(void *data __unused,size_t datalen __unused,  RIL_Token t)
+{
+    int err;
+    int i;
+    char * response[4];
+    
+    ATResponse *p_response = NULL;
+    char *line;
+    ATLine *p_cur;
+
+    response[2] = "888";
+    response[3] = "777";
+
+    err = at_send_command_multiline("AT+CGSN=1;+CGSN=2","+CGSN:", &p_response);
+	
+    /* we expect 2 lines here:
+     * +CGSN: 866857030583674
+     * +CGSN: 8668570305836726
+     */
+    if ( err < 0 || p_response->success == 0) goto error;
+
+    //line = p_response->p_intermediates->line;
+    //RLOGD("requestDeviceIdentity get mesagge = %s ",line);
+    
+    for (i = 0, p_cur = p_response->p_intermediates; 
+        p_cur != NULL; 
+        p_cur = p_cur->p_next, i++)
+    {
+          line = p_cur->line;
+          RLOGD("requestDeviceIdentity get line = %s ",line);
+          err = at_tok_start(&line);
+          if (err < 0) goto error;
+          
+          RLOGD("requestDeviceIdentity get line1 = %s ",line);
+          err = at_tok_nextstr(&line, &(response[i]));
+    }
+        
+    RIL_onRequestComplete(t,RIL_E_SUCCESS, response, sizeof(response));
+    at_response_free(p_response);
+    return;
+
+    
+error:
+    RIL_onRequestComplete(t,RIL_E_GENERIC_FAILURE,NULL,0);  
+    at_response_free(p_response);
+}
+#endif
diff --git a/hardware/ril/youyou_ril/other_function.h b/hardware/ril/youyou_ril/other_function.h
new file mode 100755
index 0000000..22876c9
--- /dev/null
+++ b/hardware/ril/youyou_ril/other_function.h
@@ -0,0 +1,42 @@
+#ifndef _OTHER_FUNCTION_H_
+#define _OTHER_FUNCTION_H_
+/*other_function.h*/
+
+/*when who why modified*/
+
+#define KEYVALLEN 200
+
+
+void  requestSendUSSD(void *data, size_t datalen, RIL_Token t);
+
+void requestCancelUSSD(void *data, size_t datalen, RIL_Token t);
+
+void requestOemHookStrings(void *data, size_t datalen, RIL_Token t);
+
+void requestBasebandVersion(void *data, size_t datalen, RIL_Token t);
+
+void requestGetIMEI(void *data, size_t datalen, RIL_Token t);
+
+void requestGetIMEISV(void *data, size_t datalen, RIL_Token t);
+
+void requestGetIMSI(void *data, size_t datalen, RIL_Token t);
+
+/* added by nodecom begin */
+void requestQueryClip(void *data, size_t datalen, RIL_Token t);
+
+/* added by nodecom end */
+
+//#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+/*Begin: Wujiabao changed it to '#if 1' in 2022/07/20*/
+#if 1
+/*End:   Wujiabao changed it to '#if 1' in 2022/07/20*/
+void requestDeviceIdentity(void *data,size_t datalen,  RIL_Token t);
+#endif
+
+void get_Properties();
+int getProfileString(char *AppName, char *KeyName, char *KeyVal, char *DefaultVal);
+char *l_trim(char *szOutput, const char *szInput);
+char *r_trim(char *szOutput, const char *szInput);
+char *a_trim(char *szOutput, const char *szInput);
+
+#endif /*_OTHER_FUNCTION_H_*/
diff --git a/hardware/ril/youyou_ril/reference-ril.c b/hardware/ril/youyou_ril/reference-ril.c
new file mode 100755
index 0000000..e5235ab
--- /dev/null
+++ b/hardware/ril/youyou_ril/reference-ril.c
@@ -0,0 +1,3836 @@
+/* //device/system/reference-ril/reference-ril.c
+ **
+ ** Copyright 2006, The Android Open Source Project
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/*
+ ** NODECOM reference-ril 1.0.0 is base version for wcdma ,added by NODECOM-Aron 2010.9.29
+ */
+/*when who why modified*/
+/*
+ *2010.11.30 modified by Aron
+ added sim pin and puk request and modified the request of Baseband Version
+ 2011.10.21 Aron modified the version to 1.1.1 for modify of mms and Baseband Version
+ */
+
+#include <telephony/ril.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <alloca.h>
+#include "atchannel.h"
+#include "at_tok.h"
+#include "misc.h"
+#include <getopt.h>
+#include <sys/socket.h>
+#include <cutils/sockets.h>
+#include <cutils/properties.h>
+#include <termios.h>
+#include <ctype.h>
+#include "ril_common.h"
+#include "sim.h"
+#include "voice.h"
+#include "network.h"
+#include "sms.h"
+#include "other_function.h"
+#include "getdevinfo.h"
+//added by NODECOM-Aron end
+
+#define LOG_TAG GHT_RIL
+#include <utils/Log.h>
+
+#define MAX_AT_RESPONSE 0x1000
+
+/* property to control the delay (in seconds) to initialize RIL */
+#define RIL_DELAY_TIME "gsm.ril.delay"
+
+//add by gaojing to resolve product question begin
+
+#define V35_Normal_Version_to_open_CREG 1
+
+#define V35_Product_Version_to_Close_CREG 1
+
+//add by gaojing to resolve product question end
+
+/*add by NODECOM-Aron for version control 2010.9.29*/
+/*modified by NODECOM-Aron for sim pin and puk request 2010.11.30*/
+
+/*add by eric.li to define version for 32/64 arm arch start*/
+#ifndef  ODM_ARM64
+#define REFERENCE_RIL_VERSION  "Fibocom_RIL_V9X.01.21"
+#else
+#define REFERENCE_RIL_VERSION  "Fibocom_RIL_V9X.01.21"
+#endif
+/*add by eric.li to define version for 32/64 arm arch end*/
+
+#define PPP_OPERSTATE_PATH "/sys/class/net/ppp0/operstate"
+
+// <!--[ODM][ril]pulong@2015.8.24 added for CT operator
+int cur_oper = -1;
+// end-->
+////int devmode = -1;
+
+dial_mode dialmode = DIAL_RAS_MOD;
+
+extern int handover_flag;
+extern int voice_handover_flag;
+extern int s_fd;
+extern int  ppp_fd ;
+extern int if_get_mode_flag;
+
+extern char s_ATBuffer[MAX_AT_RESPONSE+1];
+extern char *s_ATBufferCur;
+//added for NL678-E-00
+extern product_model mode_flag;
+#if (RIL_VERSION != 7)
+extern void requestSetInitialAttachAPN(void *data, size_t datalen, RIL_Token t);
+#endif
+
+static void onUnsolicited (const char *s, const char *sms_pdu);
+
+static void onRequest (int request, void *data, size_t datalen, RIL_Token t);
+static RIL_RadioState currentState();
+static int onSupports (int requestCode);
+static void onCancel (RIL_Token t);
+static const char *getVersion();
+static const char *getKernelVersion();
+static int isRadioOn();
+SIM_Status getSIMStatus();
+static int getCardStatus(RIL_CardStatus_v6 **pp_card_status);
+static void freeCardStatus(RIL_CardStatus_v6 *p_card_status);
+
+static void pollSIMState (void *param);
+void setRadioState(RIL_RadioState newState);
+//static void onDataCallListChanged(void *param);
+
+int start_ppp_check_pthread();
+
+//diego add for ndis thread
+int start_ndis_do_dhcp_pthread();
+extern void *ndis_main_loop();
+pthread_t s_tid_ndisloop;
+//diego add end 
+
+/* BEGIN: Added by abby.wang, 2018/12/22 fix bug14209,bug13844 USSD has no return for a long time */
+#define CUSD_USE_UCS2_MODE
+unsigned int ussd_pending_index = 0;
+const struct timeval ussd_timeout_timeval = {30,0}; //seconds
+/* END: Added by abby.wang, 2018/12/22 fix bug14209,bug13844 USSD has no return for a long time */
+/* BEGIN: Added by eric.li, 2018/12/25   PN:gSimstatus to trace sim status */
+SIM_Status gSimStatus = SIM_ABSENT;
+/* END:   Added by eric.li, 2018/12/25   PN:gSimstatus to trace sim status */
+/* BEGIN: Added by eric.li, 2019/1/10   PN:0014627 android5 cannot enter sim init with property */
+int gSimPostInitFlag = 0;
+/* END:   Added by eric.li, 2019/1/10   PN:0014627 android5 cannot enter sim init with property */
+extern int detect_usb_device(char *atchannel, char *datachannel);
+
+extern int qualcomm_diag_reset();
+
+
+// <!--[ODM]wangmengying@2019.8.16 [SN-20190608001]Customized AT commands
+//extern void initReserveAtCommand();
+void initReserveAtCommand();
+// end-->
+
+extern const char * requestToString(int request);
+extern const char * radioStateToString(RIL_RadioState s);
+extern void pingLoop();
+
+
+/*** Static Variables ***/
+static RIL_RadioFunctions s_callbacks =
+{
+    RIL_VERSION,
+    onRequest,
+    currentState,
+    onSupports,
+    onCancel,
+    getVersion
+};
+
+static RIL_RadioState sState = RADIO_STATE_UNAVAILABLE;
+
+static pthread_mutex_t s_state_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t s_state_cond = PTHREAD_COND_INITIALIZER;
+
+static int s_port = -1;
+static const char * s_device_path = NULL;
+#ifdef HAVE_DATA_DEVICE
+static const char * s_data_device_path = NULL;
+#endif
+static const char * s_diag_device_path = NULL;
+static int          s_device_socket = 0;
+
+char atchannel[15] = {0};
+char datachannel[15] = {0};
+
+char cur_atchannel[15] = {0};
+char cur_datachannel[15] = {0};
+
+int script_type = 0;
+
+/* trigger change to this with s_state_cond */
+static int s_closed = 0;
+
+//static int sFD;     /* file desc of AT channel */
+//static char sATBuffer[MAX_AT_RESPONSE+1];
+//static char *sATBufferCur = NULL;
+
+static const struct timeval TIMEVAL_SIMPOLL = {1,0};
+
+//static const struct timeval TIMEVAL_0 = {0,0};
+static struct timeval TIMEVAL_DELAYINIT = {0,0}; // will be set according to property value
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+// Max number of times we'll try to repoll when we think
+// we have a AT+CLCC race condition
+#define REPOLL_CALLS_COUNT_MAX 4
+
+// Line index that was incoming or waiting at last poll, or -1 for none
+static int s_incomingOrWaitingLine = -1;
+// Number of times we've asked for a repoll of AT+CLCC
+static int s_repollCallsCount = 0;
+// Should we expect a call to be answered in the next CLCC?
+static int s_expectAnswer = 0;
+#endif /* WORKAROUND_ERRONEOUS_ANSWER */
+
+/* added by NODECOM-Aron for SMS begin */
+extern int sms_type;
+/* added by NODECOM-Aron for SMS end */
+extern int pppd;
+
+extern int odm_get_current_network_type();
+/* BEGIN: Added by eric.li, 2018/12/22   PN:sovle issue cannot receive sms and so on issue in case  onSimReady can not be called  with probability  */
+static void odm_post_sim_init(void)
+{
+    at_send_command_singleline("AT+CSMS=0", "+CSMS:", NULL);
+
+//<!--modified by wujiabao for mantis bug:FG621 cannot receive long SMS on Android7,9
+    if(mode_flag == GHT_FG621)
+		at_send_command("AT+CPMS=\"SM\",\"SM\",\"SM\"", NULL);
+	else
+        at_send_command("AT+CPMS=\"ME\",\"ME\",\"ME\"", NULL);
+//end !-->
+
+    if(GHT_H330S == mode_flag)
+        at_send_command("AT+CNMI=3,1,0,0,0", NULL);
+    else
+        at_send_command("AT+CNMI=2,1,2,2,0", NULL);
+
+    if(ANDROID_7 == Ght_Android_Version)
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 7 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        if(mode_flag == GHT_FG621)
+            at_send_command("AT+CNMI=2,2,2,2,1", NULL);
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID7X
+    if(mode_flag == GHT_FG621)
+		at_send_command("AT+CNMI=2,2,2,2,1", NULL);
+#endif
+#endif
+
+    /* BEGIN: Added by eric.li, 2019/1/21   PN:solve onRequest done before initial callback */
+    gSimPostInitFlag = 1;
+    /* END:   Added by eric.li, 2019/1/21   PN:solve onRequest done before initial callback */
+
+}
+/* END:   Added by eric.li, 2018/12/22   PN:sovle issue cannot receive sms and so on issue in case  onSimReady can not be called  with probability  */
+/*begin:modified by lisf 20181201 for RIL8*/	
+//#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+/*Begin: Wujiabao changed it to '#if 1' in 2022/07/20*/
+#if 1
+/*End:   Wujiabao changed it to '#if 1' in 2022/07/20*/
+static void requestGetHardwareConfig(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+   // TODO - hook this up with real query/info from radio.
+
+   RIL_HardwareConfig hwCfg;
+   hwCfg.type = -1;
+
+   RIL_onRequestComplete(t, RIL_E_SUCCESS, &hwCfg, sizeof(hwCfg));
+}
+#endif
+/*end:modified by lisf 20181201 for RIL8*/	
+/* BEGIN: Added by eric.li, 2018/10/17   PN:support RIL_REQUEST_GET_RADIO_CAPABILITY */
+#if (RIL_VERSION > 9 )
+static void setRadioCap(int *rat)
+{
+    RLOGD("[%s] DEBUG mode flag :[%d]",__FUNCTION__,mode_flag);
+    if (GHT_NL668 == mode_flag) {
+        *rat = (RAF_GPRS | RAF_EDGE | RAF_UMTS | RAF_1xRTT | RAF_EVDO_A | RAF_HSDPA| RAF_HSUPA|RAF_HSPA | RAF_EHRPD | RAF_LTE | RAF_HSPAP | RAF_GSM | RAF_TD_SCDMA);
+    } 
+    else if (GHT_NL668_AM == mode_flag){
+        *rat = RAF_UMTS | RAF_HSDPA| RAF_HSUPA|RAF_HSPA | RAF_LTE | RAF_HSPAP;
+    } 
+    else if ( (GHT_NL668_EAU == mode_flag) || (GHT_NL668_EU == mode_flag)){
+       /*Begin add NL668-EAU Capablility by lisf 20181112*/
+       *rat = RAF_GPRS | RAF_EDGE | RAF_UMTS | RAF_HSDPA| RAF_HSUPA | RAF_HSPA | RAF_LTE | RAF_HSPAP | RAF_GSM;
+        /*End add NL668-EAU Capablility by lisf 20181112*/
+    }
+    /*begin:added NL678-E-00 radio Capablility by lisf 20181120*/
+    else if(GHT_NL678_E == mode_flag){
+#if (RIL_VERSION >= 12 )
+        {
+            *rat = RAF_UMTS | RAF_HSDPA| RAF_HSUPA | RAF_HSPA | RAF_LTE  | RAF_HSPAP | RAF_LTE_CA;
+        }
+#else 
+        {
+            *rat = RAF_UMTS | RAF_HSDPA| RAF_HSUPA | RAF_HSPA | RAF_LTE  | RAF_HSPAP;
+        }
+#endif
+    }
+    /*end:added NL678-E-00 radio Capablility by lisf 20181120*/
+    /*begin:added support for NL668 NORMAL by lisf 20190318*/
+    else if(GHT_MDM_NORMAL == mode_flag){
+        *rat = RAF_GPRS | RAF_EDGE|RAF_UMTS | RAF_HSDPA| RAF_HSUPA | RAF_HSPA | RAF_LTE  | RAF_HSPAP | RAF_GSM;
+    }
+    /*end:added support  for NL668 NORMAL by lisf 20190318*/
+    //add by zhengjianrong for MA510 RIL BEGIN
+    else if (GHT_M910_GL == mode_flag || GHT_757S == mode_flag || mode_flag == GHT_MA510_GL){
+    //add by zhengjianrong for MA510 RIL END
+        *rat = (RAF_GPRS | RAF_EDGE | RAF_UMTS | RAF_1xRTT | RAF_EVDO_A | RAF_HSDPA| RAF_HSUPA|RAF_HSPA | RAF_EHRPD | RAF_LTE | RAF_HSPAP | RAF_GSM | RAF_TD_SCDMA);
+    } 
+    else if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag){
+        *rat = (RAF_GPRS | RAF_EDGE | RAF_LTE | RAF_GSM);
+    }
+    else if (GHT_FG621 == mode_flag){
+        *rat = (RAF_UMTS | RAF_HSDPA| RAF_HSUPA|RAF_HSPA | RAF_LTE | RAF_HSPAP);
+    }
+     else if (GHT_FG650 == mode_flag){
+        *rat = (RAF_UMTS | RAF_HSDPA| RAF_HSUPA|RAF_HSPA | RAF_LTE | RAF_HSPAP | RAF_NR_LTE);
+    }
+    else{
+        *rat = RAF_GPRS | RAF_EDGE|RAF_UMTS | RAF_HSDPA| RAF_HSUPA | RAF_HSPA | RAF_LTE  | RAF_HSPAP | RAF_GSM;
+    }
+}
+static int getRadioCap()
+{
+    int err = 0;
+    int rat = 0;
+    char *line = NULL;
+    ATResponse *p_response = NULL;
+    
+    err = at_send_command_singleline("AT+GTRADIOCAP=0", "+GTRADIOCAP", &p_response);
+    if (err < 0 || p_response->success == 0){
+        RLOGE("[%s] at_send_command_singleline err",__FUNCTION__);
+        goto error;
+    }
+    line=p_response->p_intermediates->line;
+    err = at_tok_start(&(line));
+    if (err < 0 ){
+        RLOGE("[%s] at_tok_start err",__FUNCTION__);
+        goto error;
+    }
+    err = at_tok_nexthexint(&line, &rat);
+    if (err < 0 ){
+        RLOGE("[%s] at_tok_nexthexint err",__FUNCTION__);
+        goto error;
+    }
+    err = rat;
+    RLOGD("[%s] RadioCapability:[%d]",__FUNCTION__,rat);
+error:
+    at_response_free(p_response);
+    return err;
+}
+static int setRadioCapablility(RIL_RadioCapability *response)
+{
+    int err = 0;
+
+    if(response == NULL){
+        err = -1;
+        RLOGE("[%s] parameter error",__FUNCTION__);
+        goto error;
+    }
+    response->version = RIL_RADIO_CAPABILITY_VERSION;
+    response->session = 0;
+    response->phase = RC_PHASE_FINISH;
+
+    err = getRadioCap();
+    if(err > 0){
+        response->rat = err;
+    }
+    else{
+        setRadioCap(&response->rat);
+    }
+    RLOGD("[%s] get radioaccessfamily,rat[%d]",__FUNCTION__,response->rat);
+error:
+    return err;
+}
+static void requestGetRadioCapablility(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err = -1;
+    RIL_RadioCapability response;
+
+    RLOGD("[%s] ====== Enter ",__FUNCTION__);
+
+    memset(&response,0,sizeof(RIL_RadioCapability));
+    err = setRadioCapablility(&response);
+    if(err){
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+    else{
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(RIL_RadioCapability));
+    }
+    RLOGD("[%s] ====== Leave ",__FUNCTION__);
+    return;
+}
+#endif
+/* END:   Added by eric.li, 2018/10/17   PN:support RIL_REQUEST_GET_RADIO_CAPABILITY */
+
+static const char *getKernelVersion()
+{
+    char *cmd;
+    int fd = 0;
+    int ret = 0;
+    static  char bufsrc[100]={0};
+
+    asprintf(&cmd, "uname -r > /data/ODM_KERNEL_VERSION");
+    RLOGD("%s",cmd);
+    system(cmd);
+    free(cmd);
+
+    fd = open("/data/ODM_KERNEL_VERSION", O_RDONLY);
+    ret = read(fd, bufsrc, sizeof(bufsrc));
+
+    RLOGD("ODM_KERNEL_VERSION :: %s",bufsrc);
+    property_set("odm.kernel.version", bufsrc);
+
+    return bufsrc;
+}
+
+static void *ppp_main_loop()
+{
+    int fd;
+    char buffer[20];
+    unsigned int count = 3;
+
+    for(;;)
+    {
+        if(pppd == 1)
+        {
+        /*begin:modified for ppp dial retry count by lisf 20181224*/
+            //count = 5;
+            if (GHT_L610 == mode_flag || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+            {
+                count = 15;
+            }
+            else
+            {
+                count = 5;
+            }
+
+	/*end:modified for ppp dial retry count by lisf 20181224*/
+            do
+            {
+                fd  = open(PPP_OPERSTATE_PATH, O_RDONLY);
+                if (fd >= 0)
+                {
+                    buffer[0] = 0;
+			memset(buffer,0,sizeof(buffer)); //added by lisf for debug 20181219
+                    read(fd, buffer, sizeof(buffer));
+                    close(fd);
+		      RLOGD("ppp_main_loop:%s",buffer);
+                    if(!strncmp(buffer, "up", strlen("up")) || !strncmp(buffer, "unknown", strlen("unknown")))
+                    {
+                          /*begin:modified for ppp dial retry count by lisf 20181224*/
+                          char local_ip[PROPERTY_VALUE_MAX]={0};
+                		property_get("net.ppp0.local-ip", local_ip, "");
+			      if(!((!strcmp(local_ip, "")) || (!strcmp(local_ip, "0.0.0.0"))))
+			      {
+					  RLOGD("ppp has already connected ,local ip :%s\n",local_ip);
+					  count = 5;
+					  break;
+			      }
+				/*end:modified for ppp dial retry count by lisf 20181224*/
+                    }
+                    else
+                    {
+                        RLOGD("ppp_main_loop:PPP link status is %s. Will retry %d times after %d seconds",buffer, count, 2);
+                    }
+                }
+                else
+                {
+                    RLOGD("ppp_main_loop:Can not detect PPP state. Will retry %d times after %d seconds",count, 2);
+                }
+                sleep(2);
+            } while (--count);
+            //remove for ril reponse to framework may be messy code
+
+            if(0 == count && pppd == 1)
+
+            {
+                    RLOGD("ppp get state timeout!\n");
+                    onDeactiveDataCallList();
+            }
+        }
+        sleep(4);
+    }
+    return ((void *)0);
+}
+
+
+void readSMS()
+{
+    int location = 0;
+    int err;
+    ATResponse *p_response = NULL;
+    ATLine *p_cur;
+    /*begin:added by lisf 20181121*/
+    int network_type = 0;
+    network_type = odm_get_current_network_type();
+    /*end:added by lisf 20181121*/
+    if ((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper))
+    {
+/*begin:modified by lisf 20181121*/
+	if(6 == network_type || 7 ==network_type || 13 ==network_type)
+/*end:modified by lisf 20181121*/
+        {
+            err = at_send_command_multiline("AT^HCMGL=0","^HCMGL:",&p_response);
+
+            for (p_cur = p_response->p_intermediates; p_cur != NULL;
+                    p_cur = p_cur->p_next)
+            {
+                char *line = p_cur->line;
+                RLOGD("read SMS line=%s",line);
+                err = at_tok_start(&line);
+                if(err < 0)
+                {
+                    RLOGD("start fail");
+                    continue;
+                }
+                RLOGD("read SMS start line=%s",line);
+                err = at_tok_nextint(&line, &location);
+                if(err < 0)
+                {
+                    RLOGD("nextint fail");
+                    continue;
+                }
+                RLOGD("read SMS location=%d",location);
+
+                RIL_requestTimedCallback (receiveSMS, ( void* )(long)location, NULL );
+            }
+        }
+        else
+        {
+            err = at_send_command_multiline("AT+CMGL=0","+CMGL:",&p_response);
+
+            for (p_cur = p_response->p_intermediates; p_cur != NULL;
+                    p_cur = p_cur->p_next)
+            {
+                char *line = p_cur->line;
+                RLOGD("read SMS CMGL line=%s",line);
+                err = at_tok_start(&line);
+                if(err < 0)
+                {
+                    continue;
+                }
+                RLOGD("read SMS CMGL start line=%s",line);
+                err = at_tok_nextint(&line, &location);
+                if(err < 0)
+                {
+                    continue;
+                }
+                RLOGD("read SMS CMGL location=%d",location);
+
+                RIL_requestTimedCallback ( receiveSMS, ( void* )(long)location, NULL );
+            }
+        }
+    }
+    else
+    {
+        err = at_send_command_multiline("AT+CMGL=0","+CMGL:",&p_response);
+
+        for (p_cur = p_response->p_intermediates; p_cur != NULL;
+                p_cur = p_cur->p_next)
+        {
+            char *line = p_cur->line;
+            RLOGD("read SMS CMGL line=%s",line);
+            err = at_tok_start(&line);
+            if(err < 0)
+            {
+                continue;
+            }
+            RLOGD("read SMS CMGL start line=%s",line);
+            err = at_tok_nextint(&line, &location);
+            if(err < 0)
+            {
+                continue;
+            }
+            RLOGD("read SMS CMGL location=%d",location);
+
+            RIL_requestTimedCallback ( receiveSMS, ( void* )(long)location, NULL );
+        }
+    }
+    at_response_free(p_response);
+}
+
+/** do post-AT+CFUN=1 initialization */
+static void onRadioPowerOn()
+{
+    RLOGD("******** Enter onRadioPowerOn() ********");
+#ifdef USE_TI_COMMANDS
+    /*  Must be after CFUN=1 */
+    /*  TI specific -- notifications for CPHS things such */
+    /*  as CPHS message waiting indicator */
+
+    at_send_command("AT%CPHS=1", NULL);
+
+    /*  TI specific -- enable NITZ unsol notifs */
+    at_send_command("AT%CTZV=1", NULL);
+#endif
+
+    pollSIMState(NULL);
+}
+
+/** do post- SIM ready initialization */
+static void onSIMReady()
+{
+    int err;
+    char *line;
+    int network_mode = 2;
+    ATResponse *p_response = NULL;
+    RLOGD("******** Enter %s ********", __FUNCTION__);
+	/* BEGIN: Deleted by eric.li, 2019/1/10   PN:0014627 android5 cannot enter sim init with property */
+	/* END:   Deleted by eric.li, 2019/1/10   PN:0014627 android5 cannot enter sim init with property */
+    err = at_send_command_numeric("AT+QCIMI",&p_response);
+    if((err < 0) || (0 == p_response->success))
+    {
+        at_response_free(p_response);
+        err = at_send_command_numeric("AT+CIMI",&p_response);
+
+        if((err < 0) || (0 == p_response->success))
+        {
+            RLOGD("Fibocom unknow operator");
+            goto error;
+        }
+    }
+    line = p_response->p_intermediates->line;
+    *(line+5) = '\0';
+    if((0 == strcmp(line,"46003")) || (0 == strcmp(line,"20404")))
+    {
+        cur_oper = ODM_CT_OPERATOR_3G;
+    }
+    else if(0 == strcmp(line,"46011"))
+    {
+        cur_oper = ODM_CT_OPERATOR_4G;
+    }
+    else if((0 == strcmp(line,"46000")) || (0 == strcmp(line,"46002")) ||
+            (0 == strcmp(line,"46007")) || (0 == strcmp(line,"46004")) ||
+            (0 == strcmp(line,"46008")))
+    {
+        cur_oper = ODM_CM_OPERATOR;
+    }
+    else if((0 == strcmp(line,"46001"))||(0 == strcmp(line,"46006")) ||
+            (0 == strcmp(line,"46009")))
+    {
+        cur_oper = ODM_CU_OPERATOR;
+    }
+    else
+    {
+        RLOGD("Fibocom unkonw mcc and mnc,line = %s\r",line);
+        cur_oper = ODM_CM_OPERATOR;
+        at_response_free(p_response);
+        p_response = NULL;
+    }
+    
+    at_response_free(p_response);
+    p_response = NULL;
+
+    RLOGD("[%s,%d]cur_oper:%d, mode_flag:%d", __FUNCTION__, __LINE__, cur_oper, mode_flag);    //mode_flag defaults to 0
+
+	if (mode_flag < GHT_NL668)
+	{
+    err = at_send_command_singleline("AT+MODODR?", "+MODODR:", &p_response);
+    if (err == 0 && p_response->success != 0)
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start(&line);
+
+        err = at_tok_nextint(&line, &network_mode);
+        if (err < 0)
+        {
+                at_response_free(p_response);
+            return ;
+        }
+    }
+    // <!--modified by wangyi@2018.07.13 for optimizing time consuming of network available after radio power-on
+        at_response_free(p_response);
+    p_response = NULL;
+    // end-->
+    if((ODM_CT_OPERATOR_3G==cur_oper) || (ODM_CT_OPERATOR_4G==cur_oper))
+    {
+        if(7 == network_mode)
+        {
+            at_send_command("AT+MODODR=9",&p_response);
+        }
+        else if(3 == network_mode)
+        {
+            at_send_command("AT+MODODR=8",&p_response);
+        }
+    }
+    else
+    {
+        if((9 == network_mode) || (10 == network_mode))
+        {
+            if(ODM_CM_OPERATOR==cur_oper)
+            {
+                at_send_command("AT+MODODR=6",&p_response);
+            }
+            else if(ODM_CU_OPERATOR==cur_oper)
+            {
+                at_send_command("AT+MODODR=1",&p_response);
+            }
+        }
+        else if(8 == network_mode)
+        {
+            at_send_command("AT+MODODR=3",&p_response);
+        }
+    }
+    if(NULL != p_response)
+    {
+        at_response_free(p_response);
+        sleep(2);
+    }
+	}
+error:
+    at_response_free(p_response);
+    p_response = NULL;
+
+    RIL_onUnsolicitedResponse(RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);
+    RLOGD("******** Leave %s ********", __FUNCTION__);
+    return;
+// end-->
+}
+
+static void requestRadioPower(void *data, size_t datalen __unused, RIL_Token t)
+{
+    int onOff;
+
+    int err;
+    ATResponse *p_response = NULL;
+/* BEGIN: Added by eric.li, 2018/10/20   PN:fix switch airplane on/off not auto to register in network */
+   int restricted =0 ;
+   //RIL_SimRefreshResult refresh_result = 2;
+   RIL_SimRefreshResponse_v7 *pSimRefreshResponse = NULL;
+/* END:   Added by eric.li, 2018/10/20   PN:fix switch airplane on/off not auto to register in network */
+    RLOGD("******** Enter requestRadioPower() ********");
+    //datalen;
+    assert (datalen >= sizeof(int *));
+    onOff = ((int *)data)[0];
+    if ((onOff == 0) && (RADIO_STATE_OFF != sState))
+    {
+        /*begin:modifed "AT+CFUN=4" switch switch airplane on by lisf 20190418 for mantis 0019905*/
+        // <!--[ODM]wangmengying@2019.11.27 fix bug34577 CFUN command set time to 20s
+        err = at_send_command_timeout("AT+CFUN=4",&p_response,ATSEND_TIMEOUT_MSEC*2);
+        // end--!>
+        /*end:modifed "AT+CFUN=4" switch airplane on by lisf 20190418 for mantis 0019905*/
+        if (err < 0 || p_response->success == 0) goto error;
+        setRadioState(RADIO_STATE_OFF);
+        /* BEGIN: Added by eric.li, 2019/1/21   PN:solve issue that can not receive sms issues with probability */
+        gSimPostInitFlag = 0;
+        /* END:   Added by eric.li, 2019/1/21   PN:solve issue that can not receive sms issues with probability */
+       /*begin:added for NL678-E ppp dial by lisf 20190129*/
+	if(mode_flag  == GHT_NL678_E || mode_flag  ==GHT_MDM_NORMAL)
+	{
+		pppd =0 ;
+	}
+	/*end:added for NL678-E ppp dial by lisf 20190129*/
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    else if ((onOff > 0) && (RADIO_STATE_OFF == sState || RADIO_STATE_SIM_NOT_READY == sState))
+#else
+    else if ((onOff > 0) && (RADIO_STATE_OFF == sState))
+#endif
+#endif
+    //else if ((onOff > 0) && (RADIO_STATE_OFF == sState || ((Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11) && (RADIO_STATE_SIM_NOT_READY == sState))))
+    else if ((onOff > 0) && ((RADIO_STATE_SIM_NOT_READY == sState) || (RADIO_STATE_OFF == sState) || (RADIO_STATE_UNAVAILABLE == sState) || (RADIO_STATE_SIM_READY == sState)))
+    {
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ? and sState:%s == RADIO_STATE_SIM_NOT_READY or RADIO_STATE_OFF?", __FUNCTION__, __LINE__, Ght_Android_Version, radioStateToString(sState));
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ? and sState:%s == RADIO_STATE_OFF?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        }
+        // <!--[ODM]wangmengying@2019.11.27 fix bug34577 CFUN command set time to 20s
+        err = at_send_command_timeout("AT+CFUN=1",&p_response,ATSEND_TIMEOUT_MSEC*2);
+        // end--!>
+        if (err < 0 || p_response->success == 0)
+        {
+            // Some stacks return an error when there is no SIM,
+            // but they really turn the RF portion on
+            // So, if we get an error, let's check to see if it
+            // turned on anyway
+            if (isRadioOn() != 1)
+            {
+                goto error;
+            }
+        }
+        sleep(2);
+
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            setRadioState( RADIO_STATE_ON);
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            setRadioState(RADIO_STATE_SIM_NOT_READY);
+        }
+
+#if 0
+/*begin:modified by lisf for android8 x 20181221*/
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+      setRadioState( RADIO_STATE_ON);
+#else
+        setRadioState(RADIO_STATE_SIM_NOT_READY);
+#endif
+#endif
+	/* BEGIN: Added by eric.li, 2018/10/22   PN:add status to refresh sim status */
+      pSimRefreshResponse =  malloc(sizeof(RIL_SimRefreshResponse_v7));
+      if (NULL == pSimRefreshResponse)
+      	{
+		RLOGD("malloc RIL_SimRefreshResponse_v7 failed ");
+		goto error;
+	 }
+	 pSimRefreshResponse->aid= NULL;
+	 pSimRefreshResponse->ef_id = 0;
+	 pSimRefreshResponse->result = SIM_RESET;
+
+     if(Ght_Android_Version != ANDROID_4)
+     {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d != 4 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        RLOGD("RIL_UNSOL_SIM_REFRESH");
+        RIL_onUnsolicitedResponse(RIL_UNSOL_SIM_REFRESH, pSimRefreshResponse, sizeof(RIL_SimRefreshResponse_v7));
+     }
+
+#if 0
+	 /* BEGIN: Modified by eric.li, 2019/1/15   PN:solve issue 0015594 that SIM_REFRESH with SIM_RESET lead to exception  on android4 when radio power on */
+#ifndef 	 GHT_FEATURE_ANDROID4X
+	 RLOGD("RIL_UNSOL_SIM_REFRESH");
+	 RIL_onUnsolicitedResponse(RIL_UNSOL_SIM_REFRESH, pSimRefreshResponse, sizeof(RIL_SimRefreshResponse_v7));
+#endif	 
+	 /* END:   Modified by eric.li, 2019/1/15   PN:solve issue 0015594 that SIM_REFRESH with SIM_RESET lead to exception  on android4 radio power on */
+#endif
+
+        free(pSimRefreshResponse);
+	 pSimRefreshResponse	 = NULL;
+	/* END:   Added by eric.li, 2018/10/22   PN:add status to refresh sim status */
+    }
+    else
+    {
+        int cfun;
+        cfun = isRadioOn();
+        RLOGD("[%s,%d] current cfun:%d, current Android:%d",__FUNCTION__, __LINE__, cfun, Ght_Android_Version);
+        RLOGD("[%s,%d] Upper level request(onOff):%d, sState:%s(%d), and do nothing!",__FUNCTION__, __LINE__, onOff, radioStateToString(sState), sState);
+    }
+
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+	/* BEGIN: Added by eric.li, 2018/10/20   PN:fix switch airplane on/off not auto to register in network */
+	    restricted = RIL_RESTRICTED_STATE_NONE;
+    RIL_onUnsolicitedResponse(RIL_UNSOL_RESTRICTED_STATE_CHANGED,
+                              &restricted, sizeof(int *));
+      /* END:   Added by eric.li, 2018/10/20   PN:fix switch airplane on/off not auto to register in network */
+    return;
+error:
+    at_response_free(p_response);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+
+
+
+void requestGetSimStatus(void* data __unused, size_t datalen __unused, RIL_Token t)
+{
+    RIL_CardStatus_v6 *p_card_status;
+
+    char *p_buffer;
+    int buffer_size;
+    RLOGD("******** Enter requestGetSimStatus() ********");
+
+    int result = getCardStatus(&p_card_status);
+
+    if (result == RIL_E_SUCCESS)
+    {
+        p_buffer = (char *)p_card_status;
+        buffer_size = sizeof(*p_card_status);
+    }
+    else
+    {
+        p_buffer = NULL;
+        buffer_size = 0;
+    }
+    RIL_onRequestComplete(t, result, p_buffer, buffer_size);
+
+    freeCardStatus(p_card_status);
+}
+
+static int parseSimResponseLine(char* line, RIL_SIM_IO_Response* response) {
+    char *response_raw;
+    int err, length, sw1, sw2;
+
+    err = at_tok_start(&line);
+    if (err < 0) return err;
+
+    err = at_tok_nextint(&line, &length);
+    if (err < 0) return err;
+
+    if (at_tok_hasmore(&line)) {
+        err = at_tok_nextstr(&line, &response_raw);
+        if (err < 0) return err;
+    }
+
+    if(length >=4)
+    {
+        RLOGD("length:%d, response:%s", length, response_raw);
+
+        sscanf(response_raw + length -4, "%2x", &(response->sw1));
+        sscanf(response_raw + length -2, "%2x", &(response->sw2));
+        RLOGD("sw1:%d, sw2:%d", response->sw1, response->sw2);
+
+#if 0
+        if(SW1_RSP_SEND_COMMANDS == response->sw1)
+        {
+            switch(response->sw2)
+            {
+                case SW2_RSP_RESET_MODEM:
+                {
+                    at_send_command("AT+CFUN=0", NULL);
+                    at_send_command("AT+CFUN=1", NULL);
+                    response->sw1 = SW1_RSP_SUCCESS;
+                    response->sw2 = SW2_RSP_SUCCESS;
+                    RLOGD("new sw1:%d, sw2:%d, and reset the module", response->sw1, response->sw2);
+                    break;
+                }
+            }
+        }
+#endif
+
+        if((SW1_RSP_SEND_COMMANDS == response->sw1 || SW1_RSP_SUCCESS == response->sw1) /*&& (SW2_RSP_SUCCESS == response->sw2)*/)
+        {
+            if(!strncmp(response_raw, "BF31", strlen("BF31")))
+            {
+                RLOGD("SIM card switch succeeded!");
+                //at_send_command("AT+CSIMDETECT", NULL);
+                at_send_command("AT+CFUN=0", NULL);
+                at_send_command("AT+CFUN=1", NULL);
+                RIL_onUnsolicitedResponse(RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0);
+            }
+        }
+
+        response->simResponse = strndup(response_raw, length - 4);
+        RLOGD("simResponse:%s", response->simResponse);
+    }
+    else
+    {
+        RLOGE("The data length is too short");
+        return RET_FAIL;
+    }
+
+    return RET_SUCCESS;
+}
+
+static void requestSimOpenChannel(void *data, size_t datalen, RIL_Token t)
+{
+    ATResponse *p_response = NULL;
+    int32_t session_id;
+    int err;
+    char cmd[SIM_CMD_MAX_SIZE];
+    char dummy;
+    char *line;
+
+    // Max length is 16 bytes according to 3GPP spec 27.007 section 8.45
+    if (data == NULL || datalen == 0 || datalen > 16) {
+        RLOGE("Invalid data passed to requestSimOpenChannel");
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        return;
+    }
+
+    RLOGD("data:%s, datalen:%d", data, datalen);
+    snprintf(cmd, sizeof(cmd), "AT+CCHO=\"%s\"", data);
+
+    err = at_send_command_singleline(cmd, "+CCHO:", &p_response);
+
+    if (err < 0 || p_response == NULL || p_response->success == 0) {
+        RLOGE("Error %d opening logical channel: %d",
+              err, p_response ? p_response->success : 0);
+        goto error;
+    }
+
+
+    // Ensure integer only by scanning for an extra char but expect one result
+    line = p_response->p_intermediates->line;
+    //RLOGD("line:%s", line);
+
+    err = at_tok_start(&line);
+    if(err < 0)
+        goto error;
+
+    err = at_tok_nextint(&line, &session_id);
+    if(err < 0)
+        goto error;
+
+    RLOGD("get session_id:%d", session_id);
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, &session_id, sizeof(&session_id));
+    at_response_free(p_response);
+    return;
+
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+    return;
+}
+
+
+static void requestSimCloseChannel(void *data, size_t datalen, RIL_Token t)
+{
+    ATResponse *p_response = NULL;
+    int32_t session_id;
+    int err;
+    char cmd[32];
+
+    if (data == NULL || datalen != sizeof(session_id)) {
+        RLOGE("Invalid data passed to requestSimCloseChannel");
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        return;
+    }
+    session_id = ((int32_t *)data)[0];
+
+    snprintf(cmd, sizeof(cmd), "AT+CCHC=%" PRId32, session_id);
+
+    err = at_send_command(cmd, &p_response);
+
+    if (err < 0 || p_response == NULL || p_response->success == 0) {
+        RLOGE("Error %d closing logical channel %d: %d",
+              err, session_id, p_response ? p_response->success : 0);
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        at_response_free(p_response);
+        return;
+    }
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+
+    at_response_free(p_response);
+}
+
+
+static void requestSimTransmitApduChannel(void *data,
+                                          size_t datalen,
+                                          RIL_Token t)
+{
+    ATResponse *p_response = NULL;
+    int err;
+    char *cmd;
+    char *line;
+    size_t cmd_size;
+    RIL_SIM_IO_Response sim_response;
+    RIL_SIM_APDU *apdu = (RIL_SIM_APDU *)data;
+
+    RLOGD("datalen:%d, sizeof(RIL_SIM_APDU):%d", datalen, sizeof(RIL_SIM_APDU));
+    if (apdu == NULL || datalen != sizeof(RIL_SIM_APDU)) {
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        return;
+    }
+
+    cmd_size = 10 + (apdu->data ? strlen(apdu->data) : 0);
+    //RLOGD("cmd_size:%d", cmd_size);
+
+    asprintf(&cmd, "AT+CGLA=%d,%zu,\"%02x%02x%02x%02x%02x%s\"",
+             apdu->sessionid, cmd_size, apdu->cla, apdu->instruction,
+             apdu->p1, apdu->p2, apdu->p3, apdu->data ? apdu->data : "");
+
+    err = at_send_command_singleline(cmd, "+CGLA", &p_response);
+    free(cmd);
+    if (err < 0 || p_response == NULL || p_response->success == 0) {
+        RLOGE("Error %d transmitting APDU: %d",
+              err, p_response ? p_response->success : 0);
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        at_response_free(p_response);
+        return;
+    }
+
+    line = p_response->p_intermediates->line;
+    err = parseSimResponseLine(line, &sim_response);
+
+    if (err == 0) {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS,
+                              &sim_response, sizeof(sim_response));
+    } else {
+        RLOGE("Error %d parsing SIM response line: %s", err, line);
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+    at_response_free(p_response);
+}
+
+/**
+ * Synchronous call from the RIL to us to return current radio state.
+ * RADIO_STATE_UNAVAILABLE should be the initial state.
+ */
+    static RIL_RadioState
+currentState()
+{
+    RLOGD("******** Enter %s ********", __FUNCTION__);
+    RLOGD("current state:%s", radioStateToString(sState));
+    RLOGD("******** Leave %s ********", __FUNCTION__);
+    return sState;
+}
+/**
+ * Call from RIL to us to find out whether a specific request code
+ * is supported by this implementation.
+ *
+ * Return 1 for "supported" and 0 for "unsupported"
+ */
+
+    static int
+onSupports (int requestCode __unused)
+{
+    //@@@ todo
+    RLOGD("******** Enter onSupports() ********");
+    return 1;
+}
+
+static void onCancel (RIL_Token t __unused)
+{
+    //@@@todo
+    RLOGD("******** Enter onCancel() ********");
+}
+/* modified by NODECOM-Aron for version control 2010.9.29 begin */
+static const char * getVersion(void)
+{
+    RLOGD("******** Enter getVersion() ********");
+
+    //<-- Get the REAL version number, and only change it each time you release the version
+    #define REAL_VERSION "V1.0.6"
+    //-->
+    RLOGD("********publish version ********");
+    int device_bit = 0;
+    char final_version[64]={0};
+
+    device_bit = (8 == sizeof(char *)?6:3);       //On 64-bit devices, Pointers take up 8 bytes
+
+    if(Ght_Android_Version >= ANDROID_MIN && Ght_Android_Version <= ANDROID_MAX)
+    {
+        sprintf(final_version,"Fibocom_RIL_V%dX.0%d.%s", Ght_Android_Version, device_bit, REAL_VERSION);
+    }
+    else
+    {
+        sprintf(final_version,"Fibocom_RIL_V%sX.0%d.%s", "E", device_bit, REAL_VERSION);
+    }
+
+    property_set("ril.fibocom.version", final_version);
+    return final_version;
+
+#if 0
+//<-- Gets the number of bits for the Android device, 32 or 64 bits
+#ifndef ODM_ARM64
+#define DEVICE_BIT "3"
+#else
+#define DEVICE_BIT "6"
+#endif
+//-->
+
+//<-- Gets the Android version, such as Android7,8,9, etc
+#ifdef GHT_FEATURE_ANDROID11X
+#define ANDROID_VER "11"
+#elif defined GHT_FEATURE_ANDROID10X
+#define ANDROID_VER "10"
+#elif defined GHT_FEATURE_ANDROID9X
+#define ANDROID_VER "9"
+#elif defined GHT_FEATURE_ANDROID8X
+#define ANDROID_VER "8"
+#elif defined GHT_FEATURE_ANDROID7X
+#define ANDROID_VER "7"
+#elif defined GHT_FEATURE_ANDROID6X
+#define ANDROID_VER "6"
+#elif defined GHT_FEATURE_ANDROID5X
+#define ANDROID_VER "5"
+#elif defined GHT_FEATURE_ANDROID4X
+#define ANDROID_VER "4"
+#else
+#define ANDROID_VER "E"               //An error occurs when the version number is "Fibocom_RIL_VEX..."
+#endif
+//-->
+#endif
+}
+/* modified by NODECOM-Aron for version control 2010.9.29 end */
+
+void setRadioState(RIL_RadioState newState)
+{
+    RIL_RadioState oldState;
+
+    RLOGD("******** Enter setRadioState() ********");
+
+    pthread_mutex_lock(&s_state_mutex);
+    RLOGD("Enter %s,oldState:%d(%s),newState:%d(%s),s_closed:%d", __FUNCTION__, sState, radioStateToString(sState), newState, radioStateToString(newState), s_closed);
+    oldState = sState;
+
+    if (s_closed > 0)
+    {
+        // If we're closed, the only reasonable state is
+        // RADIO_STATE_UNAVAILABLE
+        // This is here because things on the main thread
+        // may attempt to change the radio state after the closed
+        // event happened in another thread
+        newState = RADIO_STATE_UNAVAILABLE;
+    }
+
+    if (sState != newState || s_closed > 0)
+    {
+        sState = newState;
+
+        pthread_cond_broadcast (&s_state_cond);
+    }
+
+    pthread_mutex_unlock(&s_state_mutex);
+
+
+    /* do these outside of the mutex */
+    if (sState != oldState)
+    {
+        RIL_onUnsolicitedResponse (RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,
+                NULL, 0);
+
+        /* FIXME onSimReady() and onRadioPowerOn() cannot be called
+         * from the AT reader thread
+         * Currently, this doesn't happen, but if that changes then these
+         * will need to be dispatched on the request thread
+         */
+
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            if (sState == RADIO_STATE_ON)
+            {
+                onSIMReady();
+            }
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            if (sState == RADIO_STATE_SIM_READY)
+            {
+                onSIMReady();
+            }
+            else if (sState == RADIO_STATE_SIM_NOT_READY)
+            {
+                onRadioPowerOn();
+            }
+        }
+
+#if 0
+/* BEGIN: Added by abby.wang, 2019/01/03   PN:fix bug14047,can not recieve sms on Android8 */
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        if (sState == RADIO_STATE_ON)
+        {
+            onSIMReady();
+        }
+#else
+        if (sState == RADIO_STATE_SIM_READY)
+        {
+            onSIMReady();
+        }
+        else if (sState == RADIO_STATE_SIM_NOT_READY)
+        {
+            onRadioPowerOn();
+        }
+#endif
+/* END: Added by abby.wang, 2019/01/03   PN:fix bug14047,can not recieve sms on Android8 */
+#endif
+    }
+}
+/* BEGIN: Added by eric.li, 2018/10/14   PN:add for sim io parse */
+RIL_AppType getSIMType()
+{
+    RIL_AppType rslt = RIL_APPTYPE_UNKNOWN;
+    char* line = NULL;
+    ATResponse *atResponse = NULL;
+    int act = -1;
+
+    if(GHT_NL668 == mode_flag)
+    {
+        return RIL_APPTYPE_USIM;
+    }
+
+    int err = at_send_command_singleline("AT+GTUSIM?", "+GTUSIM:", &atResponse);
+    if (err < 0 || atResponse->success == 0) {
+    RLOGD("GTUSIM not support\r\n");
+    goto done;
+    }
+    
+    line = atResponse->p_intermediates->line;
+    err = at_tok_start(&line);
+    if(err < 0)
+        goto done;
+
+    err = at_tok_nextint(&line, &act);
+    if(err < 0)
+        goto done;
+
+    if(0 == act){
+        rslt = RIL_APPTYPE_SIM;
+    }else if(1 == act){
+        rslt = RIL_APPTYPE_USIM;
+    }
+
+ done:
+    at_response_free(atResponse);
+    return rslt;
+
+}
+
+const char *
+simStatusToString(SIM_Status s) {
+    switch(s) {
+        case SIM_ABSENT : return "SIM_ABSENT";
+        case SIM_NOT_READY: return "SIM_NOT_READY";
+        case SIM_READY: return "SIM_READY";
+        case SIM_PIN: return "SIM_PIN";
+        case SIM_PUK: return "SIM_PUK";
+        case SIM_NETWORK_PERSONALIZATION: return "SIM_NETWORK_PERSONALIZATION";
+        default: return "<unknown state>";
+    }
+}
+
+/* END:   Added by eric.li, 2018/10/14   PN:add for sim io parse */
+/** Returns SIM_NOT_READY on error */
+    SIM_Status
+getSIMStatus()
+{
+    ATResponse *p_response = NULL;
+    int err;
+    int ret;
+    char *cpinLine;
+    char *cpinResult;
+
+    RLOGD("******** Enter getSIMStatus() ********");
+    #if 0
+    if (sState == RADIO_STATE_OFF || sState == RADIO_STATE_UNAVAILABLE)
+    {
+        ret = SIM_NOT_READY;
+        goto done;
+    }
+    #endif
+
+    err = at_send_command_singleline("AT+CPIN?", "+CPIN:", &p_response);
+
+    if (err != 0)
+    {
+        ret = SIM_NOT_READY;
+        goto done;
+    }
+
+    switch (at_get_cme_error(p_response))
+    {
+        case CME_SUCCESS:
+            break;
+
+        case CME_SIM_NOT_INSERTED:
+
+	{
+		ret = SIM_ABSENT;
+	}
+			
+            goto done;
+        case SIGNAL_QCDATACARD_SIM_NOT_INSERTED:
+            ret = SIM_ABSENT;
+            goto done;
+
+        default:
+            ret = SIM_NOT_READY;
+            goto done;
+    }
+
+    /* CPIN? has succeeded, now look at the result */
+
+    cpinLine = p_response->p_intermediates->line;
+    err = at_tok_start (&cpinLine);
+
+    if (err < 0)
+    {
+        ret = SIM_NOT_READY;
+        goto done;
+    }
+
+    err = at_tok_nextstr(&cpinLine, &cpinResult);
+
+    if (err < 0)
+    {
+        ret = SIM_NOT_READY;
+        goto done;
+    }
+
+    if (0 == strcmp (cpinResult, "SIM PIN"))
+    {
+        ret = SIM_PIN;
+        goto done;
+    }
+    else if (0 == strcmp (cpinResult, "SIM PUK"))
+    {
+        ret = SIM_PUK;
+        goto done;
+    }
+    else if (0 == strcmp (cpinResult, "PH-NET PIN"))
+    {
+        return SIM_NETWORK_PERSONALIZATION;
+    }
+    else if (0 != strcmp (cpinResult, "READY"))
+    {
+        /* we're treating unsupported lock types as "sim absent" */
+        ret = SIM_ABSENT;
+        goto done;
+    }
+
+    at_response_free(p_response);
+    p_response = NULL;
+    cpinResult = NULL;
+
+    ret = SIM_READY;
+/* BEGIN: Added by eric.li, 2019/1/10   PN:0014627 android5 cannot enter sim init with property */
+    if (0 == gSimPostInitFlag && if_get_mode_flag == 1)
+    {
+	   odm_post_sim_init();
+	   RLOGD("odm_post_sim_init complete");
+    }
+    RLOGD("gSimPostInitFlag [%d]", gSimPostInitFlag);
+/* END:   Added by eric.li, 2019/1/10   PN:0014627 android5 cannot enter sim init with property */
+done:
+    at_response_free(p_response);
+    return ret;
+}
+
+
+/**
+ * Get the current card status.
+ *
+ * This must be freed using freeCardStatus.
+ * @return: On success returns RIL_E_SUCCESS
+ */
+static int getCardStatus(RIL_CardStatus_v6 **pp_card_status)
+{
+    static RIL_AppStatus app_status_array[] =
+    {
+        // SIM_ABSENT = 0
+        {
+            RIL_APPTYPE_UNKNOWN, RIL_APPSTATE_UNKNOWN, RIL_PERSOSUBSTATE_UNKNOWN,
+            NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN
+        },
+        // SIM_NOT_READY = 1
+        {
+            RIL_APPTYPE_SIM, RIL_APPSTATE_DETECTED, RIL_PERSOSUBSTATE_UNKNOWN,
+            NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN
+        },
+        // SIM_READY = 2
+        {
+            RIL_APPTYPE_SIM, RIL_APPSTATE_READY, RIL_PERSOSUBSTATE_READY,
+            NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN
+        },
+        // SIM_PIN = 3
+        {
+            RIL_APPTYPE_SIM, RIL_APPSTATE_PIN, RIL_PERSOSUBSTATE_UNKNOWN,
+            NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN
+        },
+        // SIM_PUK = 4
+        {
+            RIL_APPTYPE_SIM, RIL_APPSTATE_PUK, RIL_PERSOSUBSTATE_UNKNOWN,
+            NULL, NULL, 0, RIL_PINSTATE_ENABLED_BLOCKED, RIL_PINSTATE_UNKNOWN
+        },
+        // SIM_NETWORK_PERSONALIZATION = 5
+        {
+            RIL_APPTYPE_SIM, RIL_APPSTATE_SUBSCRIPTION_PERSO, RIL_PERSOSUBSTATE_SIM_NETWORK,
+            NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN
+        },
+//#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+/*Begin: Wujiabao changed it to '#if 1' in 2022/07/20*/
+#if 1
+/*End:   Wujiabao changed it to '#if 1' in 2022/07/20*/
+        // RUIM_ABSENT = 6
+        { RIL_APPTYPE_UNKNOWN, RIL_APPSTATE_UNKNOWN, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // RUIM_NOT_READY = 7
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_DETECTED, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // RUIM_READY = 8
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_READY, RIL_PERSOSUBSTATE_READY,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // RUIM_PIN = 9
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_PIN, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN },
+        // RUIM_PUK = 10
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_PUK, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_BLOCKED, RIL_PINSTATE_UNKNOWN },
+        // RUIM_NETWORK_PERSONALIZATION = 11
+        { RIL_APPTYPE_RUIM, RIL_APPSTATE_SUBSCRIPTION_PERSO, RIL_PERSOSUBSTATE_SIM_NETWORK,
+           NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN },
+        // ISIM_ABSENT = 12
+        { RIL_APPTYPE_UNKNOWN, RIL_APPSTATE_UNKNOWN, RIL_PERSOSUBSTATE_UNKNOWN,
+           NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // ISIM_NOT_READY = 13
+        { RIL_APPTYPE_ISIM, RIL_APPSTATE_DETECTED, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // ISIM_READY = 14
+        { RIL_APPTYPE_ISIM, RIL_APPSTATE_READY, RIL_PERSOSUBSTATE_READY,
+          NULL, NULL, 0, RIL_PINSTATE_UNKNOWN, RIL_PINSTATE_UNKNOWN },
+        // ISIM_PIN = 15
+        { RIL_APPTYPE_ISIM, RIL_APPSTATE_PIN, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN },
+        // ISIM_PUK = 16
+        { RIL_APPTYPE_ISIM, RIL_APPSTATE_PUK, RIL_PERSOSUBSTATE_UNKNOWN,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_BLOCKED, RIL_PINSTATE_UNKNOWN },
+        // ISIM_NETWORK_PERSONALIZATION = 17
+        { RIL_APPTYPE_ISIM, RIL_APPSTATE_SUBSCRIPTION_PERSO, RIL_PERSOSUBSTATE_SIM_NETWORK,
+          NULL, NULL, 0, RIL_PINSTATE_ENABLED_NOT_VERIFIED, RIL_PINSTATE_UNKNOWN },
+#endif
+    };
+    RIL_CardState card_state;
+    int num_apps;
+    int sim_status;
+
+    RLOGD("******** Enter getCardStatus() ********");
+
+    sim_status = getSIMStatus();
+    /* BEGIN: Added by eric.li, 2018/12/25   PN:gSimstatus to trace sim status */
+    gSimStatus = sim_status;
+    RLOGD("gSimStatus:%d(%s)", gSimStatus, simStatusToString(gSimStatus));
+    /* END:   Added by eric.li, 2018/12/25   PN:gSimstatus to trace sim status */
+    if (sim_status == SIM_ABSENT)
+    {
+        card_state = RIL_CARDSTATE_ABSENT;
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            num_apps = 3;
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            num_apps = 1;
+        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+			num_apps = 3;
+#else
+			num_apps = 1;
+#endif
+#endif
+    }
+    else
+    {
+        card_state = RIL_CARDSTATE_PRESENT;
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            num_apps = 3;
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            num_apps = 1;
+        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+                num_apps = 3;
+#else
+                num_apps = 1;
+#endif
+#endif
+
+    }
+
+    // Allocate and initialize base card status.
+    RIL_CardStatus_v6 *p_card_status = malloc(sizeof(RIL_CardStatus_v6));
+    memset(p_card_status, 0, sizeof(RIL_CardStatus_v6));
+
+    p_card_status->card_state = card_state;
+    p_card_status->universal_pin_state = RIL_PINSTATE_UNKNOWN;
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        p_card_status->gsm_umts_subscription_app_index = -1;
+        p_card_status->cdma_subscription_app_index = -1;
+        p_card_status->ims_subscription_app_index = -1;
+    }
+    else
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        p_card_status->gsm_umts_subscription_app_index = RIL_CARD_MAX_APPS;
+        p_card_status->cdma_subscription_app_index = RIL_CARD_MAX_APPS;
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    p_card_status->gsm_umts_subscription_app_index = -1;
+    p_card_status->cdma_subscription_app_index = -1;
+    p_card_status->ims_subscription_app_index = -1;
+#else
+    p_card_status->gsm_umts_subscription_app_index = RIL_CARD_MAX_APPS;
+    p_card_status->cdma_subscription_app_index = RIL_CARD_MAX_APPS;
+#endif
+#endif
+
+    p_card_status->num_applications = num_apps;
+    RIL_AppType apptype = getSIMType();
+    /*begin:modified for when sim status is SIM_ABSENT,RIL7 will restart by lisf 20181124*/
+    if(sim_status == SIM_ABSENT)
+    {
+	apptype = RIL_APPTYPE_UNKNOWN;
+    }
+    /*end:modified for when sim status is SIM_ABSENT,RIL7 will restart by lisf 20181124*/
+    RLOGD("sim_type = %d", apptype);
+    // Initialize application status
+    int i;
+    for (i = 0; i < RIL_CARD_MAX_APPS; i++)
+    {
+        p_card_status->applications[i] = app_status_array[SIM_ABSENT];
+    }
+
+    // Pickup the appropriate application status
+    // that reflects sim_status for gsm.
+    if (num_apps != 0)
+    {
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            p_card_status->num_applications = 3;
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            p_card_status->num_applications = 1;
+        }
+
+#if 0
+        // Only support one app, gsm
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        p_card_status->num_applications = 3;
+ #else
+         p_card_status->num_applications = 1;
+#endif
+#endif
+        p_card_status->gsm_umts_subscription_app_index = 0;
+
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            p_card_status->cdma_subscription_app_index = 1;
+            p_card_status->ims_subscription_app_index = 2;
+        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        p_card_status->cdma_subscription_app_index = 1;
+        p_card_status->ims_subscription_app_index = 2;
+#endif
+#endif
+        // Get the correct app status
+        p_card_status->applications[0] = app_status_array[sim_status];
+		p_card_status->applications[0].app_type = apptype;
+
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            p_card_status->applications[1] = app_status_array[sim_status + 6];
+            p_card_status->applications[2] = app_status_array[sim_status + 12];
+        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        p_card_status->applications[1] = app_status_array[sim_status + 6];
+        p_card_status->applications[2] = app_status_array[sim_status + 12];
+#endif
+#endif
+    }
+
+    *pp_card_status = p_card_status;
+    return RIL_E_SUCCESS;
+}
+
+/**
+ * Free the card status returned by getCardStatus
+ */
+static void freeCardStatus(RIL_CardStatus_v6 *p_card_status)
+{
+    RLOGD("******** Enter freeCardStatus() ********");
+    free(p_card_status);
+}
+
+/**
+ * SIM ready means any commands that access the SIM will work, including:
+ *  AT+CPIN, AT+CSMS, AT+CNMI, AT+CRSM
+ *  (all SMS-related commands)
+ */
+
+static void pollSIMState (void *param __unused)
+{
+    RLOGD("******** Enter pollSIMState() ********");
+
+    if (sState != RADIO_STATE_SIM_NOT_READY)
+    {
+        // no longer valid to poll
+        return;
+    }
+
+    switch(getSIMStatus())
+    {
+        case SIM_ABSENT:
+        case SIM_PIN:
+        case SIM_PUK:
+        case SIM_NETWORK_PERSONALIZATION:
+        default:
+            setRadioState(RADIO_STATE_SIM_LOCKED_OR_ABSENT);
+            /* BEGIN: Added by eric.li, 2019/1/21   PN:solve issue that can not receive sms issues with probability */
+            gSimPostInitFlag = 0;
+            /* END:   Added by eric.li, 2019/1/21   PN:solve issue that can not receive sms issues with probability */
+            return;
+
+        case SIM_NOT_READY:
+            RIL_requestTimedCallback (pollSIMState, NULL, &TIMEVAL_SIMPOLL);
+            /* BEGIN: Added by eric.li, 2019/1/21   PN:solve issue that can not receive sms issues with probability */
+            gSimPostInitFlag = 0;
+            /* END:   Added by eric.li, 2019/1/21   PN:solve issue that can not receive sms issues with probability */
+            return;
+
+        case SIM_READY:
+            setRadioState(RADIO_STATE_SIM_READY);
+            return;
+    }
+}
+
+/** returns 1 if on, 0 if off, and -1 on error */
+static int isRadioOn()
+{
+    ATResponse *p_response = NULL;
+    int err;
+    char *line;
+    char ret;
+
+    RLOGD("******** Enter isRadioOn() ********");
+
+    err = at_send_command_singleline("AT+CFUN?", "+CFUN:", &p_response);
+
+    if (err < 0 || p_response->success == 0)
+    {
+        // assume radio is off
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    err = at_tok_nextbool(&line, &ret);
+    if (err < 0) goto error;
+
+    at_response_free(p_response);
+
+    return (int)ret;
+
+error:
+
+    at_response_free(p_response);
+    return -1;
+}
+
+//return value
+//0-----3GPP
+//1-----3GPP2
+int parse_technology_response(const char *response)
+{
+    int err;
+    char *line;
+    int tec;
+    int skip;
+    line = strdup(response);
+    RLOGD("parse_technology_response line=%s",line);
+    err = at_tok_start(&line);
+    if (err < 0)
+    {
+        RLOGD("tok_start err");
+        return 0;
+    }
+    err = at_tok_nextint(&line, &skip);
+    if (err < 0)
+    {
+        RLOGD("skip err");
+        return 0;
+    }
+    err = at_tok_nextint(&line, &tec);
+    if (err < 0)
+    {
+        RLOGD("tec err");
+        return 0;
+    }
+    if(12 == tec)
+    {
+        RLOGD("CDMA");
+        return 6;
+    }
+    else if((13 == tec) || (14 == tec) || (15 == tec))
+    {
+        RLOGD("EVDO");
+        return 8;
+    }
+    else if((1 == tec) || (2 == tec) || (3 == tec))
+    {
+        RLOGD("GSM");
+        return 1;
+    }
+    else if((9 == tec) || (10 == tec) || (11 == tec))
+    {
+        RLOGD("LTE");
+        return 14;
+    }
+    else
+    {    RLOGD("HSPA");
+        return 11;
+    }
+}
+
+
+static void waitForClose()
+{
+    RLOGD("******** Enter waitForClose() ********");
+
+    pthread_mutex_lock(&s_state_mutex);
+
+    while (s_closed == 0)
+    {
+        pthread_cond_wait(&s_state_cond, &s_state_mutex);
+    }
+
+    pthread_mutex_unlock(&s_state_mutex);
+    RLOGD("******** Leave waitForClose() ********");
+}
+
+
+/* Called on command or reader thread */
+static void onATReaderClosed()
+{
+    RLOGD("******** Enter onATReaderClosed() ********");
+    at_close();
+    s_closed = 1;
+
+    setRadioState (RADIO_STATE_UNAVAILABLE);
+    RLOGD("AT channel closed\n");
+}
+
+/* Called on command thread */
+static void onATTimeout()
+{
+    RLOGD("******** Enter onATTimeout() ********");
+    at_close();
+
+    s_closed = 1;
+
+    /* FIXME cause a radio reset here */
+
+    setRadioState (RADIO_STATE_UNAVAILABLE);
+    RLOGD("AT channel timeout; closing exit rild reset modem!\n");
+    //system("echo at+reset > /dev/ttyUSB3");
+    usleep(100000);
+    //system("echo at+reset > /dev/ttyUSB1");
+    //qualcomm_diag_reset();
+    exit(EXIT_FAILURE);
+}
+
+static void usage(char *s __unused)
+{
+    RLOGD("******** Enter usage() ********");
+#ifdef RIL_SHLIB
+#ifdef HAVE_DATA_DEVICE
+    fprintf(stderr, "reference-ril requires: -p <tcp port> or -d /dev/tty_device -m /dev/data_device -t type\n");
+#else
+    fprintf(stderr, "reference-ril requires: -p <tcp port> or -d /dev/tty_device\n");
+#endif
+#else
+    fprintf(stderr, "usage: %s [-p <tcp port>] [-d /dev/tty_device]\n", s);
+    exit(-1);
+#endif
+}
+
+
+
+/**
+ * Initialize everything that can be configured while we're still in
+ * AT+CFUN=0
+ */
+void initializeCallback(void *param __unused)
+{
+    ATResponse *p_response = NULL;
+    int err;
+
+    RLOGD("******** Enter initializeCallback() ********");
+
+    setRadioState (RADIO_STATE_OFF);
+
+    at_handshake();
+    // <!--[ODM]wangmengying@2019.8.16 [SN-20190712001,SN-20190608001]optimization ppp time
+    //sleep(3);
+    // end-->
+    /* note: we don't check errors here. Everything important will
+       be handled in onATTimeout and onATReaderClosed */
+
+    /*  atchannel is tolerant of echo but it must */
+    /*  have verbose result codes */
+    //at_send_command("ATE0Q0V1", NULL);
+    at_send_command("ATE0", NULL);
+    at_send_command("ATQ0", NULL);
+    at_send_command("ATV1", NULL);
+
+    /*  No auto-answer */
+    at_send_command("ATS0=0",NULL);
+
+    /*  Extended errors */
+	/*begin: Modified by lisf for NL668-CN-00 mantis 0012816 & mantis 0012820*/
+	at_send_command("AT+CMEE=1", NULL);
+	/*end: Modified by lisf for NL668-CN-00 mantis 0012816 & mantis 0012820*/
+
+#ifdef V35_Normal_Version_to_open_CREG
+
+    /*  Network registration events */
+    err = at_send_command("AT+CREG=2", &p_response);
+
+    /* some handsets -- in tethered mode -- don't support CREG=2 */
+    if (err < 0 || p_response->success == 0)
+    {
+        at_send_command("AT+CREG=1", NULL);
+    }
+
+    at_response_free(p_response);
+#endif
+
+    /*  GPRS registration events */
+    at_send_command("AT+CGREG=2", NULL);
+
+    at_send_command("AT+CEREG=2", NULL);
+
+    /*  Call Waiting notifications */
+    at_send_command("AT+CCWA=1", NULL);
+
+    /*  Alternating voice/data off */
+    at_send_command("AT+CMOD=0", NULL);
+
+    //at_send_command("AT+NWMINDEN=0", NULL);
+    /*  Not muted */
+    //   at_send_command("AT+CMUT=0", NULL);     /*for MF226, there is no audio, masked*/
+
+    /*  +CSSU unsolicited supp service notifications */
+    at_send_command("AT+CSSN=0,1", NULL);
+
+    /*  no connected line identification */
+    at_send_command("AT+COLP=0", NULL);
+
+    /*  HEX character set */
+    //add by NODECOM pulong
+    //at_send_command("AT+CSCS=\"HEX\"", NULL);
+    at_send_command("AT+CSCS=\"IRA\"", NULL);
+
+    /*  USSD unsolicited */
+    at_send_command("AT+CUSD=1", NULL);
+
+    /*  Enable +CGEV GPRS event notifications, but don't buffer */
+    at_send_command("AT+CGEREP=2,1", NULL);
+
+    /*  SMS PDU mode */
+    at_send_command("AT$QCMGF=0", NULL);
+
+    at_send_command("AT+CMGF=0", NULL);
+
+    at_send_command("AT+CAVIMS=1", NULL);
+
+#ifdef SIGNAL_MODEM
+    //at_send_command("AT+CGDCONT=2", NULL);
+    at_send_command("AT+CGDCONT=3", NULL);
+    at_send_command("AT+CGDCONT=4", NULL);
+    at_send_command("AT+CGDCONT=5", NULL);
+#endif
+
+    if(mode_flag == GHT_L716)
+    {
+        at_send_command("AT+GTRNDIS=0,1", NULL);
+    }
+#ifdef USE_TI_COMMANDS
+    at_send_command("AT%CPI=3", NULL);
+
+    /*  TI specific -- notifications when SMS is ready (currently ignored) */
+    at_send_command("AT%CSTAT=1", NULL);
+
+#endif /* USE_TI_COMMANDS */
+/* BEGIN: Added by eric.li, 2018/10/12   PN:fix bug 0010804 for problems answer call inwhen ppp connected  */
+    at_send_command("AT+GTSET=\"CALLBREAK\",0", NULL);
+/* END:   Added by eric.li, 2018/10/12   PN:fix bug 0010804 for problems answer call inwhen ppp connected  */
+
+// <!--modified by wangyi@2018.07.13 for optimizing time consuming of network available after radio power-on
+    //at_send_command("ATH", NULL);
+    //sleep(5);
+// end-->
+
+// <!--[ODM]wangmengying@2019.8.16 [SN-20190608001]Customized AT commands
+    initReserveAtCommand();
+// end-->
+
+    /* assume radio is off on error */
+    if (isRadioOn() > 0)
+    {
+
+        if(ANDROID_4 == Ght_Android_Version || ANDROID_6 == Ght_Android_Version)
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d == 4 or == 6 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            setRadioState (RADIO_STATE_SIM_NOT_READY);
+        }
+        else
+        {
+            setRadioState (RADIO_STATE_ON);
+        }
+
+#if 0
+// <!--[ODM]wangmengying@2019.10.31 fix bug31873,Android8 may be called is not at the beginning and needs to be set RADIO_STATE_ON
+#if defined GHT_FEATURE_ANDROID6X || defined GHT_FEATURE_ANDROID4X
+        setRadioState (RADIO_STATE_SIM_NOT_READY);
+#else
+        setRadioState (RADIO_STATE_ON);
+#endif
+// end-->
+#endif
+
+/* BEGIN: Added by eric.li, 2019/1/21   PN:solve issue that can not receive sms issues with probability */
+     if (1 == gSimPostInitFlag)
+     {
+        //in android6 need reset this flag to push CNMI send down to modem
+        gSimPostInitFlag = 0;
+     }
+/* END:   Added by eric.li, 2019/1/21   PN:solve issue that can not receive sms issues with probability */
+    }
+}
+
+
+/*** Callback methods from the RIL library to us ***/
+/**
+ * Call from RIL to us to make a RIL_REQUEST
+ *
+ * Must be completed with a call to RIL_onRequestComplete()
+ *
+ * RIL_onRequestComplete() may be called from any thread, before or after
+ * this function returns.
+ *
+ * Will always be called from the same thread, so returning here implies
+ * that the radio is ready to process another command (whether or not
+ * the previous command has completed).
+ */
+
+    static void
+onRequest (int request, void *data, size_t datalen, RIL_Token t)
+{
+    static int sn = 0;
+
+
+    /* Ignore all requests except RIL_REQUEST_GET_SIM_STATUS
+     * when RADIO_STATE_UNAVAILABLE.
+     */
+    RLOGD("********%3d, onRequest(%d): %s********", sn, request,requestToString(request));
+    sn++;
+    if (sState == RADIO_STATE_UNAVAILABLE
+            && request != RIL_REQUEST_GET_SIM_STATUS
+       )
+    {
+        RLOGD("state is unavailable and not get sim status");
+        RIL_onRequestComplete(t, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
+        return;
+    }
+
+    /* Ignore all non-power requests when RADIO_STATE_OFF
+     * (except RIL_REQUEST_GET_SIM_STATUS)
+     */
+     /* 
+     *Added by eric.li, 2018/10/22 
+     *(except RIL_REQUEST_GET_RADIO_CAPABILITY)
+     *(except RIL_REQUEST_BASEBAND_VERSION)
+     *(except RIL_REQUEST_GET_IMEI)
+     *(except RIL_REQUEST_GET_IMEISV)
+     *End
+     *Added by eric.li, 2018/12/30
+     *(except RIL_REQUEST_GET_IMSI)
+     *to solve issue 0014143,set prefered network with unkonw operator when exption happened
+     *End
+     */
+    if (sState == RADIO_STATE_OFF
+            && !(request == RIL_REQUEST_RADIO_POWER
+                || request == RIL_REQUEST_GET_SIM_STATUS
+                #if (RIL_VERSION > 9)
+                || request == RIL_REQUEST_GET_RADIO_CAPABILITY
+                #endif
+//#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+/*Begin: Wujiabao changed it to '#if 1' in 2022/07/20*/
+#if 1
+/*End:   Wujiabao changed it to '#if 1' in 2022/07/20*/
+                || request == RIL_REQUEST_DEVICE_IDENTITY
+ #endif
+                || request == RIL_REQUEST_GET_IMEI
+                || request == RIL_REQUEST_GET_IMEISV
+                || request == RIL_REQUEST_BASEBAND_VERSION
+                || request == RIL_REQUEST_GET_IMSI)
+       )
+    {
+        RLOGD("state is off and request is not radio_power or get sim status");
+        RIL_onRequestComplete(t, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
+        return;
+    }
+
+
+    /**
+     * we re-order the request by its function
+     * the first part is initialize
+     * the second part is sim
+     * the third part is network
+     * the fourth part other function, such as IMEIBaseBandVersion and so on
+     * the fifth part is sms
+     * the sixth part is voice
+     */
+
+    switch (request)
+    {
+        /**
+         * the first part : initialize
+         */
+        case RIL_REQUEST_GET_SIM_STATUS:
+            {
+                requestGetSimStatus(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_RADIO_POWER:
+            {
+                requestRadioPower(data, datalen, t);
+                break;
+            }
+            /**
+             * the second part : sim
+             */
+
+        case RIL_REQUEST_SIM_IO:
+            {   //add by zhengjianrong for MA510 RIL BEGIN
+                if(mode_flag == GHT_M910_GL || mode_flag == GHT_MA510_GL){
+                //add by zhengjianrong for MA510 RIL END
+                    requestSIM_IO_M910(data,datalen,t);
+                }
+                else{
+                    requestSIM_IO(data,datalen,t);
+                }
+                break;
+            }
+
+        case RIL_REQUEST_QUERY_FACILITY_LOCK:
+            {
+                requestQueryFacilityLock(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_SET_FACILITY_LOCK:
+            {
+                requestSetFacilityLock(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_ENTER_SIM_PIN:
+        case RIL_REQUEST_ENTER_SIM_PUK:
+        case RIL_REQUEST_ENTER_SIM_PIN2:
+        case RIL_REQUEST_ENTER_SIM_PUK2:
+            {
+                //requestEnterSimPin(data, datalen, t);
+                requestEnterSimPin(request, data, datalen, t);
+                break;
+            }
+        case RIL_REQUEST_CHANGE_SIM_PIN:
+        case RIL_REQUEST_CHANGE_SIM_PIN2:
+            {
+                //requestChangeSimPin(data, datalen, t);
+                requestChangeSimPin(request, data, datalen, t);
+                break;
+            }
+            //Aron modified for sim pin and puk 20101122 end
+
+
+            /**
+             * the third part : network
+             */
+
+        case RIL_REQUEST_SIGNAL_STRENGTH:
+            {
+/*                if(mode_flag == GHT_FG650)
+                    requestSignalStrength_CESQ(data, datalen, t);
+                else
+*/
+                    requestSignalStrength_Generic(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
+        case RIL_REQUEST_DATA_REGISTRATION_STATE:
+            {
+                if(mode_flag == GHT_M910_GL || mode_flag == GHT_MA510_GL)
+                {
+                    requestRegistrationStateM910(request, data, datalen, t);
+                }
+                else
+                {
+                    requestRegistrationState(request, data, datalen, t);
+                }
+                break;
+            }
+
+        case RIL_REQUEST_OPERATOR:
+            {
+                if(mode_flag == GHT_L610 || GHT_MC919 == mode_flag || GHT_MC66x == mode_flag)
+                {
+                    requestOperator(data, datalen, t);
+                }
+                else
+                {
+                    requestOperator_Generic(data, datalen, t);
+                }
+                break;
+            }
+#if (RIL_VERSION != 7)
+        case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
+            {   //add by zhengjianrong for MA510 RIL BEGIN
+                if(mode_flag == GHT_M910_GL || mode_flag == GHT_MA510_GL){
+                //add by zhengjianrong for MA510 RIL END
+                    requestSetInitialAttachAPNM910(data, datalen, t);
+                }
+                else{
+                    requestSetInitialAttachAPN(data, datalen, t);
+                }
+                break;
+            }
+#endif
+        case RIL_REQUEST_SETUP_DATA_CALL:
+            {
+                requestSetupDataCall(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_DEACTIVATE_DATA_CALL:
+            {
+                requestDeactivateDataCall(data, datalen, t);
+                break;
+            }
+        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
+            {
+                requestSetNetworkSelectionAutomatic(t);
+                break;
+            }
+
+        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
+            {
+                requestSetNetworkSelectionManual(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
+            {
+
+                /*TODO*/
+                RLOGD("set preferred network type: %d", ((int *)data)[0]);    // debug ++
+                //add by zhengjianrong for MA510 RIL BEGIN
+                if(mode_flag == GHT_M910_GL || mode_flag == GHT_757S || mode_flag == GHT_MA510_GL)
+                //add by zhengjianrong for MA510 RIL END
+                {
+                    requestSetPreferredNetworkType_M910(data, datalen,t);
+                }
+                else if(GTRAT_Support_Flag)
+                {
+                    requestSetPreferredNetworkType(data, datalen, t);
+                }
+                else
+                {
+                    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+                }
+                break;
+            }
+
+        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
+            {   //add by zhengjianrong for MA510 RIL BEGIN
+                if(mode_flag == GHT_M910_GL || mode_flag == GHT_757S || mode_flag == GHT_MA510_GL){
+                //add by zhengjianrong for MA510 RIL END
+                    requestGetPreferredNetworkTypeM910(data, datalen, t);
+                }
+                else if(GTRAT_Support_Flag)
+                {
+                    requestGetPreferredNetworkType(data, datalen, t);
+                }
+                else
+                {
+                    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+                }
+                break;
+            }
+
+        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
+            {
+                requestQueryAvailableNetworks(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
+            {
+                 requestNeighboringCellIds(data,datalen,t);
+                 break;
+            }
+        case RIL_REQUEST_GET_CELL_INFO_LIST:
+            {
+                requestGetCellInfoList(data, datalen, t);
+            }
+            break;
+
+        case RIL_REQUEST_DATA_CALL_LIST:
+            {
+                requestDataCallList(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
+            {
+                requestQueryNetworkSelectionMode(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_SET_LOCATION_UPDATES:
+            {
+                requestSetLocationUpdates(data,datalen,t);
+                break;
+            }
+        case RIL_REQUEST_SCREEN_STATE:
+            {
+                requestScreenState(data, datalen, t);
+                break;
+            }
+
+            /**
+             * the fourth part : other function, such as IMEIBaseBandVersion and so on
+             */
+
+        case RIL_REQUEST_GET_IMSI:
+            {
+		  if(RADIO_STATE_OFF != sState)
+		  {
+                   requestGetIMSI(data,datalen,t);
+		  }
+		  else
+		  {
+        		RIL_onRequestComplete(t, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
+		  }
+                break;
+            }
+
+        case RIL_REQUEST_GET_IMEISV:
+            {
+                if(GHT_H330S == mode_flag)
+                    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+                else
+                    requestGetIMEISV(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_GET_IMEI:
+            {
+                requestGetIMEI(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_SEND_USSD:
+            {
+                requestSendUSSD(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_CANCEL_USSD:
+            {
+                requestCancelUSSD(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_BASEBAND_VERSION:
+            {
+                requestBasebandVersion(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_OEM_HOOK_RAW:
+            {
+                // echo back data
+                RIL_onRequestComplete(t, RIL_E_SUCCESS, data, datalen);
+                break;
+            }
+
+        case RIL_REQUEST_OEM_HOOK_STRINGS:
+            {
+                requestOemHookStrings(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_QUERY_CLIP:
+            {
+                requestQueryClip(data, datalen, t);
+                break;
+            }
+
+            /**
+             * the fifth part : sms
+             */
+
+        case RIL_REQUEST_SEND_SMS:
+            {
+                requestSendSMS(data, datalen, t);
+                break;
+            }
+/* BEGIN: Added by eric.li, 2019/1/9   PN:add support for send more message */
+       case  RIL_REQUEST_SEND_SMS_EXPECT_MORE:
+	     {
+	      if(mode_flag == GHT_FG650)
+		  	requestSendSMS(data, datalen, t);
+		  else
+		    requestSendSMSExpectMore(data, datalen, t);
+		  break;
+	     }
+/* END:   Added by eric.li, 2019/1/9   PN:add support for send more message */
+
+        case RIL_REQUEST_SMS_ACKNOWLEDGE:
+            {
+                requestSMSAcknowledge(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_WRITE_SMS_TO_SIM:
+            {
+                requestWriteSmsToSim(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_DELETE_SMS_ON_SIM:
+            {
+                requestDeleteSmsOnSim(data, datalen, t);
+                break;
+            }
+#if 1
+        case RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG:
+            {
+		#if (RIL_VERSION  > 11)
+		/* BEGIN: Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+		if (SIM_READY != gSimStatus)
+		{
+	            RIL_onRequestComplete( t, RIL_E_INVALID_STATE, NULL, 0 );	
+		}else
+        #endif
+		{
+		/* END:   Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+                requestGsmGetBroadcastSMSConfig(data, datalen, t);
+		}
+                break;
+            }
+
+        case RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG:
+            {
+	#if (RIL_VERSION  > 11)
+		/* BEGIN: Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+		if (SIM_READY != gSimStatus)
+		{
+	            RIL_onRequestComplete( t, RIL_E_INVALID_STATE, NULL, 0 );	
+		}
+        else
+	#endif
+		{
+		/* END:   Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+                requestGsmSetBroadcastSMSConfig(data, datalen, t);
+		}
+                break;
+            }
+
+        case RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION:
+            {
+	#if (RIL_VERSION  > 11)
+		/* BEGIN: Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+		if (SIM_READY != gSimStatus)
+		{
+	            RIL_onRequestComplete( t, RIL_E_INVALID_STATE, NULL, 0 );	
+		}else
+	#endif
+		{
+		/* END:   Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+                requestGsmSMSBroadcastActivation(data, datalen, t);
+		}
+                break;
+            }
+
+        case RIL_REQUEST_GET_SMSC_ADDRESS:
+            {
+	#if (RIL_VERSION  > 11)
+		/* BEGIN: Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+		if (SIM_READY != gSimStatus)
+		{
+	            RIL_onRequestComplete( t, RIL_E_INVALID_STATE, NULL, 0 );	
+		}else
+	#endif
+		{
+		/* END:   Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+                requestGetSMSCAddress(data, datalen, t);
+		}
+                break;
+            }
+
+        case RIL_REQUEST_SET_SMSC_ADDRESS:
+            {
+	#if (RIL_VERSION  > 11)
+		/* BEGIN: Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+		if (SIM_READY != gSimStatus)
+		{
+	            RIL_onRequestComplete( t, RIL_E_INVALID_STATE, NULL, 0 );	
+		}else
+	#endif
+		{
+		/* END:   Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+                requestSetSMSCAddress(data, datalen, t);
+		}
+                break;
+            }
+
+        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
+            {
+	#if (RIL_VERSION  > 11)
+		/* BEGIN: Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+		if (SIM_READY != gSimStatus)
+		{
+	            RIL_onRequestComplete( t, RIL_E_INVALID_STATE, NULL, 0 );	
+		}else
+	#endif
+		{
+		/* END:   Modified by eric.li, 2018/12/25   PN:if sim status is not ready,including pin/puk, force return back */
+                requestReportSMSMemoryStatus(data, datalen, t);
+		}
+                break;
+            }
+
+#endif
+
+            /**
+             * the sixth part : voice
+             */
+        case RIL_REQUEST_GET_CURRENT_CALLS:
+            {
+                if(Voice_Support_Flag && getProfileBool("AT", "CLCC", true))
+                {
+                    requestGetCurrentCalls(data, datalen, t);
+                }
+                else
+                {
+                    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+                }
+                break;
+            }
+
+        case RIL_REQUEST_DIAL:
+            {
+                if(Voice_Support_Flag)
+                {
+                    requestDial(data, datalen, t);
+                }
+                else
+                {
+                    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+                }
+                break;
+            }
+
+        case RIL_REQUEST_HANGUP:
+            {
+                requestHangup(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
+            {
+                // 3GPP 22.030 6.5.5
+                // "Releases all held calls or sets User Determined User Busy
+                //  (UDUB) for a waiting call."
+                //at_send_command("AT+CHLD=0", NULL);
+                /* at_send_command("AT+CHUP", NULL);*/
+                /* success or failure is ignored by the upper layer here.
+                   it will call GET_CURRENT_CALLS and determine success that way */
+                /* RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0); */
+                requestHangupWaitingOrBackground(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
+            {
+                // 3GPP 22.030 6.5.5
+                // "Releases all active calls (if any exist) and accepts
+                //  the other (held or waiting) call."
+                //at_send_command("AT+CHLD=1", NULL);
+                /* at_send_command("AT+CHUP", NULL);*/
+                /* success or failure is ignored by the upper layer here.
+                   it will call GET_CURRENT_CALLS and determine success that way */
+                /*RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);*/
+                requestHangupForegroundResumeBackground(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
+            {
+                // 3GPP 22.030 6.5.5
+                // "Places all active calls (if any exist) on hold and accepts
+                //  the other (held or waiting) call."
+                /* at_send_command("AT+CHLD=2", NULL); */
+
+                /*
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+s_expectAnswer = 1;
+#endif*/  /* WORKAROUND_ERRONEOUS_ANSWER */
+
+                /* success or failure is ignored by the upper layer here.
+                   it will call GET_CURRENT_CALLS and determine success that way */
+                /* RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);*/
+                requestSwitchWaitingOrHoldingAndActive(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_ANSWER:
+            {
+                /* at_send_command("ATA", NULL);*/
+                /*
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+s_expectAnswer = 1;
+#endif */ /* WORKAROUND_ERRONEOUS_ANSWER */
+
+                /* success or failure is ignored by the upper layer here.
+                   it will call GET_CURRENT_CALLS and determine success that way */
+                /*RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);*/
+                requestAnswer(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_CONFERENCE:
+            {
+                // 3GPP 22.030 6.5.5
+                // "Adds a held call to the conversation"
+                /* at_send_command("AT+CHLD=3", NULL);*/
+
+                /* success or failure is ignored by the upper layer here.
+                   it will call GET_CURRENT_CALLS and determine success that way */
+                /* RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0); */
+                requestConference(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_UDUB:
+            {
+                /* user determined user busy */
+                /* sometimes used: ATH */
+                /* at_send_command("ATH", NULL); */
+
+                /* success or failure is ignored by the upper layer here.
+                   it will call GET_CURRENT_CALLS and determine success that way */
+                /* RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);*/
+                requestUDUB(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_SEPARATE_CONNECTION:
+            {
+                requestSeparateConnection(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_DTMF:
+            {
+                requestDTMF(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_DTMF_STOP:
+            {
+                requestDTMFStop(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_DTMF_START:
+            {
+                requestDTMFStart(data,datalen,t);
+                break;
+            }
+
+        case RIL_REQUEST_SET_MUTE:
+            {
+                RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+                break;
+            }
+
+        case  RIL_REQUEST_GET_MUTE:
+            {
+                requestGetMute(data, datalen, t);
+                break;
+            }
+        case  RIL_REQUEST_GET_CLIR:
+            {
+                requestGetClir(data, datalen, t);
+                break;
+            }
+
+        case  RIL_REQUEST_SET_CLIR:
+            {
+                requestSetClir(data, datalen, t);
+                break;
+            }
+// <!--added by wangmengying@2018.8.1 for Call Forwarding Number and Conditions
+        case RIL_REQUEST_SET_CALL_FORWARD:
+            {
+                requestSetCallForward(data, t);
+                break;
+            }
+        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
+            {
+                requestQueryCallForwardStatus(data, t);
+                break;
+            }
+// end--!>
+        case RIL_REQUEST_QUERY_CALL_WAITING:
+            {
+                requestQueryCallWaiting(data, datalen, t);
+                break;
+            }
+
+        case RIL_REQUEST_SET_CALL_WAITING:
+            {
+                requestSetCallWaiting(data, datalen, t);
+                break;
+            }
+		/* BEGIN: Added by eric.li, 2018/10/16   PN:add support radio capability */
+#if (RIL_VERSION > 9 )
+        case RIL_REQUEST_GET_RADIO_CAPABILITY:
+		{
+		    char  android_version[PROP_VALUE_MAX];
+		    __system_property_get("ro.build.version.release", android_version);
+		            requestGetRadioCapablility(data, datalen, t);
+		            RLOGD("Android Version [%s], support requestGetRadioCapablility request\r\n", android_version);
+		}
+		break;
+#endif
+		/* END:   Added by eric.li, 2018/10/16   PN:add support radio capability */
+//#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+/*Begin: Wujiabao changed it to '#if 1' in 2022/07/20*/
+#if 1
+/*End:   Wujiabao changed it to '#if 1' in 2022/07/20*/
+        case RIL_REQUEST_DEVICE_IDENTITY:
+        {
+            requestDeviceIdentity(data, datalen, t);
+            break;
+        }
+        case RIL_REQUEST_GET_HARDWARE_CONFIG:
+        {
+            requestGetHardwareConfig(data, datalen, t);
+            break;
+        }
+#endif
+//#ifndef GHT_FEATURE_ANDROID4X
+/*Begin: Wujiabao changed it to '#if 1' in 2022/07/20*/
+#if 1
+/*End:   Wujiabao changed it to '#if 1' in 2022/07/20*/
+        case RIL_REQUEST_SET_DATA_PROFILE:
+        {
+            RLOGD("[%s] set data profile ",__FUNCTION__);
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        }
+        case RIL_REQUEST_VOICE_RADIO_TECH:
+        {
+            RLOGD("[%s] VOICE_RADIO_TECH ",__FUNCTION__);
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        }
+        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
+        {
+            RLOGD("[%s] RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE ",__FUNCTION__);
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        }
+        case RIL_REQUEST_CDMA_SUBSCRIPTION:
+        {
+            RLOGD("[%s] RIL_REQUEST_CDMA_SUBSCRIPTION ",__FUNCTION__);
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        }
+        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
+        {
+            RLOGD("[%s] RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE ",__FUNCTION__);
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+            break;
+        } 
+        case RIL_REQUEST_ALLOW_DATA:
+        {
+            int allowdata = ((int *)data)[0];
+
+            //<--Start:Modified by Wujiabao in 2022/05/05, because we always thought modules supported data call
+            RLOGD("[%s] allowdata:%d, %s",__FUNCTION__, allowdata, allowdata == 1? "allow":"disallow");
+            if (allowdata == 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            }
+            else
+            {
+                RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+            }
+            //--End:Modified by Wujiabao in 2022/05/05, because we always thought modules supported data call---!>
+
+            break;
+        }
+#endif
+
+        case RIL_REQUEST_SIM_OPEN_CHANNEL:
+        {
+            requestSimOpenChannel(data, datalen, t);
+            break;
+        }
+        case RIL_REQUEST_SIM_CLOSE_CHANNEL:
+        {
+            requestSimCloseChannel(data, datalen, t);
+            break;
+        }
+        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
+        {
+            requestSimTransmitApduChannel(data, datalen, t);
+            break;
+        }
+
+
+        default:
+            RIL_onRequestComplete(t, RIL_E_REQUEST_NOT_SUPPORTED, NULL, 0);
+            break;
+    }
+}
+// <!--[ODM]lindong@2017.12.13 for Sim hot plug
+void SimStatusChangedCallback(void *param __unused)
+{
+    RLOGD("[%s,%d]sState %d[%s]",__FUNCTION__, __LINE__, sState, radioStateToString(sState));
+    setRadioState(RADIO_STATE_SIM_READY);
+    RLOGD("[%s,%d]sState %d[%s]",__FUNCTION__, __LINE__, sState, radioStateToString(sState));
+    RIL_onUnsolicitedResponse(
+            RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED,
+            NULL, 0);
+    RLOGD("[%s,%d]sState %d[%s]",__FUNCTION__, __LINE__, sState, radioStateToString(sState));
+    RLOGD("[%s,%d]",__FUNCTION__, __LINE__);
+}
+// end-->
+extern void cdma_pdu_2_3gpp_pdu(char *pdu_3gpp2, char *pdu_3gpp);
+/**
+ * Called by atchannel when an unsolicited line appears
+ * This is called on atchannel's reader thread. AT commands may
+ * not be issued here
+ */
+static void onUnsolicited (const char *s, const char *sms_pdu)
+{
+    char *line = NULL;
+    int err;
+    RLOGD("******** Enter onUnsolicited() ********");
+	/* BEGIN: Deleted by eric.li, 2019/1/10   PN:0014627 android5 cannot enter sim init with property */
+	/* END:   Deleted by eric.li, 2019/1/10   PN:0014627 android5 cannot enter sim init with property */
+
+    /* Ignore unsolicited responses until we're initialized.
+     * This is OK because the RIL library will poll for initial state
+     */
+    if (sState == RADIO_STATE_UNAVAILABLE)
+    {
+        RLOGD("it is exit onunsolicited because RADIO_STATE_UNAVAILABLE");
+        return;
+    }
+
+    if (strStartsWith(s, "%CTZV:"))
+    {
+        /* TI specific -- NITZ time */
+        char *response;
+
+        line = strdup(s);
+        at_tok_start(&line);
+
+        err = at_tok_nextstr(&line, &response);
+
+        if (err != 0)
+        {
+            RLOGD("invalid NITZ line %s\n", s);
+        }
+        else
+        {
+            RIL_onUnsolicitedResponse (
+                    RIL_UNSOL_NITZ_TIME_RECEIVED,
+                    response, strlen(response));
+        }
+    }
+    else if (strStartsWith(s,"+CRING:")
+            || strStartsWith(s,"RING")
+            //|| strStartsWith(s,"NO CARRIER")
+            || strStartsWith(s,"+CCWA")
+            || strStartsWith(s,"CONNECT")
+            //|| strStartsWith(s,"^DSCI:")
+            )
+    {
+        /* BEGIN: Added by eric.li, 2018/10/11   PN:fix bug for ring call */
+            if (strStartsWith(s,"+CRING:")
+                || strStartsWith(s,"RING")){
+          RIL_onUnsolicitedResponse(RIL_UNSOL_CALL_RING, NULL, 0); //Add for notify application play ring, case 0010804
+        }
+    /* END:   Added by eric.li, 2018/10/11   PN:fix bug for ring call */
+
+        RIL_onUnsolicitedResponse (
+                RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED,
+                NULL, 0);
+#ifdef WORKAROUND_FAKE_CGEV
+        RIL_requestTimedCallback (onDataCallListChanged, NULL, NULL); //TODO use new function
+#endif /* WORKAROUND_FAKE_CGEV */
+    }
+    else if (strStartsWith(s,"+CREG:")
+            ||strStartsWith(s,"+CGREG:")
+            ||strStartsWith(s,"+CEREG:")
+            ||strStartsWith(s,"+C5GREG:")
+            ||strStartsWith(s,"+NWTYPEIND:")
+            ||strStartsWith(s,"^MODE:")
+            )
+    {
+    /* BEGIN: Modified by eric.li, 2019/2/23   PN:0015171 fix android8 cfun display signal issue*/
+        #if 0 //Modified by zjr 2019/07/15 PN:0024628 fix android7 restarts after closing the flight mode can not access the Internet
+    if (sState >= RADIO_STATE_ON || sState == RADIO_STATE_SIM_READY)
+        #endif /*ODM_ARM64 */
+    {
+        RLOGD("Network State Changed.");
+        RIL_onUnsolicitedResponse (RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED,NULL, 0);
+    }
+    /* END:   Modified by eric.li, 2019/2/23   PN: 0015171 android8 cfun display signal issue*/
+#ifdef WORKAROUND_FAKE_CGEV
+/* BEGIN: Modified by eric.li, 2019/2/18   PN:debounce for network detach */
+        {
+                struct timeval network_detach = {0, 100000};
+                RLOGD("%s,%d,onUNsol str[%s]", __FUNCTION__,__LINE__,s);
+                RIL_requestTimedCallback (onDataCallListChanged, NULL, &network_detach);
+        }
+#endif /* WORKAROUND_FAKE_CGEV */
+/* BEGIN: Added by eric.li, 2018/11/5   PN:0010759  hotplug issue */
+	{
+		int sim_status;
+		sim_status = getSIMStatus();
+		RLOGD("sState: %d(%s), sim_status: %d" , sState, radioStateToString(sState),sim_status);
+		if(SIM_NOT_READY >= sim_status)
+		{
+		        RIL_onUnsolicitedResponse(
+				            RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED,
+				            NULL, 0);
+		}
+	}
+/* END:   Added by eric.li, 2018/11/5   PN:0010759  hotplug issue */
+    }
+    else if (strStartsWith(s, "+CMT:"))
+    {
+        RIL_onUnsolicitedResponse (
+                RIL_UNSOL_RESPONSE_NEW_SMS,
+                sms_pdu, strlen(sms_pdu));
+    }
+    else if (strStartsWith(s, "^DATADISCONN"))
+    {
+        RIL_requestTimedCallback (onDeactiveDataCallList, NULL, NULL);
+    }
+    else if (strStartsWith(s, "^HCMGSS:") ||
+            strStartsWith(s, "^HCMGSF0"))
+    {
+        RLOGD("handover_flag = %d",handover_flag);
+        if(1 == handover_flag)
+        {
+            RIL_requestTimedCallback (OnResumeLTENetwork, NULL, NULL);
+            handover_flag = 0;
+        }
+    }
+    else if(strStartsWith(s, "^DSCI:")
+            || strStartsWith(s,"NO CARRIER"))
+    {
+        RLOGD("voice_handover_flag = %d",voice_handover_flag);
+        RIL_onUnsolicitedResponse (
+                RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED,
+                NULL, 0);
+#ifdef WORKAROUND_FAKE_CGEV
+        RIL_requestTimedCallback (onDataCallListChanged, NULL, NULL); //TODO use new function
+#endif /* WORKAROUND_FAKE_CGEV */
+        if(1 == voice_handover_flag)
+        {
+            RIL_requestTimedCallback (OnResumeLTENetwork, NULL, NULL);
+            voice_handover_flag = 0;
+        }
+    }
+
+    //add by gaojing to test at+ecm
+    else if (strStartsWith(s, "+CDS:"))
+    {
+        RIL_onUnsolicitedResponse (
+                RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT,
+                sms_pdu, strlen(sms_pdu));
+    }
+    else if(strStartsWith(s,"+CMGR:"))
+    {
+        if(sms_type == SMS_GENERAL || sms_type == SMS_BROADCAST)
+        {
+            RIL_onUnsolicitedResponse (
+                RIL_UNSOL_RESPONSE_NEW_SMS,
+                sms_pdu, strlen(sms_pdu));
+
+        }
+        else if (sms_type == SMS_SEND_REPORT)
+        {
+            RIL_onUnsolicitedResponse (
+                    RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT,
+                    sms_pdu, strlen(sms_pdu));
+        }
+    }
+    else if (strStartsWith(s, "+CGEV:"))
+    {
+        RLOGD("%s,%d, NW DETACH", __FUNCTION__, __LINE__);
+        #if 1
+        if(mode_flag != GHT_FG650)
+        {
+            if(strStartsWith(s,"+CGEV: NW DETACH") || strStartsWith(s,"+CGEV: NW DEACT"))
+            {
+                RLOGD("%s,%d", __FUNCTION__, __LINE__);
+                #ifdef ODM_ARM64
+                RIL_onUnsolicitedResponse (RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED,NULL, 0);
+                #endif          
+                onDeactiveDataCallList();          
+            }   
+            struct timeval network_detach = {0, 100000};
+            RIL_requestTimedCallback (onDataCallListChanged, NULL, &network_detach);
+            //   RIL_requestTimedCallback (onDataCallListChanged, NULL, NULL);
+        }
+        #endif
+    }
+    #ifdef WORKAROUND_FAKE_CGEV
+    else if (strStartsWith(s, "+CME ERROR: 150"))
+    {
+        RIL_requestTimedCallback (onDataCallListChanged, NULL, NULL);
+    }
+    #endif /* WORKAROUND_FAKE_CGEV */
+    else if ( strStartsWith(s, "+CMTI:")  || strStartsWith(s, "+CBMI:") || strStartsWith(s, "+CDSI:"))
+    {
+        onNewSmsNotification((char *)s); // modify by FPL
+    }
+    else if(strStartsWith(s,"+CUSD:"))
+    {
+        char *response;
+        char *uusd_line;
+        uusd_line = strdup(s);
+        at_tok_start(&uusd_line);
+        err = at_tok_nextstr(&uusd_line, &response);
+        RIL_onUnsolicitedResponse (
+                RIL_UNSOL_ON_USSD,
+                response, strlen(response));
+    }
+    // <!--[ODM]lindong@2017.12.13 for Sim hot plug
+    else if(strStartsWith(s,"+SIM: Inserted") || strStartsWith(s,"+SIM: READY") || strStartsWith(s,"+SIM READY"))
+    {
+        RLOGD("[%s,%d]Report SIM Inserted, sState:%d(%s)", __FUNCTION__, __LINE__, sState, radioStateToString(sState));
+        if(sState != RADIO_STATE_OFF && sState != RADIO_STATE_UNAVAILABLE)
+        {
+            struct timeval SimStatusChangded = {2, 0};
+            RLOGD("[%s,%d]Report SIM Inserted status changed callback timeout[%ld]", __FUNCTION__, __LINE__, SimStatusChangded.tv_sec);
+            RIL_requestTimedCallback(SimStatusChangedCallback, NULL, &SimStatusChangded);
+            RLOGD("[%s,%d]Report SIM Inserted status changed", __FUNCTION__, __LINE__);
+        }
+    }
+    else if(strStartsWith(s,"+SIM: Removed") ||  strStartsWith(s,"+SIM: Drop")) //modified by lisf for debug 20181225
+    {
+        setRadioState(RADIO_STATE_SIM_NOT_READY);
+        RLOGD("[%s,%d]Report SIM Removed status changed", __FUNCTION__, __LINE__);
+        RIL_onUnsolicitedResponse(RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED,NULL, 0);
+        //ppp 
+        if (mode_flag == GHT_NL678_E){
+            if(ppp_fd > 0){
+                at_send_command("ATH", NULL);
+                close(ppp_fd);
+                ppp_fd = -1;
+            }
+            pppd = 0;
+            RIL_onUnsolicitedResponse(RIL_UNSOL_DATA_CALL_LIST_CHANGED,NULL, 0);
+		}
+        else{
+            onDeactiveDataCallList();
+        }
+        RLOGD("[%s,%d]Report SIM Removed status changed", __FUNCTION__, __LINE__);
+    }
+    else
+    {
+        RLOGD("Unknown statement,ignoring...:%s",s);
+    }
+
+    free(line);
+    RLOGD("******** Leave onUnsolicited() ********");
+}
+
+    static void *
+mainLoop(void *param __unused)
+{
+    int fd;
+    int ret;
+    RLOGD("******** Enter mainLoop() ********");
+#ifdef HAVE_DATA_DEVICE
+    struct stat dummy;
+#endif
+#ifdef SIGNAL_MODEM
+    struct termios new_termios, old_termios;
+#endif
+
+    at_set_on_reader_closed(onATReaderClosed);
+    at_set_on_timeout(onATTimeout);
+
+    for (;;)
+    {
+        fd = -1;
+        while  (fd < 0)
+        {
+#ifdef HAVE_DATA_DEVICE
+            /* If the modem have two channel, e.g. UART for AT command and USB for data,
+               we check the data channel firstly (e.g. /dev/ttyUSB0) so that after AT handshake
+               we can make sure the data channel is ready.
+               */
+            if((!dialmode) && (stat(s_data_device_path, &dummy)))
+            {
+                RLOGD ("opening data channel device - %s. retrying...", s_data_device_path);
+              //  goto get_device;
+            }
+#endif
+            if (s_port > 0)
+            {
+
+                if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+                {
+                    RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                    fd = socket_network_client("localhost",s_port, SOCK_STREAM);
+                }
+
+#if 0
+          #if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+                 fd = socket_network_client("localhost",s_port, SOCK_STREAM);
+	   #else
+                //fd = socket_loopback_client(s_port, SOCK_STREAM);
+	   #endif
+#endif
+            }
+            else if (s_device_socket)
+            {
+                if (!strcmp(s_device_path, "/dev/socket/qemud"))
+                {
+                    /* Qemu-specific control socket */
+                    fd = socket_local_client( "qemud",
+                            ANDROID_SOCKET_NAMESPACE_RESERVED,
+                            SOCK_STREAM );
+                    if (fd >= 0 )
+                    {
+                        char  answer[2];
+
+                        if ( write(fd, "gsm", 3) != 3 ||
+                                read(fd, answer, 2) != 2 ||
+                                memcmp(answer, "OK", 2) != 0)
+                        {
+                            close(fd);
+                            fd = -1;
+                        }
+                    }
+                }
+                else
+                    fd = socket_local_client( s_device_path,
+                            ANDROID_SOCKET_NAMESPACE_FILESYSTEM,
+                            SOCK_STREAM );
+            }
+            else if (s_device_path != NULL)
+            {
+                fd = open (s_device_path, O_RDWR);
+                if ( fd >= 0 && !memcmp( s_device_path, "/dev/ttyS", 9 ) )
+                {
+                    /* disable echo on serial ports */
+                    struct termios  ios;
+                    tcgetattr( fd, &ios );
+                    ios.c_lflag = 0;  /* disable ECHO, ICANON, etc... */
+                    tcsetattr( fd, TCSANOW, &ios );
+                }
+            }
+
+            if (fd < 0)
+            {
+
+                RLOGD ("opening AT interface. retrying...:%s",strerror(errno));
+//get_device:
+                sleep(1);
+                RLOGD("open port fail,retry usb detect");
+                memset(&s_usbPortDevice,0,sizeof(USBPortDevice));
+                ret = getUsbPortInfo(&s_usbPortDevice);
+                if (!ret)
+                {
+                    s_device_path = s_usbPortDevice.atchannel;
+                    if (dialmode == 0)
+                    {
+                        property_set("ril.datachannel", s_usbPortDevice.datachannel);
+#ifdef HAVE_DATA_DEVICE
+                        s_data_device_path = s_usbPortDevice.datachannel;
+#endif
+                    }
+                }
+                /* never returns */
+            }
+        }
+
+#ifdef SIGNAL_MODEM
+        /* Set UART parameters (e.g. Buad rate) for connecting with SIGNAL modem */
+        tcgetattr(fd, &old_termios);
+        new_termios = old_termios;
+        new_termios.c_lflag &= ~(ICANON | ECHO | ISIG);
+        new_termios.c_cflag |= (CREAD | CLOCAL);
+        new_termios.c_cflag &= ~(CSTOPB | PARENB | CRTSCTS);
+        new_termios.c_cflag &= ~(CBAUD | CSIZE) ;
+        new_termios.c_cflag |= (B115200 | CS8);
+        ret = tcsetattr(fd, TCSANOW, &new_termios);
+        if(ret < 0)
+        {
+            RLOGD ("Fail to set UART parameters. tcsetattr return %d \n", ret);
+            return 0;
+        }
+#endif
+
+        s_closed = 0;
+        ret = at_open(fd, onUnsolicited);
+
+        if (ret < 0)
+        {
+            RLOGD ("AT error %d on at_open\n", ret);
+            return 0;
+        }
+        else
+            RLOGD("AT open successfully!");
+
+        /* Some SIGNAL USB datacards (e.g. E180) bootup and attach to network a little bit slowly(e.g. 20s).
+           Delay RIL init so that we can always get correct network status (i.e. +COPS?).
+           FIX ME: this should be removed in future. Service layer should be responsible to handle "late" attach.
+           */
+        property_set("ril.currentapntype", "default"); //add by duanshitao 20111003
+
+        if(dialmode == DIAL_RAS_MOD) //RAS_MOD
+        {
+            if((ret = start_ppp_check_pthread())<0)
+            {
+                RLOGD("%s: start_ppp_check_pthread() failed: %s", __FUNCTION__, strerror(errno));
+                return 0;
+            }
+        }
+        else if(dialmode == DIAL_NDIS_MOD)
+        {
+            if((ret = start_ndis_do_dhcp_pthread())<0)
+            {
+                RLOGD("%s: start_ndis_do_dhcp_pthread() failed: %s", __FUNCTION__, strerror(errno));
+                return 0;
+            }
+        }
+        RIL_requestTimedCallback(initializeCallback, NULL, &TIMEVAL_DELAYINIT);
+
+        // Give initializeCallback a chance to dispatched, since
+        // we don't presently have a cancellation mechanism
+        sleep(1);
+
+        waitForClose();
+        RLOGD("Re-opening after close");
+    }
+}
+
+#ifdef RIL_SHLIB
+
+pthread_t s_tid_mainloop;
+
+pthread_t s_tid_pingloop;
+
+int start_ppp_check_pthread()
+{
+    int ret = -1;
+    pthread_attr_t attr;
+    pthread_attr_init (&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    ret = pthread_create(&s_tid_mainloop, &attr, ppp_main_loop,  NULL);
+    return ret;
+}
+int start_ndis_do_dhcp_pthread()
+{
+    int ret = -1;
+    pthread_attr_t attr;
+    pthread_attr_init (&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    ret = pthread_create(&s_tid_ndisloop, &attr, ndis_main_loop,  NULL);
+    return ret;
+}
+
+Android_Version Ght_Android_Version = ANDROID_4;
+
+
+int getRIL_VERSION()
+{
+//ro.build.version.release
+    int ret, Android_version;
+    char Android_ver_str[PROPERTY_VALUE_MAX] = {0};
+
+    ret = property_get("ro.build.version.release", Android_ver_str, "");
+    if(ret > 0)
+    {
+        Android_version = atoi(Android_ver_str);
+        if(Android_version > 0)
+        {
+            Ght_Android_Version = (Android_Version)Android_version;
+            RLOGD("Android version:%d, Ght_Android_Version:%d", Android_version, Ght_Android_Version);
+        }
+        else
+        {
+            RLOGE("Got the wrong Android version:%s", Android_ver_str);
+            goto error;
+        }
+    }
+    else
+    {
+        RLOGE("Failed to get value of ro.build.version.release!!!");
+        goto error;
+    }
+
+    if(Android_version < ANDROID_MIN || Android_version > ANDROID_MAX)
+    {
+        RLOGE("Android %d is not supported!!!", Android_version);
+        goto error;
+    }
+    else
+    {
+        if(ANDROID_4 == Android_version)
+        {
+            s_callbacks.version = 9;
+        }
+        else if((ANDROID_5 == Android_version) || (ANDROID_6 == Android_version))
+        {
+            s_callbacks.version = 11;
+        }
+        else if((Android_version >= ANDROID_7) && (Android_version <= ANDROID_11))
+        {
+            s_callbacks.version = 12;
+        }
+        else
+        {
+            RLOGE("[%s,%d] Unknown Android version:%d", __FUNCTION__, __LINE__, Android_version);
+            goto error;
+        }
+    }
+
+    return s_callbacks.version;
+
+error:
+    s_callbacks.version = 6;
+    return s_callbacks.version;
+}
+
+const RIL_RadioFunctions *RIL_Init(const struct RIL_Env *env,int argc, char **argv)
+{
+    int ret = 0;
+    int opt;
+    char dialmodesetbybuildprop[PROPERTY_VALUE_MAX] ={0};
+    pthread_attr_t attr;
+    s_rilenv = env;
+    RLOGD("******** Enter RIL_Init() ********");
+    char *cmd = NULL;
+
+    asprintf(&cmd, "setenforce 0");
+    RLOGD("%s",cmd);
+    system(cmd); 
+    free(cmd);
+
+    RLOGD("RIL_VERSION:%d", getRIL_VERSION());
+    RLOGD("FIBOCOM VERSION: %s",getVersion());
+    RLOGD("%s",getKernelVersion());
+
+    memset(&s_usbPortDevice,0,sizeof(USBPortDevice));
+    do
+    {
+        sleep(1);
+        ret = getUsbPortInfo(&s_usbPortDevice);
+        if(ret){
+            RLOGD("please check usb port state,RIL do not detech the usb devices");
+        }
+    }while(ret);
+
+    s_device_path = s_usbPortDevice.atchannel;
+    RLOGD("fibocom get atchannel = %s", s_device_path);
+    s_diag_device_path = s_usbPortDevice.diagchannel;
+    RLOGD("fibocom get diagchannel = %s", s_diag_device_path);
+#ifdef HAVE_DATA_DEVICE
+    if (dialmode==0)
+    {
+        s_data_device_path = s_usbPortDevice.datachannel;
+        property_set("ril.datachannel", s_usbPortDevice.datachannel);
+        RLOGD("fibocom get datachannel = %s", s_data_device_path);
+    }
+#endif
+
+#ifdef ODM_DEVMODE
+    dialmode = ODM_DEVMODE;
+#endif
+    while ( -1 != (opt = getopt(argc, argv, "p:d:s:c:w:"))) {
+        switch (opt) {
+            case 'w':
+                dialmode = atoi(optarg);
+                if (dialmode > 2) {
+                    usage(argv[0]);
+                    return NULL;
+                }
+            break;
+            default:
+                break;
+        }
+    }
+
+    ret = 0; 
+    ret = property_get("ril.fibocom.dialmode", dialmodesetbybuildprop, ""); 
+    if(ret > 0) 
+    {    
+         if ( atoi(dialmodesetbybuildprop)>=0 && atoi(dialmodesetbybuildprop) <=3 )
+         {    
+            dialmode = atoi(dialmodesetbybuildprop);
+         }    
+         else{
+            RLOGD("setting dialmode error :  ril.fibocom.dialmode=0 or 1 or 2 \n");
+         }    
+    }
+    RLOGD("Opening dialmode %d\n", dialmode);
+
+    if (s_port < 0 && s_device_path == NULL)
+    {
+        usage(argv[0]);
+        return NULL;
+    }
+
+#ifdef HAVE_DATA_DEVICE
+    if ((!dialmode) && (s_data_device_path == NULL))
+    {
+        usage(argv[0]);
+        return NULL;
+    }
+#endif
+    pthread_attr_init (&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    ret = pthread_create(&s_tid_mainloop, &attr, mainLoop, NULL);
+
+    if(getProfileBool("PING", "PINGWDT", 0))
+    {
+        ret = pthread_create(&s_tid_pingloop, &attr, pingLoop, NULL);
+    }
+    else
+    {
+        RLOGD("The PINGWDT thread is not currently enabled!");
+    }
+
+    return &s_callbacks;
+}
+#else /* RIL_SHLIB */
+int main (int argc, char **argv)
+{
+    int ret;
+    int fd = -1;
+    int opt;
+    RLOGD("it's enterring main,so RIL_SHLIB is not defined");
+    RLOGD("******** Enter main() ********");
+    while ( -1 != (opt = getopt(argc, argv, "p:d:")))
+    {
+        switch (opt)
+        {
+            case 'p':
+                s_port = atoi(optarg);
+                if (s_port == 0)
+                {
+                    usage(argv[0]);
+                }
+                RLOGD("Opening loopback port %d\n", s_port);
+                break;
+
+            case 'd':
+                s_device_path = optarg;
+                RLOGD("Opening tty device %s\n", s_device_path);
+                break;
+#ifdef HAVE_DATA_DEVICE
+            case 'u':
+                s_data_device_path = optarg;
+                RLOGD("Opening tty device %s\n", s_data_device_path);
+                break;
+#endif
+            case 's':
+                s_device_path   = optarg;
+                s_device_socket = 1;
+                RLOGD("Opening socket %s\n", s_device_path);
+                break;
+            default:
+                usage(argv[0]);
+        }
+    }
+
+    if (s_port < 0 && s_device_path == NULL)
+    {
+        usage(argv[0]);
+    }
+
+    RIL_register(&s_callbacks);
+    mainLoop(NULL);
+
+    return 0;
+}
+
+#endif /* RIL_SHLIB */
+
+int g_fd_port = -1;
+int serial_connect(const char *str_port)
+{
+        struct termios newtio;
+
+        if(!str_port)
+        {
+                RLOGD("invalid parameter!");
+                return -1;
+        }
+
+        RLOGD("port[%s] connecting...", str_port);
+
+        g_fd_port = open (str_port, O_RDWR);
+        if(g_fd_port < 0)
+        {
+                RLOGD("port[%s] open failed! errno[%d]", str_port, errno);
+                goto error_exit;
+        }
+
+        if(tcgetattr(g_fd_port, &newtio) != 0)
+        {
+                RLOGD("port[%s] tcgetattr failed! errno[%d]", str_port, errno);
+                goto error_exit;
+        }
+
+        cfmakeraw(&newtio);
+
+        /*set baudrate*/
+        cfsetispeed(&newtio, B4000000);
+        cfsetospeed(&newtio, B4000000);
+
+        /*set char bit size*/
+        newtio.c_cflag &= ~CSIZE;
+        newtio.c_cflag |= CS8;
+
+        /*set check sum*/
+        newtio.c_cflag &= ~PARENB;
+
+        /*set stop bit*/
+        newtio.c_cflag &= ~CSTOPB;
+        newtio.c_cflag |= CLOCAL |CREAD;
+        newtio.c_cflag &= ~(PARENB | PARODD);
+
+        newtio.c_iflag &= ~(INPCK | BRKINT |PARMRK | ISTRIP | INLCR | IGNCR | ICRNL);
+        newtio.c_iflag |= IGNBRK;
+        newtio.c_iflag &= ~(IXON|IXOFF|IXANY);
+
+        newtio.c_oflag = 0;
+
+        newtio.c_lflag = 0;
+
+        /*set wait time*/
+        newtio.c_cc[VMIN] = 0;
+        newtio.c_cc[VTIME] = 0;
+
+        tcflush(g_fd_port, TCIFLUSH);
+        tcflush(g_fd_port, TCOFLUSH);
+
+        if(tcsetattr(g_fd_port, TCSANOW, &newtio) !=0 )
+        {
+                RLOGD("port[%s] tcsetattr failed! errno[%d]", str_port, errno);
+                goto error_exit;
+        }
+
+        RLOGD("port[%s] connected!", str_port);
+
+        return 0;
+
+error_exit:
+
+        if(g_fd_port >= 0)
+        {
+                close(g_fd_port);
+                g_fd_port = -1;
+        }
+
+        return -1;
+}
+
+int serial_disconnect()
+{
+        if(g_fd_port >= 0)
+        {
+                close(g_fd_port);
+                g_fd_port = -1;
+        }
+
+        return 0;
+}
+
+unsigned long serial_read(unsigned char *p_in_buffer, unsigned long in_buffer_size, unsigned long *p_bytes_read)
+{
+        int read_len = 0;
+
+        if(g_fd_port < 0)
+        {
+                RLOGD("please open port first!");
+                return 0;
+        }
+
+        if(!p_in_buffer || in_buffer_size <= 0)
+                return 0;
+
+        read_len = read(g_fd_port, p_in_buffer, in_buffer_size);
+        if(read_len < 0)
+        {
+                RLOGD("read com port error :%d,  errno[%d]", read_len, errno);
+                read_len = 0;
+        }
+
+        if(p_bytes_read)
+                *p_bytes_read = read_len;
+
+        return read_len;
+}
+
+unsigned long serial_write_hexstring(const char *str_in_buffer)
+{
+        unsigned long write_cnt = 0;
+        unsigned long str_len = 0;
+        char ch_high, ch_low;
+        unsigned char *buffer_to_write = NULL;
+        unsigned long cb_wrote = 0;
+        unsigned long i;
+
+        if(g_fd_port < 0)
+        {
+                RLOGD("please open port first!");
+                return 0;
+        }
+
+        str_len = (unsigned long)strlen(str_in_buffer);
+
+        if(!str_in_buffer || str_len <= 0)
+                goto error_exit;
+
+        buffer_to_write = (unsigned char *)malloc(str_len);
+        if(!buffer_to_write)
+        {
+                RLOGD("malloc %lu bytes failed! errno[%d]", str_len, errno);
+                goto error_exit;
+        }
+
+        while(*str_in_buffer != '\0' && (*str_in_buffer + 1) != '\0')
+        {
+                ch_high = tolower(*str_in_buffer);
+                ch_low = tolower(*(str_in_buffer + 1));
+                if ((('0' <= ch_high && '9' >= ch_high) || ('a' <= ch_high && 'f' >= ch_high)) && 
+                                (('0' <= ch_low && '9' >= ch_low) || ('a' <= ch_low && 'f' >= ch_low)))
+                {
+                        if ('0' <= ch_high && '9' >= ch_high)
+                        {
+                                buffer_to_write[write_cnt] = (ch_high - '0') << 4;
+                        }
+                        else
+                        {
+                                buffer_to_write[write_cnt] = (0x0a + ch_high - 'a') << 4;
+                        }
+
+                        if ('0' <= ch_low && '9' >= ch_low)
+                        {
+                                buffer_to_write[write_cnt] |= (ch_low - '0');
+                        }
+                        else
+                        {
+                                buffer_to_write[write_cnt] |= (0x0a + ch_low - 'a');
+                        }
+                        write_cnt++;
+                        str_in_buffer += 2;
+                }
+                else
+                        str_in_buffer++;
+        }
+
+        if(write_cnt <= 0)
+                goto error_exit;
+
+	 for(i=0;i<write_cnt;i++)
+	 {
+	      RLOGD("serial_write_hexstring:buffer_to_write[%lu]=0x%x", i, buffer_to_write[i]);
+	 }
+
+        /*just write data to device*/
+        cb_wrote = write(g_fd_port, buffer_to_write, write_cnt);
+        if(cb_wrote <= 0)
+        {
+                RLOGD("port[0x%x] write error! errno[%d]", g_fd_port, errno);
+                goto error_exit;
+        }
+
+        if(buffer_to_write)
+                free(buffer_to_write);
+
+        return cb_wrote;
+
+error_exit:
+
+        if(buffer_to_write)
+                free(buffer_to_write);
+
+        return 0;
+}
+
+// <!--[ODM]wangmengying@2019.8.16 [SN-20190608001]Customized AT commands
+void initReserveAtCommand()
+{
+    RLOGD("Enter --- [%s,%d]",__FUNCTION__,__LINE__);
+
+    char reserve_at_commad_1[PROPERTY_VALUE_MAX]={0};
+    char reserve_at_commad_2[PROPERTY_VALUE_MAX]={0};
+    char reserve_at_commad_3[PROPERTY_VALUE_MAX]={0};
+
+    property_get("ril.reserve.cmd1",reserve_at_commad_1,"");
+    property_get("ril.reserve.cmd2",reserve_at_commad_2,"");
+    property_get("ril.reserve.cmd3",reserve_at_commad_3,"");
+
+    RLOGD("initReserveAtCommand reserve_at_commad_1=%s,reserve_at_commad_2=%s,reserve_at_commad_3=%s",
+            reserve_at_commad_1,reserve_at_commad_2,reserve_at_commad_3);
+
+    if( 0 != strcmp(reserve_at_commad_1, ""))
+    {
+        at_send_command(reserve_at_commad_1, NULL);
+    }
+
+    if( 0 != strcmp(reserve_at_commad_2, ""))
+    {
+        at_send_command(reserve_at_commad_2, NULL);
+    }
+
+    if( 0 != strcmp(reserve_at_commad_3, ""))
+    {
+        at_send_command(reserve_at_commad_3, NULL);
+    }
+
+    RLOGD("Leave --- [%s,%d]",__FUNCTION__,__LINE__);
+}
+// end-->
+
+int qualcomm_diag_reset()
+{
+        char *p_config_rsp_line = NULL;
+        int b_rsp_ok,try_read,i,rsp_len;
+        char str_port_name[128] = {0};
+
+        p_config_rsp_line = (char *)malloc(1024);
+
+        strcpy(str_port_name,s_diag_device_path);
+
+        if(!p_config_rsp_line)
+        {
+                RLOGD("malloc (%d) bytes buffer for response package line failed! errno[%d]", 1024, errno);
+                goto error_exit;
+        }
+		
+        if(serial_connect(str_port_name) <0)
+        {
+                goto error_exit;
+        }
+
+        if(!serial_write_hexstring("29 01 00 31 40 7e"))
+                goto error_exit;
+
+        b_rsp_ok = 0;
+        try_read = 500;
+	  RLOGD("qualcomm_diag_reset:off line respose: ");
+        do
+        {
+                rsp_len = serial_read((unsigned char *)p_config_rsp_line, 1024, NULL);
+                if(rsp_len >= 0)
+                {
+                        for(i = 0; i < rsp_len; i++)
+                        {
+                                RLOGD("%02x ", p_config_rsp_line[i]);
+                                if(p_config_rsp_line[i] == 0x7e)
+                                        b_rsp_ok = 1;
+                        }
+                }
+                else
+                {
+                        usleep(ATSEND_TIMEOUT_MSEC);
+                }
+        }while(!b_rsp_ok && try_read--);
+
+	  usleep(500000);
+
+        if(!serial_write_hexstring("29 02 00 59 6a 7e"))
+                goto error_exit;
+
+        b_rsp_ok = 0;
+        try_read = 500;
+	  RLOGD("qualcomm_diag_reset:respose: ");
+        do
+        {
+                rsp_len = serial_read((unsigned char *)p_config_rsp_line, 1024, NULL);
+                if(rsp_len >= 0)
+                {
+                        for(i = 0; i < rsp_len; i++)
+                        {
+                                RLOGD("%02x ", p_config_rsp_line[i]);
+                                if(p_config_rsp_line[i] == 0x7e)
+                                        b_rsp_ok = 1;
+                        }
+                }
+                else
+                {
+                        usleep(ATSEND_TIMEOUT_MSEC);
+                }
+        }while(!b_rsp_ok && try_read--);
+
+
+        serial_disconnect();
+
+        return 1;
+
+error_exit:
+
+        RLOGD("Log stop error.");
+
+        serial_disconnect();
+
+        return 0;
+}
+
diff --git a/hardware/ril/youyou_ril/ril_common.h b/hardware/ril/youyou_ril/ril_common.h
new file mode 100755
index 0000000..fe15850
--- /dev/null
+++ b/hardware/ril/youyou_ril/ril_common.h
@@ -0,0 +1,186 @@
+#ifndef _RIL_COMMON_H_
+#define _RIL_COMMON_H_
+
+#include <telephony/ril.h>
+#include "sim.h"
+
+#define GHT_RIL "GHT_RIL"
+#define GHT_AT  "GHT_AT"
+
+#define PROPERTY_CURRENT_USBMODE "persist.ril.current_usbmode"
+#define PROFILE_PATH "/system/etc/ght_ril_config.ini"
+
+//<---!added by Wujiabao in 2022/2/28:Add global variables that indicate whether certain functionality is supported or not
+extern int Voice_Support_Flag;
+extern int GTRAT_Support_Flag;
+extern int Net_3G_Support_Flag;
+//!---->
+
+#define ENTER_FUNC RLOGD("********Enter %s********", __FUNCTION__)
+#define LEAVE_FUNC RLOGD("********Leave %s********", __FUNCTION__)
+#define PRINT_FUNC_LINE RLOGD("[%s,%d]", __FUNCTION__, __LINE__)
+
+#define SCNd32 "d"
+#define PRId32 "d"
+#define SIM_CMD_MAX_SIZE 50
+#define SW1_RSP_SUCCESS 0x90
+#define SW1_RSP_SEND_COMMANDS 0x91
+#define SW2_RSP_SUCCESS 0x00
+#define SW2_RSP_RESET_MODEM 0x0B
+
+#define RET_FAIL -1
+#define RET_SUCCESS 0
+
+#define TRUE  1
+#define FALSE 0
+
+#define CHECK_DNS_AVAILABLE(x) (x != NULL && strcmp(x, "0.0.0.0") && strlen(x)?true:false)
+
+#ifdef USE_TI_COMMANDS
+
+// Enable a workaround
+// 1) Make incoming call, do not answer
+// 2) Hangup remote end
+// Expected: call should disappear from CLCC line
+// Actual: Call shows as "ACTIVE" before disappearing
+#define WORKAROUND_ERRONEOUS_ANSWER 1
+
+// Some varients of the TI stack do not support the +CGEV unsolicited
+// response. However, they seem to send an unsolicited +CME ERROR: 150
+#define WORKAROUND_FAKE_CGEV 1
+#endif
+
+#define ODM_CM_OPERATOR 0
+#define ODM_CT_OPERATOR_3G 1
+#define ODM_CT_OPERATOR_4G 2
+#define ODM_CU_OPERATOR 3
+
+#define Kernel_Version "4.4.36"      //Android6.x
+
+//#ifdef RIL_SHLIB
+ struct RIL_Env *s_rilenv;
+typedef enum
+{
+    INVALIDE_MOD = -1,
+    DIAL_RAS_MOD   = 0,
+    DIAL_ECM_MOD   = 1,
+    DIAL_NDIS_MOD  = 2,
+    DIAL_MAX_MOD
+} dial_mode;
+
+typedef enum
+{
+    GHT_NL650,
+    GHT_NL660,
+    GHT_NL668,/*added by eric.li, mean NL668-CN*/
+    /* BEGIN: Added by eric.li, 2018/10/18   PN:add support for android7 to handle prefered network */
+    GHT_NL668_AM,
+    GHT_NL668_EAU,
+    /* END:   Added by eric.li, 2018/10/18   PN:add support for android7 to handle prefered network */
+    GHT_NL668_EU,
+    GHT_NL668_JP,
+    GHT_NL668_LA,
+    GHT_MDM_NORMAL,  //For special product models, add modem_flags after GHT_MDM_NORMAL please.
+    GHT_L610,
+    GHT_MC919,       //Add a new model because the MC919 and L610 are quite different
+    GHT_MC66x,
+    GHT_FG621,
+    GHT_NL678_E,
+    /*diego add for campalibility M910 devices begin*/
+    GHT_M910_GL,
+    GHT_757S,
+    /*diego add for campalibility M910 devices end*/
+    //add by zhengjianrong for MA510 begin
+    GHT_MA510_GL,
+    GHT_FG650,
+    //add by zhengjianrong for MA510 end
+    GHT_H330S,
+    GHT_L716
+} product_model;
+//added by lisf for android8 20181208
+
+#if 0
+typedef enum
+{
+    RADIO_STATE_SIM_NOT_READY = 2, 
+    RADIO_STATE_SIM_LOCKED_OR_ABSENT = 3,
+    RADIO_STATE_SIM_READY = 4,
+    RADIO_STATE_RUIM_NOT_READY = 5,  
+    RADIO_STATE_RUIM_READY = 6, 
+    RADIO_STATE_RUIM_LOCKED_OR_ABSENT = 7,
+    RADIO_STATE_NV_NOT_READY = 8, 
+    RADIO_STATE_NV_READY = 9, 
+}RIL_RadioState;    
+#endif
+//Register network priority by "+GTRANT" command 20181119
+typedef enum {    
+	PREF_NET_TYPE_GSM                = 0, /* GSM only */    
+		PREF_NET_TYPE_GSM_UMTS                 = 1, /* GSM /UMTS */   
+		PREF_NET_TYPE_UMTS                    = 2, /* UMTS only  */    
+		PREF_NET_TYPE_LTE           = 3, /* LTE only */    
+		PREF_NET_TYPE_LTE_UMTS           = 4, /* LTE and UMTS */    
+		PREF_NET_TYPE_LTE_GSM                = 5, /*LTE and GSM*/    
+		PREF_NET_TYPE_LTE_UMTS_GSM                = 6, /* LTE/UMTS/GSM */    
+		PREF_NET_TYPE_TD_SCDMA = 7, /* TD-SCDMA */    
+		PREF_NET_TYPE_EMTC            = 8, /* EMTC */    
+		PREF_NET_TYPE_NB_IOT       = 9, /* NBIOT*/    
+		PREF_NET_TYPE_AUTOMATIC  = 10, /* Automic */    
+		PREF_NET_TYPE_CDMA                 = 11, /* CDMA only */    
+		PREF_NET_TYPE_CDMA_EVDO                = 12 , /*CDMA and EVDO */    
+		PREF_NET_TYPE_EVDO                  =13     /*EVDO*/
+} RIL_PreferredNetType;
+#define RIL_onRequestComplete(t, e, response, responselen) s_rilenv->OnRequestComplete(t,e, response, responselen)
+#define RIL_onUnsolicitedResponse(a,b,c) s_rilenv->OnUnsolicitedResponse(a,b,c)
+#define RIL_requestTimedCallback(a,b,c) s_rilenv->RequestTimedCallback(a,b,c)
+//#endif
+
+void initializeCallback(void *param);
+
+typedef struct{
+    int rssi;
+    int ber;
+    int rscp;
+    int rsrp;
+    int rsrq;
+}CSQInfo;
+int getCSQInfo(CSQInfo *csqInfo);
+
+/*Begin: Deleted by wujiabao in 2022/07/20, because we did not need it*/
+#if 0
+typedef struct{
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        RIL_SignalStrength_v10 signalStrength;
+#else
+        RIL_SignalStrength_v6 signalStrength;
+#endif
+}RIL_SignalStrength;
+#endif
+/*End:   Deleted by wujiabao in 2022/07/20, because we did not need it*/
+
+typedef struct{
+    int mode;
+    int format;
+    char *oper;
+    int Act;
+}COPSInfo;
+
+typedef enum{
+    ANDROID_MIN = 4,
+    ANDROID_4 = 4,
+    ANDROID_5,
+    ANDROID_6,
+    ANDROID_7,
+    ANDROID_8,
+    ANDROID_9,
+    ANDROID_10,
+    ANDROID_11,
+    ANDROID_MAX = 11,
+}Android_Version;
+
+extern Android_Version Ght_Android_Version;
+
+int getCOPSInfo(COPSInfo *copsInfo);
+void getNetifName();
+const char *simStatusToString(SIM_Status s);
+
+#endif /*_RIL_COMMON_H_*/
diff --git a/hardware/ril/youyou_ril/sim.c b/hardware/ril/youyou_ril/sim.c
new file mode 100755
index 0000000..c46f3e7
--- /dev/null
+++ b/hardware/ril/youyou_ril/sim.c
@@ -0,0 +1,1883 @@
+/******************************************************************************
+  Copyright (C), 2019, Shenzhen G&T Industrial Development Co., Ltd
+
+  File:      sim.c
+
+  Author:  Fibocom-diego
+  Version: 1.0
+  Date:  2019.04
+
+  Description:   sims APIs
+
+** History:
+**Author (core ID)                Date          Number     Description of Changes
+**-----------------------------------------------------------------------------
+** NODECOM-Aron                30-10-2018         **   init version 
+** FIBOCOM-diego               15-04-2019         **   add requestSIM_IO_M910 support M910/757S devices
+** -----------------------------------------------------------------------------
+******************************************************************************/
+#include <telephony/ril.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <alloca.h>
+#include "atchannel.h"
+#include "at_tok.h"
+#include "misc.h"
+#include <getopt.h>
+#include <sys/socket.h>
+#include <cutils/sockets.h>
+#include <cutils/properties.h>
+#include <termios.h>
+
+#include "ril_common.h"
+#include "sim.h"
+#include "network.h"
+#define LOG_TAG GHT_RIL
+#include <utils/Log.h>
+
+extern int cur_oper;
+extern product_model mode_flag;
+static struct timeval TIMEVAL_DELAYINIT = {0,0}; // will be set according to property value
+
+extern void setRadioState(RIL_RadioState newState);
+extern SIM_Status getSIMStatus();
+extern SIM_Status gSimStatus;
+#if 1 //usim -> sim
+typedef struct __TLV {
+    unsigned char tag;
+    unsigned char len;
+    unsigned char data[0];
+} TLV;
+
+static int hexCharToInt(char c) {
+    if (c >= '0' && c <= '9') return (c - '0');
+    if (c >= 'A' && c <= 'F') return (c - 'A' + 10);
+    if (c >= 'a' && c <= 'f') return (c - 'a' + 10);
+    return 0;
+}
+
+static int hexStringToBytes(const char * s, unsigned char *d) {
+    int sz, i;
+
+    if (!s || !strlen(s))
+        return 0;
+
+    sz = strlen(s) / 2;
+
+    for (i = 0; i < sz ; i++) {
+        d[i] = (unsigned char) ((hexCharToInt(s[i*2 + 0]) << 4) | hexCharToInt(s[i*2 + 1]));
+    }
+
+    return sz;
+}
+
+static TLV * getTLV(const unsigned char *d, unsigned char tag) {
+     TLV *tlv = (TLV *)d;
+     int sz = tlv->len;
+
+     tlv++; //skip head
+
+     while (sz) {
+        if (tlv->tag != tag) {
+            tlv = (TLV *)(((char *)tlv) + sizeof(TLV) + tlv->len);
+            sz -= sizeof(TLV) + tlv->len;
+        } else {
+        #if 0
+            int i;
+            printf("{%02x, %02x, ", tlv->tag, tlv->len);
+            for (i = 0; i < tlv->len; i++)
+                printf("%02x, ", tlv->data[i]);
+            printf("}\n");
+        #endif
+            return tlv;
+        }
+    }
+    return NULL;
+}
+
+//frameworks\base\telephony\java\com\android\internal\telephony\IccFileHandler.java
+//from TS 11.11 9.1 or elsewhere
+const int EF_ICCID  = 0x2fe2;
+const int COMMAND_READ_BINARY = 0xb0;     //176
+const int COMMAND_UPDATE_BINARY = 0xd6;   //214
+const int COMMAND_READ_RECORD = 0xb2;     //178
+const int COMMAND_UPDATE_RECORD = 0xdc;   //220
+const int COMMAND_SEEK = 0xa2;
+const int COMMAND_GET_RESPONSE = 0xc0;
+        
+//***** types of files  TS 11.11 9.3
+static const int EF_TYPE_TRANSPARENT = 0;
+static const int EF_TYPE_LINEAR_FIXED = 1;
+static const int EF_TYPE_CYCLIC = 3;
+
+//***** types of files  TS 11.11 9.3
+const int TYPE_RFU = 0;
+const int TYPE_MF  = 1;
+const int TYPE_DF  = 2;
+const int TYPE_EF  = 4;
+
+// Byte order received in response to COMMAND_GET_RESPONSE
+// Refer TS 51.011 Section 9.2.1
+const int RESPONSE_DATA_RFU_1 = 0;
+const int RESPONSE_DATA_RFU_2 = 1;
+
+const int RESPONSE_DATA_FILE_SIZE_1 = 2;
+const int RESPONSE_DATA_FILE_SIZE_2 = 3;
+
+const int RESPONSE_DATA_FILE_ID_1 = 4;
+const int RESPONSE_DATA_FILE_ID_2 = 5;
+const int RESPONSE_DATA_FILE_TYPE = 6;
+const int RESPONSE_DATA_RFU_3 = 7;
+const int RESPONSE_DATA_ACCESS_CONDITION_1 = 8;
+const int RESPONSE_DATA_ACCESS_CONDITION_2 = 9;
+const int RESPONSE_DATA_ACCESS_CONDITION_3 = 10;
+const int RESPONSE_DATA_FILE_STATUS = 11;
+const int RESPONSE_DATA_LENGTH = 12;
+const int RESPONSE_DATA_STRUCTURE = 13;
+const int RESPONSE_DATA_RECORD_LENGTH = 14;
+
+void usim2sim(RIL_SIM_IO_Response *psr) {
+    int sz;
+    int i;
+    unsigned char usim_data[1024];
+    unsigned char sim_data[15] = {0};
+    static char new_response[31];
+    TLV * tlv;
+    const char bytesToHexString[] = "0123456789abcdef";
+
+    if (!psr->simResponse)
+        return;
+
+    if (!strlen(psr->simResponse)) {
+        psr->simResponse = NULL;
+        return;
+    }
+
+    if (strlen(psr->simResponse) < 4)
+        return;
+
+    sz = hexStringToBytes(psr->simResponse, usim_data);
+
+    if (usim_data[0] != 0x62) {
+       RLOGD("CRSM: not usim");
+        return;
+    }
+
+    if (usim_data[1] != (sz - 2)) {
+        RLOGD("CRSM: error usim len");
+
+    }
+
+    tlv = getTLV(usim_data, 0x80);
+    if (tlv) {
+        RLOGD("CRSM: FILE_SIZE %02X%02X", tlv->data[0], tlv->data[1]);
+        sim_data[RESPONSE_DATA_FILE_SIZE_1] = tlv->data[0];
+        sim_data[RESPONSE_DATA_FILE_SIZE_2] = tlv->data[1];
+    }
+
+    tlv = getTLV(usim_data, 0x83);
+    if (tlv) {
+        RLOGD("CRSM: FILE_ID %02X%02X", tlv->data[0], tlv->data[1]);
+        sim_data[RESPONSE_DATA_FILE_ID_1] = tlv->data[0];
+        sim_data[RESPONSE_DATA_FILE_ID_2] = tlv->data[1];
+    }
+
+    tlv = getTLV(usim_data, 0x82);
+    if (tlv) {
+        int filetype = (tlv->data[0] >> 3) & 0x7;
+        int efstruct = (tlv->data[0] >> 0) & 0x7;
+        RLOGD("CRSM: len: %d, %02x %02x %02x %02x %02x", tlv->len, tlv->data[0], tlv->data[1], tlv->data[2], tlv->data[3], tlv->data[4]);
+
+        //File type:
+        if ((filetype == 0) || (filetype == 1)) {
+            RLOGD("CRSM: FILE_TYPE_EF");
+            sim_data[RESPONSE_DATA_FILE_TYPE] = TYPE_EF;
+        } else if ((filetype == 7) && (efstruct == 0)) {
+            RLOGD("CRSM: TYPE_DF");
+            sim_data[RESPONSE_DATA_FILE_TYPE] = TYPE_DF;
+        } else {
+            RLOGD("CRSM: TYPE_RFU");
+            sim_data[RESPONSE_DATA_FILE_TYPE] = TYPE_RFU;
+        }
+
+        //EF struct
+        if (efstruct == 1) {
+            RLOGD("CRSM: EF_TYPE_TRANSPARENT");
+            sim_data[RESPONSE_DATA_STRUCTURE] = EF_TYPE_TRANSPARENT;
+        } else if (efstruct == 2) {
+            RLOGD("CRSM: EF_TYPE_LINEAR_FIXED");
+            sim_data[RESPONSE_DATA_STRUCTURE] = EF_TYPE_LINEAR_FIXED;
+        } else if (efstruct == 3) {
+            RLOGD("CRSM: EF_TYPE_CYCLIC");
+            sim_data[RESPONSE_DATA_STRUCTURE] = EF_TYPE_CYCLIC;
+         } else {
+            RLOGD("CRSM: EF_TYPE_UNKNOWN");
+         }
+
+        if ((efstruct == 2) || (efstruct == 3)) {
+            if (tlv->len == 5) {
+                sim_data[RESPONSE_DATA_RECORD_LENGTH] = ((tlv->data[2] << 8) + tlv->data[3]) & 0xFF;
+               RLOGD("CRSM: RESPONSE_DATA_RECORD_LENGTH %d", sim_data[RESPONSE_DATA_RECORD_LENGTH]);
+            } else {
+                RLOGD("CRSM: must contain Record length and Number of records");
+            }
+        }
+    }
+
+    for (i = 0; i < 15; i++) {
+        new_response[i*2 + 0] =  bytesToHexString[0x0f & (sim_data[i] >> 4)];
+        new_response[i*2 + 1] =  bytesToHexString[0x0f & sim_data[i]];
+    }
+    new_response[30] = '\0';
+
+    psr->simResponse = new_response;
+
+//see telephony\src\java\com\android\internal\telephony\uicc\IccIoResult.java
+#if 0
+    /**
+     * true if this operation was successful
+     * See GSM 11.11 Section 9.4
+     * (the fun stuff is absent in 51.011)
+     */
+    public boolean success() {
+        return sw1 == 0x90 || sw1 == 0x91 || sw1 == 0x9e || sw1 == 0x9f;
+    }
+#endif
+    if (psr->sw1 == 0x90 || psr->sw1 == 0x91 || psr->sw1 == 0x9e || psr->sw1 == 0x9f)
+        ;
+    else
+        psr->sw1 = 0x90;
+
+    return;
+}
+#endif
+extern int odm_get_current_network_type();
+/* BEGIN: Added by eric.li, 2018/10/14   PN:add for sim io parse */
+#if 1
+#define RIL_SIMRECORDTYPE_UNKNOWN       (0x00000000)
+#define RIL_SIMRECORDTYPE_TRANSPARENT   (0x00000001)
+#define RIL_SIMRECORDTYPE_CYCLIC        (0x00000002)
+#define RIL_SIMRECORDTYPE_LINEAR        (0x00000003)
+#define RIL_SIMRECORDTYPE_MASTER        (0x00000004)
+#define RIL_SIMRECORDTYPE_DEDICATED     (0x00000005)
+
+typedef struct
+{
+    unsigned char m_bTag;
+    int  m_uLen;
+    unsigned char* m_pbValue;
+    int m_uTotalSize;
+}BerTlv;
+
+struct sUSIMGetResponse
+{
+    int dwRecordType;
+    //UINT32 dwItemCount;
+    int dwTotalSize;
+    int dwRecordSize;
+};
+
+unsigned char PrintStringNullTerminate(char* pszOut, int cbOut, char* pszFormat, ... )
+{
+    unsigned char fRet = true;
+    int iWritten;
+
+    //RIL_LOG_VERBOSE("PrintStringNullTerminate() - Enter\r\n");
+
+    va_list args;
+    va_start(args, pszFormat);
+
+    iWritten = vsnprintf(pszOut, cbOut, pszFormat, args);
+
+    if (0 > iWritten)
+    {
+        fRet = false;
+        pszOut[0] = '\0';
+    }
+    else if ((int)iWritten >= cbOut)
+    {
+        fRet = false;
+        pszOut[cbOut - 1] = '\0';
+    }
+
+    va_end(args);
+
+    //RIL_LOG_VERBOSE("PrintStringNullTerminate() - Exit\r\n");
+    return fRet;
+}
+
+
+static unsigned char Parse(unsigned char* pRawData, int cbSize, BerTlv * pBerTlv)
+{
+    if (2 > cbSize) {
+        // Not enough data for a TLV.
+        return false;
+    }
+
+    // Tag at index 0.
+    unsigned char bTag = pRawData[0];
+    if (0x00 == bTag ||
+        0xFF == bTag)
+    {
+        // Invalid Tag
+        return false;
+    }
+
+    // Encoded length starts at index 1
+    unsigned char bValuePos = 0;
+    int uLen = 0;
+
+    if (0x80 == (0x80 & pRawData[1])) {
+        unsigned char bLenBytes = 0x7F & pRawData[1];
+
+        if (1 < bLenBytes ||
+            3 > cbSize) {
+            // Currently only support 1 extra length byte
+            return false;
+        }
+
+        uLen = pRawData[2];
+        bValuePos = 3;
+    }
+     else {
+        uLen = pRawData[1];
+        bValuePos = 2;
+    }
+
+    // Verify there is enough data available for the value
+    if (uLen + bValuePos > cbSize) {
+        return false;
+    }
+
+    // Verify length and value size are consistent.
+    if (cbSize - bValuePos < uLen) {
+        // Try and recover using the minimum value.
+        uLen = cbSize - bValuePos;
+    }
+
+    pBerTlv->m_bTag = bTag;
+    pBerTlv->m_uLen = uLen;
+    pBerTlv->m_pbValue = pRawData + bValuePos;
+    pBerTlv->m_uTotalSize = uLen + bValuePos;
+
+    return true;
+}
+
+
+static unsigned char ParseUSIMRecordStatus(unsigned char* sResponse, int cbResponse, struct sUSIMGetResponse* sUSIM)
+{
+    RLOGD("ParseUSIMRecordStatus - ENTER\r\n");
+
+    unsigned char bRet = false;
+
+    unsigned char FCP_TAG = 0x62;
+    unsigned char FILE_SIZE_TAG = 0x80;
+    unsigned char FILE_DESCRIPTOR_TAG = 0x82;
+    unsigned char FILE_ID_TAG = 0x83;
+    int MASTER_FILE_ID = 0x3F00;
+    int dwRecordType = 0;
+    int dwItemCount = 0;
+    int dwRecordSize = 0;
+    int dwTotalSize = 0;
+    BerTlv tlvFileDescriptor = {0};
+    BerTlv tlvFcp = {0};
+                // Retrieve the file size.
+    BerTlv tlvCurrent = {0};
+                        // Next data object should be File ID.
+
+    unsigned char* pbFcpData = NULL;
+    int cbFcpDataSize = 0;
+    int cbDataUsed = 0;
+    unsigned char* pbFileDescData = NULL;
+    int cbFileDescDataSize = 0;
+
+    unsigned char fIsDf = false;
+    unsigned char bEfStructure = 0;
+
+    if (NULL == sResponse ||
+        0 == cbResponse ||
+        NULL == sUSIM)
+    {
+        RLOGD("ParseUSIMRecordStatus - Input parameters\r\n");
+        goto Error;
+    }
+
+    // Need at least 2 bytes for response data FCP (file control parameters)
+    if (2 > cbResponse)
+    {
+       RLOGD("ParseUSIMRecordStatus - Need at least 2 bytes for response data\r\n");
+        goto Error;
+    }
+
+    // Validate this response is a 3GPP 102 221 SELECT response.
+    Parse(sResponse, cbResponse, &tlvFcp);
+    if (FCP_TAG != tlvFcp.m_bTag)
+    {
+        RLOGD("ParseUSIMRecordStatus - First tag is not FCP.  Tag=[0x%02X]\r\n",
+                tlvFcp.m_bTag);
+        goto Error;
+    }
+
+    if (cbResponse != tlvFcp.m_uTotalSize)
+    {
+        RLOGD("ParseUSIMRecordStatus -"
+                " cbResponse=[%d] not equal to total size=[%d]\r\n",
+                cbResponse, tlvFcp.m_uTotalSize);
+        goto Error;
+    }
+    pbFcpData = tlvFcp.m_pbValue;
+    cbFcpDataSize = tlvFcp.m_uLen;
+
+    // Retrieve the File Descriptor data object
+    Parse(pbFcpData, cbFcpDataSize,&tlvFileDescriptor);
+    if (FILE_DESCRIPTOR_TAG != tlvFileDescriptor.m_bTag)
+    {
+        RLOGD("ParseUSIMRecordStatus -"
+                " File descriptor tag is not FCP.  Tag=[0x%02X]\r\n", tlvFileDescriptor.m_bTag);
+        goto Error;
+    }
+
+    cbDataUsed = tlvFileDescriptor.m_uTotalSize;
+    if (cbDataUsed > cbFcpDataSize)
+    {
+        RLOGD("ParseUSIMRecordStatus -"
+                " cbDataUsed=[%d] is greater than cbFcpDataSize=[%d]\r\n",
+                cbDataUsed, cbFcpDataSize);
+        goto Error;
+    }
+
+    pbFileDescData = tlvFileDescriptor.m_pbValue;
+    cbFileDescDataSize = tlvFileDescriptor.m_uLen;
+    // File descriptors should only be 2 or 5 bytes long.
+    if((2 != cbFileDescDataSize) && (5 != cbFileDescDataSize))
+    {
+        RLOGD("ParseUSIMRecordStatus -"
+                " File descriptor can only be 2 or 5 bytes.  cbFileDescDataSize=[%d]\r\n",
+                cbFileDescDataSize);
+        goto Error;
+
+    }
+    if (2 > cbFileDescDataSize)
+    {
+        RLOGD("ParseUSIMRecordStatus -"
+                " File descriptor less than 2 bytes.  cbFileDescDataSize=[%d]\r\n",
+                cbFileDescDataSize);
+        goto Error;
+    }
+
+    fIsDf = (0x38 == (0x38 & pbFileDescData[0]));
+    bEfStructure = (0x07 & pbFileDescData[0]);
+
+
+    RLOGD("ParseUSIMRecordStatus: fIsDf = %u , bEfStructure = %u \r\n",fIsDf, bEfStructure);
+
+    if (fIsDf)
+    {
+        dwRecordType = RIL_SIMRECORDTYPE_DEDICATED;
+    }
+    // or it is an EF or MF.
+    else
+    {
+        switch (bEfStructure)
+        {
+            // Transparent
+            case 0x01:
+                dwRecordType = RIL_SIMRECORDTYPE_TRANSPARENT;
+                break;
+
+            // Linear Fixed
+            case 0x02:
+                dwRecordType = RIL_SIMRECORDTYPE_LINEAR;
+                break;
+
+            // Cyclic
+            case 0x06:
+                dwRecordType = RIL_SIMRECORDTYPE_CYCLIC;
+                break;
+
+           default:
+                break;
+        }
+
+        if (RIL_SIMRECORDTYPE_LINEAR == dwRecordType ||
+            RIL_SIMRECORDTYPE_CYCLIC == dwRecordType)
+        {
+            // Need at least 5 bytes
+            if (5 > cbFileDescDataSize)
+            {
+                RLOGD("ParseUSIMRecordStatus -"
+                        " File descriptor less than 5 bytes.  cbFileDescDataSize=[%d]\r\n",
+                        cbFileDescDataSize);
+                goto Error;
+            }
+
+            dwItemCount = pbFileDescData[4];
+            dwRecordSize = (pbFileDescData[2] << 4) + (pbFileDescData[3]);
+
+            // Skip checking of consistency with the File Size data object to
+            // save time.
+            dwTotalSize = dwItemCount * dwRecordSize;
+        }
+        else if(RIL_SIMRECORDTYPE_TRANSPARENT == dwRecordType)
+        {
+            while (cbFcpDataSize > cbDataUsed)
+            {
+                if (!Parse(
+                    pbFcpData + cbDataUsed,
+                    cbFcpDataSize - cbDataUsed,&tlvCurrent))
+                {
+                    RLOGD("ParseUSIMRecordStatus - Couldn't parse TRANSPARENT\r\n");
+                    goto Error;
+                }
+
+                cbDataUsed += tlvCurrent.m_uTotalSize;
+
+                if (FILE_SIZE_TAG == tlvCurrent.m_bTag)
+                {
+                    unsigned char* pbFileSize = NULL;
+
+                    if (2 > tlvCurrent.m_uLen)
+                    {
+                        RLOGD("ParseUSIMRecordStatus -"
+                                " TRANSPARENT length must be at least 2\r\n");
+                        goto Error;
+                    }
+
+                    pbFileSize = tlvCurrent.m_pbValue;
+
+                    dwTotalSize = (pbFileSize[0] << 4) + pbFileSize[1];
+
+                    // Size found. Leave loop
+                    break;
+                }
+            }
+        }
+    }
+
+    // if record type has not been resolved, check for Master file.
+    if (RIL_SIMRECORDTYPE_UNKNOWN == dwRecordType)
+    {
+        unsigned char* pbFileId = NULL;
+        int uFileId = 0;
+        BerTlv tlvFileId = {0};
+
+        // Next data object should be File ID.
+        Parse(
+            pbFcpData + cbFcpDataSize,
+            cbFcpDataSize - cbDataUsed, &tlvFileId);
+
+        if (FILE_ID_TAG != tlvFileId.m_bTag)
+        {
+            RLOGD("ParseUSIMRecordStatus - UNKNOWN tag not equal to FILE_ID_TAG\r\n");
+            goto Error;
+        }
+
+        if (2 != tlvFileId.m_uLen)
+        {
+            RLOGD("ParseUSIMRecordStatus - UNKNOWN length not equal to 2\r\n");
+            goto Error;
+        }
+
+        pbFileId = tlvFileId.m_pbValue;
+        uFileId = (pbFileId[0] << 4) + pbFileId[1];
+
+        if (MASTER_FILE_ID != uFileId)
+        {
+            RLOGD("ParseUSIMRecordStatus -"
+                    " UNKNOWN file ID not equal to MASTER_FILE_ID\r\n");
+            goto Error;
+        }
+
+        dwRecordType = RIL_SIMRECORDTYPE_MASTER;
+    }
+
+    sUSIM->dwRecordType = dwRecordType;
+    sUSIM->dwTotalSize = dwTotalSize;
+    sUSIM->dwRecordSize = dwRecordSize;
+
+    bRet = true;
+Error:
+
+    RLOGD("ParseUSIMRecordStatus - EXIT = [%d]\r\n", bRet);
+    return bRet;
+}   
+
+
+static  unsigned char SemiByteCharsToByte(char chHigh, char chLow)
+{
+    unsigned char bRet;
+
+    if ('0' <= chHigh && '9' >= chHigh)
+    {
+        bRet = (chHigh - '0') << 4;
+    }
+    else
+    {
+        bRet = (0x0a + chHigh - 'A') << 4;
+    }
+
+    if ('0' <= chLow && '9' >= chLow)
+    {
+        bRet |= (chLow - '0');
+    }
+    else
+    {
+        bRet |= (0x0a + chLow - 'A');
+    }
+    return bRet;
+}
+
+static unsigned char GSMHexToGSM(char* sIn, int cbIn, unsigned char* sOut,
+                            int cbOut, int* rcbUsed)
+{
+    char* pchIn = sIn;
+    char* pchInEnd = sIn + cbIn;
+    unsigned char* pchOut = sOut;
+    unsigned char* pchOutEnd = sOut + cbOut;
+    unsigned char fRet = false;
+
+    while (pchIn < pchInEnd - 1 && pchOut < pchOutEnd)
+    {
+        *pchOut++ = SemiByteCharsToByte(*pchIn, *(pchIn + 1));
+        pchIn += 2;
+    }
+
+    *rcbUsed = pchOut - sOut;
+    fRet = true;
+    return fRet;
+}
+
+static unsigned char CopyStringNullTerminate(char* pszOut, char* pszIn, int cbOut)
+{
+    unsigned char fRet = true;
+    int cbIn = 0;
+
+    //RIL_LOG_VERBOSE("CopyStringNullTerminate() - Enter\r\n");
+
+    if ((NULL != pszIn) && (NULL != pszOut))
+    {
+        cbIn = strlen(pszIn);
+
+        strncpy(pszOut, pszIn, cbOut);
+
+        //  Klokworks fix here
+        pszOut[cbOut - 1] = '\0';
+        //  End Klokworks fix
+
+        if (cbOut <= cbIn)
+        {
+            fRet = false;
+        }
+    }
+
+    //RIL_LOG_VERBOSE("CopyStringNullTerminate() - Exit\r\n");
+
+    return fRet;
+}
+
+static long ParseSimIo(char *line, int command, RIL_SIM_IO_Response *pResponse)
+{
+     RLOGD("ParseSimIo() - Enter\r\n");
+
+    long res = RIL_E_GENERIC_FAILURE;
+    char* pszRsp = NULL;
+    int err = 0;
+
+    int  uiSW1 = 0;
+    int  uiSW2 = 0;
+    char* szResponseString = NULL;
+    int  cbResponseString = 0;
+    char m_szNewLine[3];
+    
+    CopyStringNullTerminate(m_szNewLine, "\r\n", sizeof(m_szNewLine));
+
+    err = at_tok_start(&line);
+    if (err < 0) goto Error;
+
+    err = at_tok_nextint(&line, &uiSW1);
+    if (err < 0) goto Error;
+
+    err = at_tok_nextint(&line, &uiSW2);
+    if (err < 0) goto Error;
+
+    if (at_tok_hasmore(&line)) {
+        err = at_tok_nextstr(&line, &pszRsp);
+        if (err < 0) goto Error;
+    }
+
+    RLOGD("ParseSimIo() - Extracted SW1 = %u and SW2 = %u\r\n", uiSW1, uiSW2);
+
+   // Parse <response>
+   // NOTE: we take ownership of allocated szResponseString
+   RLOGD("ParseSimIo():pszRsp:%s\r\n",pszRsp);
+
+   if(NULL == pszRsp)
+   {
+       RLOGD("ParseSimIo:pszRsp == NULL !!!\r\n");
+       goto Error;
+   }
+   
+   cbResponseString = strlen(pszRsp) + 1;
+   szResponseString = (char*)malloc(cbResponseString);
+
+    if (NULL == szResponseString)
+    {
+        RLOGE("ParseSimIo()+++3\r\n");
+        goto Error;
+    }
+
+    memset(szResponseString, 0, cbResponseString);
+    strncpy(szResponseString, pszRsp, cbResponseString);
+
+    RLOGD("ParseSimIo() -"
+                    " Extracted data string: \"%s\" (%u chars including NULL)\r\n",
+                   szResponseString, cbResponseString);
+    if (0 != (cbResponseString - 1) % 2)
+    {
+       RLOGD("ParseSimIo() : String was not a multiple of 2.\r\n");
+       goto Error;
+    }
+
+    if ((192 == command) && ('6' == szResponseString[0]) && ('2' == szResponseString[1]))
+    {
+            //  USIM GET_RESPONSE response
+       // RIL_LOG_INFO("CTE_XMM6260::ParseSimIo() - USIM GET_RESPONSE\r\n");
+        char szTemp[5] = {0};
+        struct sUSIMGetResponse sUSIM;
+        memset(&sUSIM, 0, sizeof(struct sUSIMGetResponse));
+
+            //  Need to convert the response string from ascii to binary.
+        
+        int cbNewString = (cbResponseString-1)/2;
+        unsigned char *sNewString = (unsigned char*)malloc(cbNewString);
+        
+        if (NULL == sNewString)
+        {
+           // RIL_LOG_CRITICAL("CTE_XMM6260::ParseSimIo() - Cannot create new string!\r\n");
+            goto Error;
+        }
+        memset(sNewString, 0, cbNewString);
+
+        int cbUsed = 0;
+        if (!GSMHexToGSM(szResponseString, cbResponseString, sNewString, cbNewString, &cbUsed))
+        {
+            RLOGD("CTE_XMM6260::ParseSimIo() -"
+                   " Cannot cconvert szResponseString to GSMHex.\r\n");
+            free(sNewString);
+            sNewString = NULL;
+            cbNewString = 0;
+            goto Error;
+        }
+
+        //  OK, now parse!
+        if (!ParseUSIMRecordStatus((unsigned char*)sNewString, cbNewString, &sUSIM))
+        {
+            //RIL_LOG_CRITICAL("CTE_XMM6260::ParseSimIo() - Cannot parse USIM record status\r\n");
+            free(sNewString);
+            sNewString = NULL;
+            cbNewString = 0;
+            goto Error;
+        }
+
+
+        free(sNewString);
+        sNewString = NULL;
+        cbNewString = 0;
+
+        RLOGD("ParseSimIo() - sUSIM.dwRecordType=[0x%04X]\r\n",
+                sUSIM.dwRecordType);
+        RLOGD("ParseSimIo() - sUSIM.dwTotalSize=[0x%04X]\r\n",
+                sUSIM.dwTotalSize);
+        RLOGD("ParseSimIo() - sUSIM.dwRecordSize=[0x%04X]\r\n",
+                sUSIM.dwRecordSize);
+
+        //  Delete old original response.  Create new "fake" response.
+        free(szResponseString);
+        szResponseString = NULL;
+        cbResponseString = 0;
+
+        //  Java layers as of Froyo (Nov 1/2010) only use:
+        //  Total size (0-based bytes 2 and 3), File type (0-based byte 6),
+        //  Data structure (0-based byte 13), Data record length (0-based byte 14)
+        cbResponseString = 31;  //  15 bytes + NULL
+        szResponseString = (char*)malloc(cbResponseString);
+        if (NULL == szResponseString)
+        {
+           RLOGE("CTE_XMM6260::ParseSimIo() -"
+                    " Cannot create new szResponsestring!\r\n");
+            free(sNewString);
+            sNewString = NULL;
+            goto Error;
+        }
+        if (!CopyStringNullTerminate(szResponseString,
+                "000000000000000000000000000000", cbResponseString))
+        {
+            RLOGD("CTE_XMM6260::ParseSimIo() -"
+                    " Cannot CopyStringNullTerminate szResponsestring!\r\n");
+            free(sNewString);
+            sNewString = NULL;
+            goto Error;
+        }
+
+        //  Extract info, put into new response string
+        if (!PrintStringNullTerminate(szTemp, 5, "%04X", sUSIM.dwTotalSize))
+        {
+            RLOGE("CTE_XMM6260::ParseSimIo() -"
+                    " Cannot PrintStringNullTerminate sUSIM.dwTotalSize!\r\n");
+            free(sNewString);
+            sNewString = NULL;
+            goto Error;
+        }
+        memcpy(&szResponseString[4], szTemp, 4);
+
+        if (!PrintStringNullTerminate(szTemp, 3, "%02X", sUSIM.dwRecordSize))
+        {
+           RLOGD("CTE_XMM6260::ParseSimIo() -"
+                    " Cannot PrintStringNullTerminate sUSIM.dwRecordSize!\r\n");
+            free(sNewString);
+            sNewString = NULL;
+            goto Error;
+        }
+        memcpy(&szResponseString[28], szTemp, 2);
+
+        if (RIL_SIMRECORDTYPE_UNKNOWN == sUSIM.dwRecordType)
+        {
+            //  bad parse.
+            RLOGD("CTE_XMM6260::ParseSimIo() -"
+                    " sUSIM.dwRecordType is unknown!\r\n");
+            free(sNewString);
+            sNewString = NULL;
+            goto Error;
+        }
+
+
+        if (RIL_SIMRECORDTYPE_MASTER == sUSIM.dwRecordType)
+        {
+            szResponseString[13] = '1';
+        }
+        else if (RIL_SIMRECORDTYPE_DEDICATED == sUSIM.dwRecordType)
+        {
+            szResponseString[13] = '2';
+        }
+        else
+        {
+            //  elementary file
+            szResponseString[13] = '4';
+
+            if (RIL_SIMRECORDTYPE_TRANSPARENT == sUSIM.dwRecordType)
+            {
+                szResponseString[27] = '0';
+            }
+            else if (RIL_SIMRECORDTYPE_LINEAR == sUSIM.dwRecordType)
+            {
+                szResponseString[27] = '1';
+            }
+            else if (RIL_SIMRECORDTYPE_CYCLIC == sUSIM.dwRecordType)
+            {
+                szResponseString[27] = '3';
+            }
+        }
+
+        //  ok we're done.  print.
+        RLOGD("ParseSimIo() - new USIM response=[%s]\r\n",
+                szResponseString);
+
+    }
+
+    // Allocate memory for the response struct PLUS a buffer for the response string
+    // The char* in the RIL_SIM_IO_Response will point to the buffer allocated directly after the
+    // RIL_SIM_IO_Response, When the RIL_SIM_IO_Response is deleted, the corresponding response
+    // string will be freed as well.
+    //pResponse = (RIL_SIM_IO_Response*)malloc(sizeof(RIL_SIM_IO_Response) + cbResponseString + 1);
+    pResponse->simResponse = (char *)malloc(cbResponseString + 1);
+    if (NULL == pResponse->simResponse)
+    {
+        RLOGD("CTE_XMM6260::ParseSimIo() -"
+                " Could not allocate memory for a RIL_SIM_IO_Response struct.\r\n");
+        goto Error;
+    }
+    
+    memset(pResponse->simResponse, 0, cbResponseString + 1);
+    pResponse->sw1 = uiSW1;
+    pResponse->sw2 = uiSW2;
+
+    if (NULL == szResponseString)
+    {
+        free(pResponse->simResponse);
+        pResponse->simResponse = NULL;
+    }
+    else
+    {
+        if (!CopyStringNullTerminate(pResponse->simResponse, szResponseString, cbResponseString))
+        {
+           RLOGE("CTE_XMM6260::ParseSimIo() -"
+                    " Cannot CopyStringNullTerminate szResponseString\r\n");
+            goto Error;
+        }
+
+        // Ensure NULL termination!
+        pResponse->simResponse[cbResponseString] = '\0';
+    }
+
+    res = RIL_E_SUCCESS;
+
+Error:
+    if (RIL_E_SUCCESS != res)
+    {
+        free(pResponse->simResponse);
+        pResponse->simResponse = NULL;
+    }
+
+    free(szResponseString);
+    szResponseString = NULL;
+
+   RLOGD("CTE_XMM6260::ParseSimIo() - Exit\r\n");
+    return res;
+}
+#endif
+/* END:   Added by eric.li, 2018/10/14   PN:add for sim io parse */
+
+
+
+void  requestSIM_IO(void *data, size_t datalen __unused, RIL_Token t)
+{
+    ATResponse *p_response = NULL;
+    RIL_SIM_IO_Response sr;
+    int err;
+    char *cmd = NULL;
+    RIL_SIM_IO_v6 *p_args;
+    char *line;
+    unsigned int i = 0;
+    ATResponse *qccid_response = NULL;
+    char iccid_low = 0;
+    int command =0;
+    memset(&sr, 0, sizeof(sr));
+
+    p_args = (RIL_SIM_IO_v6 *)data;
+    command = p_args->command;
+
+    if (p_args->command == COMMAND_GET_RESPONSE) {
+        p_args->p3 = 0;
+    }
+
+    if((mode_flag  == GHT_FG621) ||(mode_flag == GHT_FG650) || (mode_flag == GHT_L610) || (GHT_MC919 == mode_flag) || (GHT_MC66x == mode_flag))
+    {
+        if (p_args->data == NULL) 
+        {
+                    asprintf(&cmd, "AT+CRSM=%d,%d,%d,%d,%d",
+                    p_args->command, p_args->fileid,
+                    p_args->p1, p_args->p2, p_args->p3);
+        }
+        else
+        {
+                    asprintf(&cmd, "AT+CRSM=%d,%d,%d,%d,%d,\"%s\"",
+                    p_args->command, p_args->fileid,
+                    p_args->p1, p_args->p2, p_args->p3, p_args->data);
+        }
+    }
+    else
+    {
+        
+        if (p_args->data == NULL) {
+                asprintf(&cmd, "AT+CRSM=%d,%d,%d,%d,%d,,\"%s\"",
+                            p_args->command, p_args->fileid,
+                            p_args->p1, p_args->p2, p_args->p3, p_args->path);
+            }
+            else
+            {
+                asprintf(&cmd, "AT+CRSM=%d,%d,%d,%d,%d,\"%s\",\"%s\"",
+                            p_args->command, p_args->fileid,
+                            p_args->p1, p_args->p2, p_args->p3, p_args->data, p_args->path);
+            }
+    }
+    
+    err = at_send_command_singleline(cmd, "+CRSM:", &p_response);
+
+    if (err < 0 || p_response->success == 0) {
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(sr.sw1));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(sr.sw2));
+    if (err < 0) goto error;
+
+    if (at_tok_hasmore(&line)) {
+        err = at_tok_nextstr(&line, &(sr.simResponse));
+        if (err < 0) goto error;
+    }
+
+
+//see telephony\src\java\com\android\internal\telephony\uicc\IccFileHandler.java handleMessage() -> case EVENT_GET_BINARY_SIZE_DONE:
+    if (p_args->command == COMMAND_GET_RESPONSE)
+    {
+        usim2sim(&sr);
+    }
+
+
+    RLOGD("[%s]: RIL_SIM_IO_Response Complete sr.sw1=%d, sr.sw2=%d, sr.simResponse=%s",
+        __func__, sr.sw1, sr.sw2, sr.simResponse);
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        if(!sr.sw1 && !sr.sw2)
+        {
+            goto error;
+        }
+    }
+
+#if 0
+/*SIM_IO request: Abnormal handling of telecom card data reading, lisf 20181207*/
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+   if(!sr.sw1 && !sr.sw2)
+  {
+        goto error;
+   }
+#endif
+#endif
+
+    if (p_args->fileid == EF_ICCID && sr.simResponse == NULL)
+        goto error;
+    
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, &sr, sizeof(sr));
+    at_response_free(p_response);
+    free(cmd);
+
+    return;
+error:
+    if (p_args->fileid == EF_ICCID) {
+        sr.sw1 = 144;
+        sr.sw2 = 0;
+        sr.simResponse = NULL;
+        if (p_args->command == COMMAND_GET_RESPONSE) {
+            sr.simResponse = "0000000a2fe2040000000000000000";
+        } else if (p_args->command == COMMAND_READ_BINARY) {
+#define TELCOMM_DUMMY_ICCID "98681031098310024233"
+            err = at_send_command_singleline("AT+CCID?", "+CCID: ", &qccid_response);
+            if (err < 0 || qccid_response == NULL || qccid_response->success == 0) {
+                sr.simResponse = TELCOMM_DUMMY_ICCID;
+            } else {
+            line = qccid_response->p_intermediates->line;
+            if (0 == at_tok_start(&line) && 0 == at_tok_nextstr(&line, &sr.simResponse)) {
+                for (i = 0; i < strlen(sr.simResponse); i+=2) {
+                    if ((strlen(sr.simResponse) - 1) < (i+1)) {
+                        sr.simResponse = TELCOMM_DUMMY_ICCID;
+                    } else {
+                        iccid_low = sr.simResponse[i];
+                        sr.simResponse[i] = sr.simResponse[i+1];
+                        sr.simResponse[i+1] = iccid_low;
+                    }
+                }
+            } else {
+                sr.simResponse = TELCOMM_DUMMY_ICCID;
+            }
+            }
+        }
+        if (sr.simResponse != NULL) {
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &sr, sizeof(sr));
+            at_response_free(p_response);
+            free(cmd);
+            if (NULL != qccid_response) {
+                at_response_free(qccid_response);
+                qccid_response = NULL;
+            }
+            return;
+        }
+    }
+    RLOGD("%s error\n", __func__);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+    free(cmd);
+    if (NULL != qccid_response) {
+        at_response_free(qccid_response);
+    }
+}
+
+/* BEGIN: Added by eric.li, 2018/12/26   PN:function check facility */
+static int odm_check_facility_cmd(char *facility_string)
+{
+    ATResponse   *p_response = NULL;
+    char *line;
+    char *cmd = NULL;
+    int  response = -1;
+    int err;
+
+    if (NULL == facility_string)
+    {
+        RLOGD("facility_string is NULL");
+        goto error;	
+    }
+
+    asprintf(&cmd, "AT+CLCK=\"%s\",2", facility_string);
+
+    err = at_send_command_singleline(cmd, "+CLCK:", &p_response);
+
+    if (NULL != cmd)
+    {
+        free(cmd);
+        cmd = NULL;
+    }
+
+    if (err < 0 || p_response->success == 0)
+    {
+        goto error;
+    }
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0)
+    {
+        goto error;
+    }
+
+    err = at_tok_nextint(&line, &response);
+    if (err < 0)
+    {
+        goto error;
+    }
+
+    at_response_free(p_response);
+    RLOGD("odm_check_clck_cmd response[%d]", response);
+    return response;
+
+    error:
+    RLOGD("odm_check_clck_cmd err happened!!!!!!");
+    at_response_free(p_response);
+    return -1;
+}
+/* END:   Added by eric.li, 2018/12/26   PN:function check facility */
+//duanshitao add for sim pin and puk 20101122
+
+void  requestQueryFacilityLock(void*  data, size_t  datalen __unused, RIL_Token  t)
+{
+    int  response;
+    char *facility_string = NULL;
+    char *facility_password = NULL;
+    char *facility_class = NULL;
+
+    assert (datalen >=  (3 * sizeof(char **)));
+
+    facility_string   = ((char **)data)[0];
+    facility_password = ((char **)data)[1];
+    facility_class    = ((char **)data)[2];
+/*begin:modified by lisf 20181116 for check sim lock status*/
+
+	RLOGD("%s facility_string[%s];facility_password[%s]facility_class[%s] ", __FUNCTION__,facility_string, facility_password, facility_class);
+
+    if (strcmp("SC", facility_string) == 0)
+    {
+        switch (gSimStatus)
+        {
+            case    SIM_READY: /* SIM_READY means the radio state is RADIO_STATE_SIM_READY */
+                response =0;
+                break;
+
+            case    SIM_PIN:
+            case    SIM_PUK:
+            case    SIM_NETWORK_PERSONALIZATION:
+                response = 1;
+                break;
+
+            case   SIM_ABSENT :
+            case    SIM_NOT_READY :	   
+                default :
+                response = -1; 
+                break;
+        }
+        
+        if (0 == response)
+        {
+            //need check if CLCK locked.
+            //instead using AT+CLCK="SC",2 directly to check, as this AT cmd always block too much time leading timeout to reset modem
+            response = odm_check_facility_cmd(facility_string);				
+        }
+        RLOGD("%s getSIMStatus response [%d],   gSimStatus:%d(%s)", __FUNCTION__, response, gSimStatus, simStatusToString(gSimStatus));
+        if((0 == response) || (1 == response))
+        {
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(int));
+            return;
+        }
+        else
+        {
+            // response equal -1, unsol RIL_E_GENERIC_FAILURE for now;
+            goto error;
+        }
+        /*end:modified by lisf 20181116 for check sim lock status*/
+    }
+    else
+    {
+    	response = odm_check_facility_cmd(facility_string);
+    	RLOGD("other facility_string[%s] response[%d]", facility_string, response);
+    	if (-1 == response)
+    		goto error;
+
+		RIL_onRequestComplete(t, RIL_E_SUCCESS, &response, sizeof(int));
+		return;
+	}
+
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    return;
+}
+
+void  requestSetFacilityLock(void*  data, size_t  datalen __unused, RIL_Token  t)
+{
+    ATResponse   *p_response = NULL;
+    ATResponse     *pin_response =NULL;
+    int           err;
+    char*         cmd = NULL;
+    char pin = 0;
+    int rc=0;
+    int response[2];
+    char *nettypeline;
+
+    char *facility_string = NULL;
+    char *facility_mode = NULL;
+    char *facility_password = NULL;
+
+    /*begin:added by lisf 20181121*/
+    int network_type = 0;
+    network_type = odm_get_current_network_type();
+    /*end:added by lisf 20181121*/
+    assert(datalen >= (4 * sizeof(char **)));
+
+    facility_string = ((char **) data)[0];
+    facility_mode = ((char **) data)[1];
+    facility_password = ((char **) data)[2];
+
+    if (strcmp("SC", facility_string) == 0)
+    {
+        pin = 1;
+    }
+
+/*begin:modified by lisf 20181121*/
+	if(6 == network_type || 7 ==network_type || 13 ==network_type)
+/*end:modified by lisf 20181121*/
+    {
+        asprintf(&cmd, "AT+QCLCK=\"%s\",%s,\"%s\"", facility_string, facility_mode, facility_password);
+    }
+    else
+    {
+        asprintf(&cmd, "AT+CLCK=\"%s\",%s,\"%s\"", facility_string, facility_mode, facility_password);
+    }
+
+    err = at_send_command(cmd, &p_response);
+
+    if (err < 0 || p_response->success == 0)
+    {
+        if (pin == 1)
+        {
+            //<!--[ODM]wangmengying@2019.07.31 modify PIN related AT
+            if (GHT_NL668 <= mode_flag)
+            // end-->
+            {
+                rc = at_send_command_singleline("AT+TPIN?","+TPIN:",&pin_response);
+            }
+            else
+            {
+                rc = at_send_command_singleline("AT+PINPUK=?", "+PINPUK:",&pin_response);
+            }
+
+            if (rc < 0 || pin_response->success == 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                goto error;
+            }
+
+            nettypeline = pin_response->p_intermediates->line;
+            rc = at_tok_start(&nettypeline);
+            if (rc < 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                goto error;
+            }
+
+            rc= at_tok_nextint(&nettypeline, &(response[0]));
+            if (rc < 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                goto error;
+            }
+        }
+
+        if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+        {
+            RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, &response[0], sizeof(int));
+        }
+        else
+        {
+            RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+            RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, &response[0], sizeof(int *));
+        }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, &response[0], sizeof(int));
+#else
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, &response[0], sizeof(int *));
+#endif
+#endif
+    }
+    else
+    {
+        if (pin == 1)
+        {
+            response[0]=3;
+
+            if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+            {
+                RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                RIL_onRequestComplete(t, RIL_E_SUCCESS, &response[0], sizeof(int));
+            }
+            else
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                RIL_onRequestComplete(t, RIL_E_SUCCESS, &response[0], sizeof(int *));
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &response[0], sizeof(int));
+#else
+
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &response[0], sizeof(int *));
+#endif
+#endif
+        }
+    }
+
+error:
+    at_response_free(p_response);
+    at_response_free(pin_response);
+}
+
+//void  requestEnterSimPin(void*  data, size_t  datalen, RIL_Token  t)
+void  requestEnterSimPin(int request, void*  data, size_t  datalen __unused, RIL_Token  t)
+{
+    ATResponse   *p_response = NULL;
+    ATResponse   *pin_response = NULL;
+    int           err;
+    int           num_retries = -1;
+    char*         cmd = NULL;
+    const char**  strings = (const char**)data;
+    int response[2];
+    int rc=0;
+    char *nettypeline = NULL;
+    int count = 0;
+
+    //printf(&cmd, "AT+CPIN=%s", strings[0]);
+    if (( datalen == sizeof(char*)) || !strings[1] || !strings[1][0])
+    {
+    // <!--added by wangmengying@2020.2.12 fix bug40734,AT+CPIN="xxxx"
+        asprintf(&cmd, "AT+CPIN=\"%s\"", strings[0]);
+    // end--!>
+    }
+    else
+    {
+        asprintf(&cmd, "AT+CPIN=\"%s\",\"%s\"", strings[0], strings[1]);
+    }
+
+    err = at_send_command(cmd, &p_response);
+    RLOGD("EnterSimPin return err = %d, p_response->success = %d", err, p_response->success);
+    free(cmd);
+    cmd =NULL;
+
+    //<!--[ODM]wangmengying@2019.07.31 modify PIN related AT
+    if (GHT_NL668 <= mode_flag )
+    // end-->
+    {
+        if (err < 0 || p_response->success == 0)
+        {
+            rc = at_send_command_singleline("AT+TPIN?","+TPIN:",&pin_response);
+
+            if (rc < 0 || pin_response->success == 0)
+            {
+                goto error1;
+            }
+            nettypeline = pin_response->p_intermediates->line;
+            rc = at_tok_start(&nettypeline);
+            if (rc < 0)
+            {
+                goto error1;
+            }
+
+            rc = at_tok_nextint(&nettypeline, &num_retries);
+            if (rc < 0)
+            {
+                goto error_668;
+            }
+
+            if (request == RIL_REQUEST_ENTER_SIM_PUK)
+            {
+                err = at_tok_nextint(&nettypeline, &num_retries);
+                RLOGD("response[%d] = %d\n",count,num_retries);
+                if (err < 0) goto error_668;
+                RLOGD("refresh response[%d] [%d] = %d\n",request,count,num_retries);
+            }
+
+            goto error_668;
+        }
+        else
+        {
+            /* Got OK, return success. */
+
+            num_retries = 1;
+
+            if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+            {
+                RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                RIL_onRequestComplete(t, RIL_E_SUCCESS, &num_retries, sizeof(int));
+            }
+            else
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                RIL_onRequestComplete(t, RIL_E_SUCCESS, &num_retries, sizeof(int *));
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &num_retries, sizeof(int));
+#else
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &num_retries, sizeof(int *));
+#endif
+#endif
+            sleep(1);
+            /* Make sure we get notifications for network registeration
+               of both voice and data now */
+            at_send_command("AT+CREG=2", NULL);
+            at_send_command("AT+CGREG=2", NULL);
+            at_send_command("AT+CEREG=2", NULL);
+
+            /* Notify that SIM is ready */
+            setRadioState(RADIO_STATE_SIM_READY);
+        // <!--added by wangmengying@2020.3.11 fix bug42831,unlock SIM pin and update SIM status
+            RIL_onUnsolicitedResponse( RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED,NULL, 0);
+        // end-->
+        }
+        return;
+    }
+    else
+    {
+        if (err < 0 || p_response->success == 0)
+        {
+            rc = at_send_command_singleline("AT+PINPUK=?", "+PINPUK:",&pin_response);
+            if (rc < 0 || pin_response->success == 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                goto error_660;
+            }
+            nettypeline = pin_response->p_intermediates->line;
+            rc = at_tok_start(&nettypeline);
+            if (rc < 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                goto error_660;
+            }
+
+            rc = at_tok_nextint(&nettypeline, &(response[0]));
+            if (rc < 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                goto error_660;
+            }
+
+            RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &response[0], sizeof(int *));
+        }
+        else
+        {
+            response[0]=3;
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &response[0], sizeof(int *));
+            TIMEVAL_DELAYINIT.tv_sec = 5;
+            RIL_requestTimedCallback(initializeCallback, NULL, &TIMEVAL_DELAYINIT);
+        }
+    }
+
+error1:
+    at_response_free(p_response);
+    num_retries = 1;
+error_668:
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &num_retries, sizeof(int));
+    }
+    else
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &num_retries, sizeof(int *));
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &num_retries, sizeof(int));
+#else
+    RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &num_retries, sizeof(int *));
+#endif
+#endif
+error_660:
+    at_response_free(p_response);
+    at_response_free(pin_response);
+}
+
+#if 0
+void  requestEnterSimPuk(void*  data, size_t  datalen, RIL_Token  t)
+{
+    ATResponse   *p_response = NULL;
+    int           err;
+    char*         cmd = NULL;
+    const char**  strings = (const char**)data;
+    int response[2];
+    char *nettypeline,*nettypestr;
+    int    rc;
+    //    ARLOGD("Sim puk = %s, Sim pin = %s", strings[0], strings[1]);
+    datalen;
+    asprintf(&cmd, "AT+CPIN=\"%s\",\"%s\"", strings[0], strings[1]);
+
+    err = at_send_command(cmd, &p_response);
+
+    if (err < 0 || p_response->success == 0)
+    {
+        rc = at_send_command_singleline("AT+PINPUK=?", "+PINPUK:",&p_response);
+
+        if (rc < 0 || p_response->success == 0)
+        {
+            RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            goto error;
+        }
+        nettypeline = p_response->p_intermediates->line;
+        rc = at_tok_start(&nettypeline);
+        if (rc < 0)
+        {
+            RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            goto error;
+        }
+
+        rc = at_tok_nextint(&nettypeline,  &(response[0]));
+        if (rc <0)
+        {
+            RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            goto error;
+        }
+        rc = at_tok_nextint(&nettypeline,  &(response[1]));
+        if (rc <0)
+        {
+            RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+            goto error;
+        }
+
+        RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &response[1], sizeof(int *));
+    }
+    else
+    {
+        response[1]=10;
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, &response[1], sizeof(int *));
+        TIMEVAL_DELAYINIT.tv_sec = 5;
+        RIL_requestTimedCallback(initializeCallback, NULL, &TIMEVAL_DELAYINIT);
+    }
+
+error:
+    at_response_free(p_response);
+}
+#endif
+
+//void  requestChangeSimPin(void*  data, size_t  datalen, RIL_Token  t)
+void  requestChangeSimPin(int request, void*  data, size_t  datalen __unused, RIL_Token  t)
+{
+    ATResponse   *p_response = NULL;
+    int           err;
+    char*         cmd = NULL;
+    const char**  strings = (const char**)data;;
+    int response[2];
+    int rc;
+    char *nettypeline = NULL;
+    int num_retries = -1;
+    int count = 0;
+
+    asprintf(&cmd, "AT+CPWD=\"SC\",\"%s\",\"%s\"", strings[0], strings[1]);
+
+    err = at_send_command(cmd, &p_response);
+    free(cmd);
+    cmd = NULL;
+
+    //<!--[ODM]wangmengying@2019.07.31 modify PIN related AT
+    if (GHT_NL668 <= mode_flag)
+    // end-->
+    {
+        if (err < 0 || p_response->success == 0)
+        {
+            at_response_free(p_response);
+            rc = at_send_command_singleline("AT+TPIN?","+TPIN:",&p_response);
+
+            if (rc < 0 || p_response->success == 0)
+            {
+                goto error1;
+            }
+            nettypeline = p_response->p_intermediates->line;
+            rc = at_tok_start(&nettypeline);
+            if (rc < 0)
+            {
+                goto error1;
+            }
+
+            rc = at_tok_nextint(&nettypeline, &num_retries);
+            if (rc < 0)
+            {
+                goto error_668;
+            }
+
+            if (request == RIL_REQUEST_ENTER_SIM_PUK)
+            {
+                err = at_tok_nextint(&nettypeline, &num_retries);
+                RLOGD("response[%d] = %d\n",count,num_retries);
+                if (err < 0) goto error_668;
+                RLOGD("refresh response[%d] [%d] = %d\n",request,count,num_retries);
+            }
+
+            goto error_668;
+        }
+        else
+        {
+            num_retries = 1;
+            if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+            {
+                RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                RIL_onRequestComplete(t, RIL_E_SUCCESS, &num_retries, sizeof(int));
+            }
+            else
+            {
+                RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+                RIL_onRequestComplete(t, RIL_E_SUCCESS, &num_retries, sizeof(int *));
+            }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &num_retries, sizeof(int));
+#else
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &num_retries, sizeof(int *));
+#endif
+#endif
+            /* Make sure we get notifications for network registeration
+               of both voice and data now */
+            at_send_command("AT+CREG=2", NULL);
+            at_send_command("AT+CGREG=2", NULL);
+            at_send_command("AT+CEREG=2", NULL);
+
+            /* Notify that SIM is ready */
+            setRadioState(RADIO_STATE_SIM_READY);
+        }
+        at_response_free(p_response);
+		return;
+    }
+    else
+    {
+        if (err < 0 || p_response->success == 0)
+        {
+            at_response_free(p_response);
+            rc = at_send_command_singleline("AT+PINPUK=?", "+PINPUK:",&p_response);
+            if (rc < 0 || p_response->success == 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                goto error_660;
+            }
+            nettypeline = p_response->p_intermediates->line;
+            rc = at_tok_start(&nettypeline);
+            if (rc < 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                goto error_660;
+            }
+            rc = at_tok_nextint(&nettypeline, &(response[0]));
+            if (rc < 0)
+            {
+                RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+                goto error_660;
+            }
+            RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &response[0], sizeof(int *));
+        }
+        else
+        {
+            response[0]=3;
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &response[0], sizeof(int *));
+        }
+    }
+
+error1:
+    at_response_free(p_response);
+    num_retries = 1;
+error_668:
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &num_retries, sizeof(int));
+    }
+    else
+    {
+        RLOGD("[%s,%d]: version_check Ght_Android_Version:%d, < 8 or > 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &num_retries, sizeof(int *));
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &num_retries, sizeof(int));
+#else
+    RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, &num_retries, sizeof(int *));
+#endif
+#endif
+error_660:
+    at_response_free(p_response);
+}
+//duanshitao add for sim pin and puk 20101122 end
+
+#if 0
+void  requestSIM_IO_M910(void *data, size_t datalen __unused, RIL_Token t)
+{
+    ATResponse *p_response = NULL;
+    RIL_SIM_IO_Response sr;
+    int err;
+    char *cmd = NULL;
+    RIL_SIM_IO_v6 *p_args;
+    char *line;
+    unsigned long i = 0;
+    ATResponse *qccid_response = NULL;
+    char iccid_low = 0;
+
+    memset(&sr, 0, sizeof(sr));
+
+    p_args = (RIL_SIM_IO_v6 *)data;
+
+    /* FIXME handle pin2 */
+#if 1 //fibocom
+    if (p_args->command == COMMAND_GET_RESPONSE) {
+        p_args->p3 = 0;
+    }
+#endif
+
+    if (p_args->data == NULL) {
+        //RLOGD("[%s]: p_args->data is NULL", __func__);
+        asprintf(&cmd, "AT+CRSM=%d,%d,%d,%d,%d",
+                    p_args->command, p_args->fileid,
+                    p_args->p1, p_args->p2, p_args->p3);
+    }
+    else
+    {
+        asprintf(&cmd, "AT+CRSM=%d,%d,%d,%d,%d,\"%s\"",
+                    p_args->command, p_args->fileid,
+                    p_args->p1, p_args->p2, p_args->p3, p_args->data);
+    }
+
+    err = at_send_command_singleline(cmd, "+CRSM:", &p_response);
+
+    if (err < 0 || p_response->success == 0) {
+        goto error;
+    }
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(sr.sw1));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(sr.sw2));
+    if (err < 0) goto error;
+
+    if (at_tok_hasmore(&line)) {
+        err = at_tok_nextstr(&line, &(sr.simResponse));
+        if (err < 0) goto error;
+    }
+
+#if 1 //fibocom
+//see telephony\src\java\com\android\internal\telephony\uicc\IccFileHandler.java handleMessage() -> case EVENT_GET_BINARY_SIZE_DONE:
+    if (p_args->command == COMMAND_GET_RESPONSE)
+        usim2sim(&sr);
+#endif
+
+    /*RLOGD("[%s]: RIL_SIM_IO_Response Complete sr.sw1=%d, sr.sw2=%d, sr.simResponse=%s",
+        __func__, sr.sw1, sr.sw2, sr.simResponse);*/
+
+#ifdef QUECTEL_REPORT_SIGNAL_STRENGTH
+    if ((p_args->fileid == EF_ICCID) && (p_args->command == COMMAND_READ_BINARY)) {
+        requestSignalStrength(NULL, 0, NULL);
+    }
+#endif
+
+    if (p_args->fileid == EF_ICCID && sr.simResponse == NULL)
+        goto error;
+    
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, &sr, sizeof(sr));
+    at_response_free(p_response);
+    free(cmd);
+
+    return;
+error:
+    if (p_args->fileid == EF_ICCID) {
+        sr.sw1 = 144;
+        sr.sw2 = 0;
+        sr.simResponse = NULL;
+        if (p_args->command == COMMAND_GET_RESPONSE) {
+            sr.simResponse = "0000000a2fe2040000000000000000";
+        } else if (p_args->command == COMMAND_READ_BINARY) {
+#define TELCOMM_DUMMY_ICCID "98681031098310024233"
+			err = at_send_command_singleline("AT+CCID?", "+CCID: ", &qccid_response);
+            if (err < 0 || qccid_response == NULL || qccid_response->success == 0) {
+                sr.simResponse = TELCOMM_DUMMY_ICCID;
+            } else {
+            line = qccid_response->p_intermediates->line;
+            if (0 == at_tok_start(&line) && 0 == at_tok_nextstr(&line, &sr.simResponse)) {
+                for (i = 0; i < strlen(sr.simResponse); i+=2) {
+                    if ((strlen(sr.simResponse) - 1) < (i+1)) {
+                        //RLOGD("[%s:%d] array out of index, invalid iccid length.\n", __func__, __LINE__);
+                        sr.simResponse = TELCOMM_DUMMY_ICCID;
+                    } else {
+                        iccid_low = sr.simResponse[i];
+                        sr.simResponse[i] = sr.simResponse[i+1];
+                        sr.simResponse[i+1] = iccid_low;
+                    }
+                }
+            } else {
+                //RLOGD("[%s:%d] at_tok_start or at_tok_nextstr failed.\n", __func__, __LINE__);
+                sr.simResponse = TELCOMM_DUMMY_ICCID;
+            }
+            }
+        }
+        if (sr.simResponse != NULL) {
+            RIL_onRequestComplete(t, RIL_E_SUCCESS, &sr, sizeof(sr));
+            at_response_free(p_response);
+            free(cmd);
+            if (NULL != qccid_response) {
+                at_response_free(qccid_response);
+                qccid_response = NULL;
+            }
+            return;
+        }
+    }
+    RLOGD("%s error\n", __func__);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+    free(cmd);
+    if (NULL != qccid_response) {
+        at_response_free(qccid_response);
+    }
+}
+#else
+void  requestSIM_IO_M910(void *data, size_t datalen __unused, RIL_Token t)
+{
+}
+#endif
\ No newline at end of file
diff --git a/hardware/ril/youyou_ril/sim.h b/hardware/ril/youyou_ril/sim.h
new file mode 100755
index 0000000..243ba63
--- /dev/null
+++ b/hardware/ril/youyou_ril/sim.h
@@ -0,0 +1,31 @@
+#ifndef _SIM_H_
+#define _SIM_H_
+
+typedef enum
+{
+    SIM_ABSENT = 0,
+    SIM_NOT_READY = 1,
+    SIM_READY = 2, /* SIM_READY means the radio state is RADIO_STATE_SIM_READY */
+    SIM_PIN = 3,
+    SIM_PUK = 4,
+    SIM_NETWORK_PERSONALIZATION = 5
+} SIM_Status;
+
+void  requestSIM_IO(void *data, size_t datalen, RIL_Token t);
+
+void  requestQueryFacilityLock(void*  data, size_t  datalen, RIL_Token  t);
+
+void  requestSetFacilityLock(void*  data, size_t  datalen, RIL_Token  t);
+
+//void  requestEnterSimPin(void*  data, size_t  datalen, RIL_Token  t);
+void  requestEnterSimPin(int request, void*  data, size_t  datalen, RIL_Token  t);
+
+void  requestEnterSimPuk(void*  data, size_t  datalen, RIL_Token  t);
+
+//void  requestChangeSimPin(void*  data, size_t  datalen, RIL_Token  t);
+void  requestChangeSimPin(int request, void*  data, size_t  datalen, RIL_Token  t);
+
+void  requestSIM_IO_M910(void *data, size_t datalen, RIL_Token t);
+
+#endif /*_SIM_H_*/
+
diff --git a/hardware/ril/youyou_ril/sms.c b/hardware/ril/youyou_ril/sms.c
new file mode 100755
index 0000000..9b4c295
--- /dev/null
+++ b/hardware/ril/youyou_ril/sms.c
@@ -0,0 +1,2205 @@
+/*SMS*/
+/*when who why modified*/
+
+#include <telephony/ril.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <alloca.h>
+#include "atchannel.h"
+#include "at_tok.h"
+#include "misc.h"
+#include <getopt.h>
+#include <sys/socket.h>
+#include <cutils/sockets.h>
+#include <cutils/properties.h>
+#include <termios.h>
+#include <ctype.h>
+
+#include "ril_common.h"
+#include "sms.h"
+
+#define LOG_TAG GHT_RIL
+#include <utils/Log.h>
+#include <stdlib.h>
+
+/*added by nodecom  for adding sms_send_report begin */
+SMS_Type sms_type =  SMS_GENERAL;
+/*added by nodecom  for adding sms_send_report end */
+extern int cur_oper;
+extern product_model mode_flag;
+extern char * get_network_type();
+extern int odm_get_current_network_type();
+void convertstrtohex(char *src_str,char *hex_str,int src_str_len);
+int handover_flag = 0;
+#if 0
+void receiveSMS( void* param )
+{
+    int location = ( int )param;
+    char* cmd;
+
+    //    if (screenStatus) {
+    asprintf( &cmd, "AT+CMGR=%d", location );
+    /* request the sms in a specific location */
+    //at_send_command(ATch_primary, cmd, NULL);
+    at_send_command( cmd, NULL );
+    free( cmd );
+    /* remove the sms from specific location XXX temp fix*/
+    asprintf( &cmd, "AT+CMGD=%d,0", location );
+    at_send_command( cmd, NULL );
+    //at_send_command(ATch_primary, cmd, NULL);
+    free( cmd );
+    //    } else
+    //            RIL_requestTimedCallback (receiveSMS, param, &TIMEVAL_SIMPOLL);
+    return;
+}
+
+void requestWriteSmsToSim( void* data, size_t datalen, RIL_Token t )
+{
+    RIL_SMS_WriteArgs* p_args;
+    char* cmd;
+    int length;
+    int err;
+    ATResponse* p_response = NULL;
+    datalen;
+    p_args = ( RIL_SMS_WriteArgs* )data;
+
+    length = strlen( p_args->pdu ) / 2;
+    asprintf( &cmd, "AT+CMGW=%d,%d", length, p_args->status );
+
+    err = at_send_command_sms( cmd, p_args->pdu, "+CMGW:", &p_response );
+
+    if ( err != 0 || p_response->success == 0 ) { goto error; }
+
+    RIL_onRequestComplete( t, RIL_E_SUCCESS, NULL, 0 );
+    at_response_free( p_response );
+
+    return;
+error:
+    RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+    at_response_free( p_response );
+}
+
+void requestSendSMS( void* data, size_t datalen, RIL_Token t )
+{
+    int err;
+    const char* smsc;
+    const char* pdu;
+    int tpLayerLength;
+    char* cmd1, *cmd2;
+    RIL_SMS_Response response;
+    ATResponse* p_response = NULL;
+    datalen;
+    smsc = ( ( const char** )data )[0];
+    pdu = ( ( const char** )data )[1];
+
+    tpLayerLength = strlen( pdu ) / 2;
+
+    // "NULL for default SMSC"
+    if ( smsc == NULL )
+    {
+        smsc = "00";
+    }
+
+    asprintf( &cmd1, "AT+CMGS=%d", tpLayerLength );
+    asprintf( &cmd2, "%s%s", smsc, pdu );
+
+    err = at_send_command_sms( cmd1, cmd2, "+CMGS:", &p_response );
+
+    if ( err != 0 || p_response->success == 0 ) { goto error; }
+
+    memset( &response, 0, sizeof( response ) );
+
+    /* FIXME fill in messageRef and ackPDU */
+
+    RIL_onRequestComplete( t, RIL_E_SUCCESS, &response, sizeof( response ) );
+    at_response_free( p_response );
+
+    return;
+error:
+    RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+    at_response_free( p_response );
+}
+
+void requestSMSAcknowledge( void* data, size_t datalen, RIL_Token t )
+{
+    int ackSuccess;
+    int err;
+
+    ackSuccess = ( ( int* )data )[0];
+    datalen;
+    if ( ackSuccess == 1 )
+    {
+        err = at_send_command( "AT+CNMA=1", NULL );
+    }
+    else if ( ackSuccess == 0 )
+    {
+        err = at_send_command( "AT+CNMA=2", NULL );
+    }
+    else
+    {
+        ARLOGD( "unsupported arg to RIL_REQUEST_SMS_ACKNOWLEDGE\n" );
+        goto error;
+    }
+
+    RIL_onRequestComplete( t, RIL_E_SUCCESS, NULL, 0 );
+error:
+    RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+
+}
+
+#else
+
+#if 1
+#define PDU_3GPP_7BIT
+#ifdef PDU_3GPP_7BIT
+typedef unsigned char uint8;
+typedef enum
+{
+    ENCODE_7BIT,
+    ENCODE_UNICDE,
+    ENCODE_NULL,
+} encode_e_type;
+
+typedef struct cdma_7bit_data
+{
+    char data_3pgg2_ptr[255];
+    char data_3pgg2_len;
+    char data_len;
+} cdma_7bit_data_s_type;
+
+cdma_7bit_data_s_type cdma_7bit_d;
+extern unsigned char GetBit(unsigned char uByte, int iBitIndex);
+
+extern void SetBit(unsigned char* lpByte, int iBitIndex, unsigned char uVal);
+
+// 7bit
+
+// : pSrc - 
+
+//       nSrcLength - 
+
+// : pDst - 
+
+// : 
+
+int Encode7bit(const char* pSrc, unsigned char* pDst, int nSrcLength)
+
+{
+
+    int iDst;
+
+    int nBitsInByte;
+    int iSrc;
+    int i;
+
+
+    //unsigned char* szDst = new unsigned char[nSrcLength+1];
+    unsigned char  szDst[nSrcLength+1];
+
+    memset(szDst, 0x00, nSrcLength+1);
+
+    iDst = 0;
+
+    nBitsInByte = 0;
+
+    for (iSrc = 0; iSrc < nSrcLength; iSrc++)
+    {
+        for (i = 0; i < 7; i++)
+        {
+            unsigned char uBitVal = GetBit(*(pSrc+iSrc), i+1);
+
+            SetBit(szDst+iDst, nBitsInByte, uBitVal);
+
+            nBitsInByte++;
+
+            if (nBitsInByte >= 8)
+            {
+                nBitsInByte = 0;
+
+                iDst++;
+            }
+        }
+    }
+
+    if (nBitsInByte > 0)
+    {
+        iDst++;
+    }
+
+    for (i = 0; i < iDst; i++)
+    {
+        sprintf((char*)pDst+2*i, "%02x", *(szDst+i));
+
+    }
+
+    //delete szDst;
+
+    //szDst = 0;
+
+    return iDst*2;
+
+}
+
+
+
+// 7bit
+
+// : pSrc - 
+
+//       nSrcLength - 
+
+// : pDst - 
+
+// : 
+
+int Decode7bit(const unsigned char* pSrc, char* pDst, int nSrcLength)
+{
+
+    //unsigned char uVal;
+    unsigned int uVal;
+
+    int iDst = 0;
+
+    int nBitsInByte = 1;
+    int iSrc;
+    int i;
+    unsigned char uBitVal;
+
+    for ( iSrc = 0; iSrc < nSrcLength; iSrc += 2)
+
+    {
+
+        sscanf((char*)pSrc+iSrc, "%02x", &uVal);
+
+        for ( i = 0; i < 8; i++)
+
+        {
+
+            uBitVal = GetBit(uVal, i);
+
+            SetBit((unsigned char*)pDst+iDst, nBitsInByte, uBitVal);
+
+            nBitsInByte++;
+
+            if (nBitsInByte >= 8)
+
+            {
+
+                nBitsInByte = 1;
+
+                iDst++;
+
+            }
+
+        }
+
+    }
+
+
+
+    if (nBitsInByte > 0)
+
+    {
+
+        iDst++;
+
+    }
+
+    return iDst;
+
+}
+
+
+
+unsigned char GetBit(unsigned char uByte, int iBitIndex)
+
+{
+
+    unsigned char uVal;
+
+    uVal = uByte;
+
+    uVal = uVal & (0x80 >> iBitIndex);
+
+    uVal = uVal >> (7 - iBitIndex);
+
+    return uVal;
+
+}
+
+
+
+void SetBit(unsigned char* lpByte, int iBitIndex, unsigned char uVal)
+
+{
+
+    unsigned char uBit = uVal;
+
+    uBit = uBit & 0x01;
+
+    *lpByte = *lpByte | (uBit << (7 - iBitIndex));
+
+}
+
+int gsmEncode7bit(const char* pSrc, unsigned char* pDst, int nSrcLength)
+{
+
+    int nSrc;
+
+    // 
+
+    int nDst;
+
+    // 
+
+    int nChar;
+
+    //0-7
+    unsigned char nLeft;
+    //
+
+    // 
+
+    nSrc = 0;
+
+    nDst = 0;
+
+    // 87
+
+    // 
+
+    // 8
+
+    while(nSrc<nSrcLength)
+    {
+
+        //3
+
+        nChar = nSrc & 7;
+        //
+
+        if(nChar == 0)
+        {
+            //
+
+            nLeft = *pSrc;
+        }
+        else
+        {
+            // 
+            *pDst = (*pSrc << (8-nChar)) | nLeft;
+
+            // 
+            nLeft = *pSrc >> nChar;
+
+            // 
+            pDst++;
+            nDst++;
+        }
+
+        // 
+
+        pSrc++; nSrc++;
+    }
+    // 
+    return nDst;
+}
+// 7-bit
+// pSrc: 
+// pDst: 
+// nSrcLength: 
+// : 
+int gsmDecode7bit(const unsigned char* pSrc, char* pDst, int nSrcLength) {
+    int nSrc;        // 
+    int nDst;        // 
+    int nByte;       // 0-6
+    unsigned char nLeft;    // 
+    // 
+    nSrc = 0;     nDst = 0;
+    // 
+    nByte = 0;     nLeft = 0;
+    // 78
+    // 
+    // 7
+    while(nSrc<nSrcLength)     {
+        // 
+        *pDst = ((*pSrc << nByte) | nLeft) & 0x7f;
+        // 
+        nLeft = *pSrc >> (7-nByte);
+        // 
+        pDst++;
+        nDst++;
+        // 
+        nByte++;
+        // 
+        if(nByte == 7)
+        {
+            // 
+            *pDst = nLeft;
+            // 
+            pDst++;
+            nDst++;
+            // 
+            nByte = 0;
+            nLeft = 0;
+        }
+        // 
+        pSrc++;
+        nSrc++;
+    }
+    *pDst = 0;
+    // 
+    return nDst;
+}
+
+void StrToHex(char *pbDest, char *pbSrc, int nLen)
+{
+    char h1,h2;
+    char s1,s2;
+    int i;
+
+    for (i=0; i<nLen; i++)
+    {
+        h1 = pbSrc[2*i];
+        h2 = pbSrc[2*i+1];
+
+        s1 = toupper(h1) - 0x30;
+        if (s1 > 9)
+            s1 -= 7;
+
+        s2 = toupper(h2) - 0x30;
+        if (s2 > 9)
+            s2 -= 7;
+
+        pbDest[i] = s1*16 + s2;
+    }
+}
+//GSM 7bit
+char str_2_num(char* pdu_str_p, char str_len, char* num_buff_p)
+{
+    char pdu_str[0xff] = {0};
+    char num_buff[0xff] = {0};
+    char byte_str[3] = {0};
+    int i;
+    char num;
+
+    if(str_len > 200)
+    {
+        return 0;
+    }
+    memcpy(pdu_str, pdu_str_p,str_len);
+    for(i=0;i<str_len;i++)
+    {
+        byte_str[0] = pdu_str_p[i];
+        byte_str[1] = pdu_str_p[i+1];
+        byte_str[2] = '\0';
+        StrToHex(&num, byte_str, 2);
+        num_buff[i/2] = num;
+        i++;
+    }
+    memcpy(num_buff_p,num_buff,str_len/2);
+    return str_len/2;
+}
+
+//void pdu_3gpp_7bit_2_3gpp2_7bit(char* pdu_data_ptr, char* data_3pgg2_ptr, char* data_3pgg2_len)
+void pdu_3gpp_7bit_2_3gpp2_7bit(char* pdu_data_ptr)
+{
+    char num_buff[255]={0};
+    char num_buff_len = 0;
+    char decode_3gpp_str[255] = {0};
+    char encode_3gpp2_str[255] = {0};
+    char decode_3gpp_str_len = 0;
+    char len = 0;
+    char encode_3gpp2_hex[255] = {0};
+    char encode_3gpp2_hex_len = 0;
+    char i;
+    num_buff_len = str_2_num(pdu_data_ptr, strlen(pdu_data_ptr), num_buff);
+    decode_3gpp_str_len = gsmDecode7bit(num_buff, decode_3gpp_str,num_buff_len);
+    len = Encode7bit(decode_3gpp_str, encode_3gpp2_str, strlen(decode_3gpp_str));
+    encode_3gpp2_hex_len = str_2_num(encode_3gpp2_str, strlen(encode_3gpp2_str), encode_3gpp2_hex);
+    memset(&cdma_7bit_d,0,sizeof(cdma_7bit_data_s_type));
+    if((strlen(decode_3gpp_str)%8) == 7)
+    {
+        memcpy(cdma_7bit_d.data_3pgg2_ptr,encode_3gpp2_hex,encode_3gpp2_hex_len-1);
+        cdma_7bit_d.data_3pgg2_len = encode_3gpp2_hex_len -1;
+        cdma_7bit_d.data_len = strlen(decode_3gpp_str);
+    }
+    else
+    {
+        memcpy(cdma_7bit_d.data_3pgg2_ptr,encode_3gpp2_hex,encode_3gpp2_hex_len);
+        cdma_7bit_d.data_3pgg2_len = encode_3gpp2_hex_len;
+        cdma_7bit_d.data_len = decode_3gpp_str_len;
+    }
+}
+extern void converthextostr(char *hex_str,char *dest_str,int hex_str_len);
+void pdu_3gpp2_7bit_2_3gpp_7bit(char* hex_3gpp2_ptr,int hex_len, char* pdu_3gpp_str)
+{
+    char dest_str[500] = {0};
+    char decode_3gpp2_str[500] = {0};
+    char encode_3gpp_hex[500] = {0};
+    int decode_3gpp2_str_len = 0;
+    int encode_3gpp_hex_len = 0;
+    int encode_3gpp_str_len = 0;
+
+    converthextostr(hex_3gpp2_ptr, dest_str, hex_len);
+
+    decode_3gpp2_str_len = Decode7bit(dest_str, decode_3gpp2_str, strlen(dest_str));
+
+    if(decode_3gpp2_str_len%8 ==7)
+    {
+        int dest_str_len = strlen(dest_str);
+        dest_str[dest_str_len] = '0';
+        dest_str[dest_str_len+1] = '0';
+        dest_str[dest_str_len+2] = '\0';
+        memset(decode_3gpp2_str,0,500);
+        decode_3gpp2_str_len = Decode7bit(dest_str, decode_3gpp2_str, strlen(dest_str));
+    }
+
+    encode_3gpp_hex_len = gsmEncode7bit(decode_3gpp2_str,encode_3gpp_hex,decode_3gpp2_str_len);
+
+    converthextostr(encode_3gpp_hex, pdu_3gpp_str, encode_3gpp_hex_len);
+
+}
+
+void parse_3gpp2_sms(char *src_3gpp2_pdu,char *number,int *dig_num_len,char *time,
+        char *sms_data,uint8 *data_len,uint8 *str_len,encode_e_type* encode_type)
+{
+    int pos =16;
+    int i,j;
+    int tmp_len = 0;
+    uint8 tmp = 0;
+    uint8 hex_tmp[500] = {0};
+    if((src_3gpp2_pdu[pos]>='0') && (src_3gpp2_pdu[pos] <= '9'))
+    {
+        tmp_len = (src_3gpp2_pdu[pos]-'0')*16;
+    }
+    else if((src_3gpp2_pdu[pos]>='a') && (src_3gpp2_pdu[pos] <= 'f'))
+    {
+        tmp_len = ((src_3gpp2_pdu[pos]-'a')+10)*16;
+    }
+    else if((src_3gpp2_pdu[pos]>='A') && (src_3gpp2_pdu[pos] <= 'F'))
+    {
+        tmp_len = ((src_3gpp2_pdu[pos]-'A')+10)*16;
+    }
+    if((src_3gpp2_pdu[pos+1]>='0') && (src_3gpp2_pdu[pos+1] <= '9'))
+    {
+        tmp_len += src_3gpp2_pdu[pos+1]-'0';
+    }
+    else if((src_3gpp2_pdu[pos+1]>='a') && (src_3gpp2_pdu[pos+1] <= 'f'))
+    {
+        tmp_len += (src_3gpp2_pdu[pos+1]-'a')+10;
+    }
+    else if((src_3gpp2_pdu[pos+1]>='A') && (src_3gpp2_pdu[pos+1] <= 'F'))
+    {
+        tmp_len += (src_3gpp2_pdu[pos+1]-'A')+10;
+    }
+    pos += 2;
+    memset(hex_tmp,0,500);
+    convertstrtohex(&src_3gpp2_pdu[pos],hex_tmp,tmp_len*2);
+    *dig_num_len = ((hex_tmp[0]&0x3f)<<2)+((hex_tmp[1]&0xc0)>>6);
+    for(i=0,j=0;i<tmp_len;i++,j++)
+    {
+        tmp = ((hex_tmp[1+i]&0x3f)<<2) + ((hex_tmp[1+i+1]&0xc0)>>6);
+        number[j] = (tmp&0xf0)>>4;
+        if(number[j] == 0x0a)
+        {
+            number[j] = '0';
+        }
+        else
+        {
+            number[j] += '0';
+        }
+        j++;
+        if(j >= *dig_num_len)
+            break;
+        number[j] = tmp&0x0f;
+        if(number[j] == 0x0a)
+        {
+            number[j] = '0';
+        }
+        else
+        {
+            number[j] += '0';
+        }
+    }
+    pos += tmp_len*2;
+    pos += 22;
+    if((src_3gpp2_pdu[pos]>='0') && (src_3gpp2_pdu[pos] <= '9'))
+    {
+        tmp_len = (src_3gpp2_pdu[pos]-'0')*16;
+    }
+    else if((src_3gpp2_pdu[pos]>='a') && (src_3gpp2_pdu[pos] <= 'f'))
+    {
+        tmp_len = ((src_3gpp2_pdu[pos]-'a')+10)*16;
+    }
+    else if((src_3gpp2_pdu[pos]>='A') && (src_3gpp2_pdu[pos] <= 'F'))
+    {
+        tmp_len = ((src_3gpp2_pdu[pos]-'A')+10)*16;
+    }
+    if((src_3gpp2_pdu[pos+1]>='0') && (src_3gpp2_pdu[pos+1] <= '9'))
+    {
+        tmp_len += src_3gpp2_pdu[pos+1]-'0';
+    }
+    else if((src_3gpp2_pdu[pos+1]>='a') && (src_3gpp2_pdu[pos+1] <= 'f'))
+    {
+        tmp_len += (src_3gpp2_pdu[pos+1]-'a')+10;
+    }
+    else if((src_3gpp2_pdu[pos+1]>='A') && (src_3gpp2_pdu[pos+1] <= 'F'))
+    {
+        tmp_len += (src_3gpp2_pdu[pos+1]-'A')+10;
+    }
+    pos += 2;
+    memset(hex_tmp,0,500);
+    convertstrtohex(&src_3gpp2_pdu[pos],hex_tmp,tmp_len*2);
+    tmp = (hex_tmp[0]&0xf8)>>3;
+    switch(tmp)
+    {
+        case 0x02:
+            *encode_type = ENCODE_7BIT;
+            break;
+        case 0x04:
+            *encode_type = ENCODE_UNICDE;
+            break;
+        default:
+            RLOGD("encode_type = %d err!",*encode_type);
+            return;
+    }
+
+    *str_len = ((hex_tmp[0]&0x07)<<5) + ((hex_tmp[1]&0xf8)>>3);
+
+    if(ENCODE_7BIT == *encode_type)
+    {
+        for(i=0;i<tmp_len;i++)
+        {
+            sms_data[i] = ((hex_tmp[1+i]&0x07)<<5) + ((hex_tmp[1+i+1]&0xf8)>>3);
+            RLOGD("sms_data[%d]=0x%x!",i,sms_data[i]);
+            if((1+i+1) >= tmp_len)
+            {
+                *data_len = i+1;
+                break;
+            }
+        }
+    }
+    else if(ENCODE_UNICDE == *encode_type)
+    {
+        for(i=0;i<tmp_len;i++)
+        {
+            sms_data[i] = ((hex_tmp[1+i]&0x07)<<5) + ((hex_tmp[1+i+1]&0xf8)>>3);
+            RLOGD("sms_data[%d]=0x%x!",i,sms_data[i]);
+            if((1+i+1) >= tmp_len)
+            {
+                *data_len = i;
+                break;
+            }
+        }
+    }
+
+    pos += tmp_len*2;
+    pos += 4;
+    memcpy(time,&src_3gpp2_pdu[pos],12);
+    return;
+}
+uint8 encode_3gpp_sms_pdu(char *pdu,char *addr,char* time,
+        uint8 addr_len,char *data,uint8 data_len,uint8 str_len,encode_e_type encode_type)
+{
+    int pos = 0;
+    int i = 0;
+    int j = 0;//08 91683108200905F0 040D 91683175420784F2 0000 510121917262 23 0AB0986C46ABD96EB81C
+    char data_hex[500] = {0};
+    pdu[pos] = 0x08;
+    pos++;
+    pdu[pos] = 0x91;
+    pos++;
+    pdu[pos] = 0x68;
+    pos++;
+    pdu[pos] = 0x31;
+    pos++;
+    pdu[pos] = 0x08;
+    pos++;
+    pdu[pos] = 0x20;
+    pos++;
+    pdu[pos] = 0x09;
+    pos++;
+    pdu[pos] = 0x05;
+    pos++;
+    pdu[pos] = 0xF0;
+    pos++;
+    //    if(11 == addr_len)
+    {
+        pdu[pos] = 0x04;
+        pos++;
+        pdu[pos] = addr_len+2;
+        pos++;
+        pdu[pos] = 0x91;
+        pos++;
+        pdu[pos] = 0x68;
+    }
+    /*    else
+          {
+          pdu[pos] = 0x60;
+          pos++;
+          pdu[pos] = addr_len;
+          pos++;
+          pdu[pos] = 0xA1;
+          }*/
+    pos++;
+    for(i=0;i<addr_len;i++)
+    {
+        if((addr_len%2 != 0) && ((i+1)>=addr_len))
+        {
+            pdu[pos] = 0xF0 + (addr[i]-'0');
+        }
+        else
+        {
+            pdu[pos] = ((addr[i+1]-'0')<<4) + (addr[i]-'0');
+        }
+        pos++;
+        i++;
+    }
+    pdu[pos] = 0x00;
+    pos++;
+    switch(encode_type)
+    {
+        case ENCODE_7BIT:
+            pdu[pos] = 0x00;
+            break;
+        case ENCODE_UNICDE:
+            pdu[pos] = 0x08;
+            break;
+        default:
+            RLOGD("encode_3gpp_sms_pdu::encode_type err!encode_type=%d",encode_type);
+            break;
+    }
+    pos++;
+    //time
+    for(i=0;i<12;i++)
+    {
+        if((time[i]<'0')||(time[i]<'9'))
+        {
+            RLOGD("encode_3gpp_sms_pdu::number err!addr[%d]=%c",i,time[i]);
+        }
+        pdu[pos] = ((time[i+1]-'0')<<4) + (time[i]-'0');
+        pos++;
+        i++;
+    }
+    pdu[pos] = 0x23;
+    pos++;
+    switch(encode_type)
+    {
+        case ENCODE_7BIT:
+            pdu[pos] = str_len;
+            pos++;
+            convertstrtohex(data, data_hex, data_len*2);
+            for(i=0;i<data_len;i++)
+            {
+                pdu[pos] = data_hex[i];
+                pos++;
+            }
+            break;
+        case ENCODE_UNICDE:
+            pdu[pos] = data_len;
+            pos++;
+            for(i=0;i<data_len;i++)
+            {
+                pdu[pos] = data[i];
+                pos++;
+            }
+            break;
+        default:
+            RLOGD("encode_3gpp_sms_pdu::encode_type err!encode_type=%d",encode_type);
+            break;
+    }
+    return pos;
+}
+void cdma_pdu_2_3gpp_pdu(char *pdu_3gpp2, char *pdu_3gpp)
+{
+    char number[32] ={0};
+    uint8 dig_num_len = 0;
+    char time[16] = {0};
+    char sms_data[500] = {0};
+    char pdu_3gpp_data[500] = {0};
+    char pdu_3gpp_hex[500] = {0};
+    int pdu_3gpp_hex_len = 0;
+    uint8 data_len = 0;
+    uint8 str_len = 0;
+    uint8 pdu_3gpp_len = 0;
+    encode_e_type encode_type = ENCODE_NULL;
+
+    parse_3gpp2_sms(pdu_3gpp2, number,&dig_num_len,time, sms_data,
+            &data_len, &str_len,&encode_type);
+    switch(encode_type)
+    {
+        case ENCODE_7BIT:
+            pdu_3gpp2_7bit_2_3gpp_7bit(sms_data,data_len, pdu_3gpp_data);
+            pdu_3gpp_hex_len = encode_3gpp_sms_pdu(pdu_3gpp_hex,number,time,dig_num_len,pdu_3gpp_data,
+                    data_len,str_len,encode_type);
+            converthextostr(pdu_3gpp_hex,pdu_3gpp,pdu_3gpp_hex_len);
+            pdu_3gpp_len = strlen(pdu_3gpp);
+            if(str_len%8 == 7)
+            {
+                pdu_3gpp[pdu_3gpp_len] = '0';
+                pdu_3gpp[pdu_3gpp_len+1] = '0';
+                pdu_3gpp[pdu_3gpp_len+2] = '\0';
+            }
+            break;
+        case ENCODE_UNICDE:
+            pdu_3gpp_hex_len = encode_3gpp_sms_pdu(pdu_3gpp_hex,number,time,dig_num_len,sms_data,
+                    data_len,str_len,encode_type);
+            converthextostr(pdu_3gpp_hex,pdu_3gpp,pdu_3gpp_hex_len);
+            break;
+        default:
+            RLOGD("cdma_pdu_2_3gpp_pdu encode_type=%d err!",encode_type);
+            return;
+    }
+}
+#endif
+
+
+
+void convertstrtohex(char *src_str,char *hex_str,int src_str_len)
+{
+    int i = 0;
+    int j = 0;
+    if(0 != (src_str_len%2))
+    {
+        src_str_len = src_str_len+1;
+    }
+    while(j < src_str_len)
+    {
+        if((src_str[j] >= '0') && (src_str[j]<='9'))
+        {
+            hex_str[i] = (src_str[j]-'0')<<4;
+        }
+        else if ((src_str[j] >= 'a') && (src_str[j]<='f'))
+        {
+            hex_str[i] = ((src_str[j]-'a')+10)<<4;
+        }
+        else if ((src_str[j] >= 'A') && (src_str[j]<='F'))
+        {
+            hex_str[i] = ((src_str[j]-'A')+10)<<4;
+        }
+        j++;
+        if((src_str[j] >= '0') && (src_str[j]<='9'))
+        {
+            hex_str[i] |= (src_str[j]-'0');
+        }
+        else if ((src_str[j] >= 'a') && (src_str[j]<='f'))
+        {
+            hex_str[i] |= ((src_str[j]-'a')+10);
+        }
+        else if ((src_str[j] >= 'A') && (src_str[j]<='F'))
+        {
+            hex_str[i] |= ((src_str[j]-'A')+10);
+        }
+        i++;
+        j++;
+    }
+}
+
+void converthextostr(char *hex_str,char *dest_str,int hex_str_len)
+{
+    int i = 0;
+    int j = 0;
+    char high_4_bit;
+    char low_4_bit;
+    int dest_str_len = hex_str_len * 2;
+    while(i < hex_str_len)
+    {
+        high_4_bit = hex_str[i] >> 4;
+        low_4_bit = hex_str[i] & 0x0F;
+        i++;
+        if((high_4_bit >= 0) && (high_4_bit <= 9))
+        {
+            dest_str[j] = high_4_bit + '0';
+            j++;
+        }
+        else if((high_4_bit >= 0x0A) && (high_4_bit <= 0x0F))
+        {
+            dest_str[j] = (high_4_bit - 10) + 'A';
+            j++;
+        }
+
+        if((low_4_bit >= 0) && (low_4_bit <= 9))
+        {
+            dest_str[j] = low_4_bit + '0';
+            j++;
+        }
+        else if((low_4_bit >= 0x0A) && (low_4_bit <= 0x0F))
+        {
+            dest_str[j] = (low_4_bit - 10) + 'A';
+            j++;
+        }
+    }
+}
+
+uint8 encode_cdma_sms_pdu_7bit(char *pdu,char *addr,
+        uint8 addr_len,char *data,uint8 data_len,uint8 str_len)
+{
+    int pos = 0;
+    int i = 0;
+    int j = 0;
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x02;
+    pos++;
+    pdu[pos] = 0x10;
+    pos++;
+    pdu[pos] = 0x02;
+    pos++;
+    pdu[pos] = 0x04;
+    pos++;
+    pdu[pos] = ((addr_len * 4) + 12)/8;
+    pos++;
+    pdu[pos] = 0x00;
+    pdu[pos] |= addr_len>>2;
+    pos++;
+    pdu[pos] = addr_len<<6;
+    while(i < addr_len/2+1)
+    {
+        if((addr[i]&0xf0) == 0)
+        {
+            addr[i] += 0xa0;
+        }
+        if((addr[i]&0x0f) == 0)
+        {
+            addr[i] += 0x0a;
+        }
+        //f 
+        if(i==addr_len/2)
+        {
+            addr[i] &= 0xf0;
+        }
+        pdu[pos] |= addr[i]>>2;
+        pos++;
+        pdu[pos] = addr[i]<<6;
+        i++;
+    }
+    //pos++;
+    pdu[pos] = 0x06;
+    pos++;
+    pdu[pos] = 0x01;
+    pos++;
+    pdu[pos] = 0xFC;
+    pos++;
+    pdu[pos] = 0x08;
+    pos++;
+    pdu[pos] = data_len + 9;
+    pos++;
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x03;
+    pos++;
+    pdu[pos] = 0x20;
+    pos++;
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x01;
+    pos++;
+    pdu[pos] = data_len + 2;
+    pos++;
+    pdu[pos] = 0x10;//7bit
+    pdu[pos] |= str_len>>5;
+    pos++;
+    pdu[pos] = (str_len & 0x1F)<<3;
+    i = 0;
+    while(i<data_len)
+    {
+        pdu[pos] |= data[i]>>5;
+        pos++;
+        pdu[pos] = (data[i] & 0x1F)<<3;
+        i++;
+    }
+    return pos;
+}
+
+
+uint8 encode_cdma_sms_pdu(char *pdu,char *addr,
+        uint8 addr_len,char *data,int data_len)
+{
+    int pos = 0;
+    int i = 0;
+    int j = 0;
+    char hex_data[200];
+    memset(hex_data,0x0,sizeof(hex_data));
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x02;
+    pos++;
+    pdu[pos] = 0x10;
+    pos++;
+    pdu[pos] = 0x02;
+    pos++;
+    pdu[pos] = 0x04;
+    pos++;
+    pdu[pos] = ((addr_len * 4) + 12)/8;
+    pos++;
+    pdu[pos] = 0x00;
+    pdu[pos] |= addr_len>>2;
+    pos++;
+    pdu[pos] = addr_len<<6;
+    while(i < addr_len/2+1)
+    {
+        if((addr[i]&0xf0) == 0)
+        {
+            addr[i] += 0xa0;
+        }
+        if((addr[i]&0x0f) == 0)
+        {
+            addr[i] += 0x0a;
+        }
+        //f 
+        if(i==addr_len/2)
+        {
+            addr[i] &= 0xf0;
+        }
+        pdu[pos] |= addr[i]>>2;
+        pos++;
+        pdu[pos] = addr[i]<<6;
+        i++;
+    }
+
+    //pos++;
+    pdu[pos] = 0x06;
+    pos++;
+    pdu[pos] = 0x01;
+    pos++;
+    pdu[pos] = 0xFC;
+    pos++;
+    pdu[pos] = 0x08;
+    pos++;
+    pdu[pos] = data_len + 9;
+    pos++;
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x03;
+    pos++;
+    pdu[pos] = 0x20;
+    pos++;
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x00;
+    pos++;
+    pdu[pos] = 0x01;
+    pos++;
+    pdu[pos] = data_len + 2;
+    pos++;
+    //
+    pdu[pos] = 0x20;
+    //unicodeunicode
+    pdu[pos] |= (data_len/2)>>5;
+    pos++;
+    pdu[pos] = ((data_len/2) & 0x1F)<<3;
+    convertstrtohex(data,hex_data,data_len*2);
+    i = 0;
+    while(i<data_len+1)
+    {
+        pdu[pos] |= hex_data[i]>>5;
+        pos++;
+        pdu[pos] = (hex_data[i] & 0x1F)<<3;
+        i++;
+    }
+    return pos;
+}
+
+void parse_3gpp_sms(char *src_3gpp_pdu,char *number,uint8 *num_len,int *dig_num_len,
+        char *sms_data,uint8 *data_len,int *dig_data_len,encode_e_type* encode_type)
+{
+    int pos =6;
+    int i = 0;
+    RLOGD("src_3gpp_pdu = %s",src_3gpp_pdu);
+    if((src_3gpp_pdu[pos]>='0') && (src_3gpp_pdu[pos] <= '9'))
+    {
+        *dig_num_len = (src_3gpp_pdu[pos]-'0')*16;
+    }
+    else if((src_3gpp_pdu[pos]>='a') && (src_3gpp_pdu[pos] <= 'f'))
+    {
+        *dig_num_len = ((src_3gpp_pdu[pos]-'a')+10)*16;
+    }
+    if((src_3gpp_pdu[pos+1]>='0') && (src_3gpp_pdu[pos+1] <= '9'))
+    {
+        *dig_num_len += src_3gpp_pdu[pos+1]-'0';
+    }
+    else if((src_3gpp_pdu[pos+1]>='a') && (src_3gpp_pdu[pos+1] <= 'f'))
+    {
+        *dig_num_len += (src_3gpp_pdu[pos+1]-'a')+10;
+    }
+    convertstrtohex(&src_3gpp_pdu[6],num_len,2);
+    pos = pos+4;
+    while(i<*dig_num_len)
+    {
+        number[i] = src_3gpp_pdu[pos+1];
+        number[i+1] = src_3gpp_pdu[pos];
+        i= i+2;
+        pos = pos+2;
+    }
+    pos = pos+3;
+    if('0' == src_3gpp_pdu[pos])
+    {
+        *encode_type = ENCODE_7BIT;
+    }
+    else if('8' == src_3gpp_pdu[pos])
+    {
+        *encode_type = ENCODE_UNICDE;
+    }
+    else
+    {
+        RLOGD("PDU encode type err!");
+        *encode_type = ENCODE_NULL;
+    }
+    pos = pos+1;
+    if((src_3gpp_pdu[pos]>='0') && (src_3gpp_pdu[pos] <= '9'))
+    {
+        *dig_data_len = (src_3gpp_pdu[pos]-'0')*16;
+    }
+    else if((src_3gpp_pdu[pos]>='a') && (src_3gpp_pdu[pos] <= 'f'))
+    {
+        *dig_data_len = ((src_3gpp_pdu[pos]-'a')+10)*16;
+    }
+    if((src_3gpp_pdu[pos+1]>='0') && (src_3gpp_pdu[pos+1] <= '9'))
+    {
+        *dig_data_len += src_3gpp_pdu[pos+1]-'0';
+    }
+    else if((src_3gpp_pdu[pos+1]>='a') && (src_3gpp_pdu[pos+1] <= 'f'))
+    {
+        *dig_data_len += (src_3gpp_pdu[pos+1]-'a')+10;
+    }
+    convertstrtohex(&src_3gpp_pdu[pos],data_len,2);
+
+    pos= pos+2;
+    i = 0;
+    while(i<(*dig_data_len*2))
+    {
+        sms_data[i] = src_3gpp_pdu[pos];
+        i++;
+        pos++;
+    }
+}
+#endif
+/*
+   request functions
+
+ **/
+void requestSendSMS( void* data, size_t datalen __unused, RIL_Token t )
+{
+    int err;
+    const char* smsc;
+    const char* pdu;
+    int tpLayerLength;
+    char* cmd1, *cmd2;
+    RIL_SMS_Response response;
+    ATResponse* p_response = NULL;
+    int send_retry = 0;
+#if 1
+    char phone_number[12];
+    char dst_3gpp2_pdu[500];
+    char hex_3gpp2_pdu[300];
+    char sms_data[250];
+    char hex_phone_num[6];
+    uint8 phone_num_len = 0;
+    int dig_num_len = 0;
+    uint8 dst_3gpp2_pdu_len = 0;
+    uint8 sms_data_len = 0;
+    int dig_sms_data_len = 0;
+    encode_e_type encode_type = ENCODE_NULL;
+
+    memset(phone_number,0x0,sizeof(phone_number));
+    memset(dst_3gpp2_pdu,0x0,sizeof(dst_3gpp2_pdu));
+    memset(sms_data,0x0,sizeof(sms_data));
+    memset(hex_3gpp2_pdu,0x0,sizeof(hex_3gpp2_pdu));
+    memset(hex_phone_num,0x0,sizeof(hex_phone_num));
+#endif
+
+    smsc = ( ( const char** )data )[0];
+    pdu = ( ( const char** )data )[1];
+    tpLayerLength = strlen( pdu ) / 2;
+    /*begin:added by lisf 20181121*/
+    int network_type = 0;
+    network_type = odm_get_current_network_type();
+    /*end:added by lisf 20181121*/
+    // "NULL for default SMSC"
+    if ( smsc == NULL )
+    {
+        smsc = "00";
+    }
+    asprintf( &cmd2, "%s%s", smsc, pdu );
+    // <!--[ODM]wangmengying@2019.8.13 bug10901,The telecom card receives the SMS and displays error characters.
+    if (((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper)) && (mode_flag < GHT_NL668))//modified not support for NL668 NORMAL by lisf 20190320
+    // end-->
+    {
+        if (strcmp(get_network_type(),"SRLTE") != 0)
+        {
+/*begin:modified by lisf 20181121*/
+            if (14 == network_type)
+/*end:modified by lisf 20181121*/
+            {
+                at_send_command("AT+MODODR=9",NULL);
+                handover_flag = 1;
+/*begin:modified by lisf 20181121*/
+                while(6 != network_type
+                        && 7!= network_type
+                        && 13!= network_type
+                        && 10> send_retry)
+ /*end:modified by lisf 20181121*/
+                {
+                    network_type = odm_get_current_network_type();
+                    sleep(1);
+                    send_retry++;
+                    RLOGD("send_retry = %d",send_retry);
+                }
+            }
+        }
+        parse_3gpp_sms(cmd2,phone_number,&phone_num_len,&dig_num_len,
+                sms_data,&sms_data_len,&dig_sms_data_len,&encode_type);
+        convertstrtohex(phone_number,hex_phone_num,dig_num_len);
+
+        if(ENCODE_7BIT == encode_type)
+        {
+            pdu_3gpp_7bit_2_3gpp2_7bit(sms_data);
+
+            dst_3gpp2_pdu_len = encode_cdma_sms_pdu_7bit(hex_3gpp2_pdu,hex_phone_num,phone_num_len,
+                    cdma_7bit_d.data_3pgg2_ptr,cdma_7bit_d.data_3pgg2_len,cdma_7bit_d.data_len);
+
+            converthextostr(hex_3gpp2_pdu,dst_3gpp2_pdu,dst_3gpp2_pdu_len+1);
+            tpLayerLength = strlen( dst_3gpp2_pdu ) / 2;
+        }
+        else if(ENCODE_UNICDE == encode_type)
+        {
+
+            dst_3gpp2_pdu_len = encode_cdma_sms_pdu(hex_3gpp2_pdu,hex_phone_num,phone_num_len,
+                    sms_data,sms_data_len);
+            converthextostr(hex_3gpp2_pdu,dst_3gpp2_pdu,dst_3gpp2_pdu_len);
+
+            tpLayerLength = strlen( dst_3gpp2_pdu ) / 2;
+        }
+
+        asprintf(&cmd1,"AT^HCMGS=%d",tpLayerLength);
+
+        asprintf(&cmd2,"%s",dst_3gpp2_pdu);
+        err = at_send_command_sms( cmd1, cmd2, "^HCMGS:", &p_response );
+    }
+    else
+    {
+        asprintf( &cmd1, "AT+CMGS=%d", tpLayerLength );
+        err = at_send_command_sms( cmd1, cmd2, "+CMGS:", &p_response );
+    }
+    RLOGD("err=%d,p_response->sucess=%d",err,p_response->success);
+    if ( err != 0 || p_response->success == 0 )
+    {
+        //goto error;
+        RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+        at_response_free( p_response );
+        return;
+    }
+
+    memset( &response, 0, sizeof( response ) );
+
+    if(Ght_Android_Version >= ANDROID_8 && Ght_Android_Version <= ANDROID_11)
+    {
+        RLOGD("[%s,%d]: version_check 8 <= Ght_Android_Version:%d <= 11 ?", __FUNCTION__, __LINE__, Ght_Android_Version);
+        response.messageRef = 1;
+    }
+
+#if 0
+#if defined GHT_FEATURE_ANDROID8X || defined GHT_FEATURE_ANDROID9X || defined GHT_FEATURE_ANDROID10X
+    response.messageRef = 1;  //added by lisf for debug 20181208
+#endif
+#endif
+    /* FIXME fill in messageRef and ackPDU */
+    RIL_onRequestComplete( t, RIL_E_SUCCESS, &response, sizeof( response ) );
+    at_response_free( p_response );
+    free(cmd1);
+    free(cmd2);
+    return;
+    /*
+error:
+RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+
+at_response_free(p_response);
+*/
+}
+
+/* BEGIN: Added by eric.li, 2019/1/9   PN:add support for send more message */
+void requestSendSMSExpectMore(void *data, size_t datalen, RIL_Token t)
+{
+        (void) data; (void) datalen;
+	//todo 
+        requestSendSMS(data, datalen, t);
+}
+/* END:   Added by eric.li, 2019/1/9   PN:add support for send more message */
+
+void requestSendCDMASMS( void* data, size_t datalen, RIL_Token t )
+{
+    RIL_SMS_Response response;
+    ATResponse* p_response = NULL;
+    RLOGD("CMDA data = %s,datalen=%zu",(char *)data,datalen);
+#if 0
+    smsc = ( ( const char** )data )[0];
+    pdu = ( ( const char** )data )[1];
+    tpLayerLength = strlen( pdu ) / 2;
+    // "NULL for default SMSC"
+    if ( smsc == NULL )
+    {
+        smsc = "00";
+    }
+
+    asprintf( &cmd2, "%s%s", smsc, pdu );
+    err = at_send_command_sms( cmd1, cmd2, "^HCMGS:", &p_response );
+    if ( err != 0 || p_response->success == 0 )
+    {
+        //goto error;
+        RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+        at_response_free( p_response );
+        return;
+    }
+
+    memset( &response, 0, sizeof( response ) );
+#endif
+    /* FIXME fill in messageRef and ackPDU */
+    RIL_onRequestComplete( t, RIL_E_SUCCESS, &response, sizeof( response ) );
+    at_response_free( p_response );
+    return;
+
+}
+
+void requestSMSAcknowledge( void* data __unused, size_t datalen __unused, RIL_Token t )
+{
+    /* modified by nodecom begin  we always think the sms received correct */
+    /*   int ackSuccess;
+         int err;
+         ackSuccess = ((int *)data)[0];
+         if (ackSuccess == 1)
+         {
+         err = at_send_command("AT+CNMA=1", NULL);
+         }
+         else if (ackSuccess == 0)
+         {
+         err = at_send_command("AT+CNMA=2", NULL);
+         }
+         else
+         {
+         ARLOGD("unsupported arg to RIL_REQUEST_SMS_ACKNOWLEDGE\n");
+    //goto error;
+
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    return;
+    }
+    */
+    /* modified by nodecom end*/
+    RIL_onRequestComplete( t, RIL_E_SUCCESS, NULL, 0 );
+    /*
+error:
+RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+*/
+}
+
+
+void requestWriteSmsToSim( void* data, size_t datalen __unused, RIL_Token t )
+
+{
+    RIL_SMS_WriteArgs* p_args;
+    char* cmd;
+    int length;
+    int err;
+    ATResponse* p_response = NULL;
+
+    p_args = ( RIL_SMS_WriteArgs* )data;
+    length = strlen( p_args->pdu ) / 2;
+	// <!--added by wangmengying@2020.2.21 fix CT card send sms
+    if (((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper)) && (mode_flag < GHT_NL668))
+	// end-->
+    {
+        asprintf(&cmd,"AT^HCMGW=%d,%d",length,p_args->status);
+        err = at_send_command_sms(cmd,p_args->pdu,"^HCMGW:",&p_response);
+    }
+    else
+    {
+        asprintf( &cmd, "AT+CMGW=%d,%d", length, p_args->status );
+
+        err = at_send_command_sms( cmd, p_args->pdu, "+CMGW:", &p_response );
+    }
+    free(cmd);
+    if ( err != 0 || p_response->success == 0 )
+    {
+        //goto error;
+        RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+    }
+    else
+    {
+        RIL_onRequestComplete( t, RIL_E_SUCCESS, NULL, 0 );
+    }
+    at_response_free( p_response );
+    return;
+}
+
+
+void requestDeleteSmsOnSim( void* data, size_t datalen __unused, RIL_Token t )
+
+{
+    char* cmd;
+    ATResponse* p_response;
+    int err;
+    p_response = NULL;
+
+	// <!--added by wangmengying@2020.2.21 fix CT card send sms
+    if(ODM_CT_OPERATOR_3G == cur_oper &&  mode_flag < GHT_NL668)
+	// end-->
+    {
+        /* BEGIN: Added by eric.li, 2018/11/5   PN:fix bug 0012360 for del sms on sim function */
+    	 err = at_send_command("AT$QCPMS=\"SM\",\"SM\",\"SM\"", NULL);
+         if (0 > err)
+         {
+             RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+         }
+    /* END:   Added by eric.li, 2018/11/5   PN:fix bug 0012360 for del sms on sim function */
+        asprintf( &cmd, "AT$QCMGD=%d", ( ( int* )data )[0] );
+        err = at_send_command( cmd, &p_response );
+    }
+    else
+    {
+    /* BEGIN: Added by eric.li, 2018/11/5   PN:fix bug 0012360 for del sms on sim function */
+    	 err = at_send_command("AT+CPMS=\"SM\",\"SM\",\"SM\"", NULL);
+	 if (0 > err)
+	{
+	        RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+	}
+    /* END:   Added by eric.li, 2018/11/5   PN:fix bug 0012360 for del sms on sim function */
+        asprintf( &cmd, "AT+CMGD=%d", ( ( int* )data )[0] );
+        err = at_send_command( cmd, &p_response );
+    }
+    free( cmd );
+    if ( err < 0 || p_response->success == 0 )
+    {
+        RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+    }
+    else
+    {
+        RIL_onRequestComplete( t, RIL_E_SUCCESS, NULL, 0 );
+    }
+    at_response_free( p_response );
+}
+
+
+// The follow functions are used to implement the  RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG request
+
+int numbercaculatebycomma( char* pdata )
+{
+    int count = 0;
+
+    while( *pdata )
+    {
+        if( ( *pdata == ',' ) && ( *( pdata + 1 ) != '\0' ) )
+        { count++; }
+
+        pdata++;
+    }
+    count++;
+    return count;
+}
+
+/**
+ *the GHT_nextTok is like nextTok in the at_tok.c
+ *it is for handling string
+ *
+ */
+static void GHT_skipWhiteSpace( char** p_cur )
+{
+    if ( *p_cur == NULL ) { return; }
+
+    while ( **p_cur != '\0' && isspace( **p_cur ) )
+    {
+        ( *p_cur )++;
+    }
+}
+
+static void GHT_skipNextComma( char** p_cur )
+{
+    if ( *p_cur == NULL ) { return; }
+
+    while ( **p_cur != '\0' &&** p_cur != ',' )
+    {
+        ( *p_cur )++;
+    }
+
+    if ( **p_cur == ',' )
+    {
+        ( *p_cur )++;
+    }
+}
+
+static char* GHT_nextTok( char** p_cur )
+{
+    char* ret = NULL;
+
+    GHT_skipWhiteSpace( p_cur );
+
+    if ( *p_cur == NULL )
+    {
+        ret = NULL;
+    }
+    else if ( **p_cur == '"' )
+    {
+        ( *p_cur )++;
+        ret = strsep( p_cur, "\"" );
+        GHT_skipNextComma( p_cur );
+    }
+    else
+    {
+        ret = strsep( p_cur, "," );
+    }
+
+    return ret;
+}
+
+
+
+
+
+void makeBSC( RIL_GSM_BroadcastSmsConfigInfo* BSC, int num, char* mids, char* dcss, int mids_num __unused, int dcss_num __unused, int select )
+{
+    int i;
+    char* ret;
+    char* end;
+    char* str_from;
+
+    for( i = 0; i < num; i++ )
+    {
+        BSC[i].selected = select ^ 0x01;
+    }
+
+    i = 0;
+
+    while( mids != NULL )
+    {
+        if( *mids == '\0' )
+        { break; }
+
+        ret = GHT_nextTok( &mids );
+        str_from = strsep( &ret, "-" );
+
+        if( ret == NULL )
+        {
+            BSC[i].fromServiceId = strtol( str_from, &end, 10 );
+            BSC[i].toServiceId =  BSC[i].fromServiceId;
+            i++;
+        }
+        else
+        {
+            BSC[i].fromServiceId = strtol( str_from, &end, 10 );
+            BSC[i].toServiceId =  strtol( ret, &end, 10 );
+            i++;
+        }
+
+    }
+
+    i = 0;
+
+    while( dcss != NULL )
+    {
+        if( *dcss == '\0' )
+        { break; }
+
+        ret = GHT_nextTok( &dcss );
+        str_from = strsep( &ret, "-" );
+
+        if( ret == NULL )
+        {
+            BSC[i].fromCodeScheme = strtol( str_from, &end, 10 );
+            BSC[i].toCodeScheme =  BSC[i].fromCodeScheme;
+            i++;
+        }
+        else
+        {
+            BSC[i].fromCodeScheme = strtol( str_from, &end, 10 );
+            BSC[i].toCodeScheme =  strtol( ret, &end, 10 );
+            i++;
+        }
+
+    }
+}
+void requestGsmGetBroadcastSMSConfig( void* data __unused, size_t datalen __unused, RIL_Token t )
+{
+    int err;
+    char* line;
+    int select;
+    char* mids;
+    int mids_num = 0;
+    char* dcss;
+    int dcss_num = 0;
+    int num;
+    int i;
+    RIL_GSM_BroadcastSmsConfigInfo** response;
+    RIL_GSM_BroadcastSmsConfigInfo* BSC;
+    ATResponse* p_response;
+
+    err = at_send_command_singleline( "AT+CSCB?", "+CSCB:", &p_response );
+
+    if( err < 0 || p_response->success == 0 )
+    { RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 ); }
+    else
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start( &line );               // skip the +CSCB:
+
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+
+        err = at_tok_nextint( &line, &select );
+
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+
+        err = at_tok_nextstr( &line, &mids );
+
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+
+        err = at_tok_nextstr( &line, &dcss );
+
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+
+        mids_num = numbercaculatebycomma( mids );
+        dcss_num = numbercaculatebycomma( dcss );
+        num = ( mids_num > dcss_num ) ? mids_num : dcss_num;
+        BSC = ( RIL_GSM_BroadcastSmsConfigInfo* )malloc( num * sizeof( RIL_GSM_BroadcastSmsConfigInfo ) );
+        response = ( RIL_GSM_BroadcastSmsConfigInfo** )malloc( num * sizeof( RIL_GSM_BroadcastSmsConfigInfo* ) );
+        memset( BSC, -1, num * sizeof( RIL_GSM_BroadcastSmsConfigInfo ) );
+
+        for( i = 0; i < num; i++ )
+        { response[i] = &BSC[i]; }
+
+        makeBSC( BSC, num, mids, dcss, mids_num, dcss_num, select );
+
+        RIL_onRequestComplete( t, RIL_E_SUCCESS, response, num * sizeof( RIL_GSM_BroadcastSmsConfigInfo* ) );
+        free( BSC );
+        free( response );
+    }
+
+    at_response_free( p_response );
+}
+// RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG request function
+char* substrsep( char** srcstr, char* substr )
+{
+    char* ret = *srcstr;
+    int loc = 0;
+
+    if( strlen( *srcstr ) < strlen( substr ) )
+    {
+        *srcstr = NULL;
+        return ret;
+    }
+
+    if( strstr( *srcstr, substr ) == NULL )
+    {
+        *srcstr = NULL;
+        return ret;
+    }
+
+    *srcstr = strstr( *srcstr, substr );
+    loc = strlen( ret ) - strlen( *srcstr );
+    *srcstr = *srcstr + ( strlen( substr ) );
+
+    *( ret + loc ) = '\0';
+
+    return ret;
+}
+void removefromstr( char* substr, char* oldstr, char** newstr )
+{
+    char* ret;
+
+    ret = substrsep( &oldstr, substr );
+    asprintf( newstr, "%s", ret );
+
+    while( oldstr != NULL )  // find substr in oldstr
+    {
+        if( *oldstr == ',' )
+        { oldstr++; }
+
+        asprintf( newstr, "%s%s", *newstr, oldstr );
+        ret = substrsep( &oldstr, substr );
+    }
+}
+void addtostr( char* substr, char* oldstr, char** newstr )
+{
+    removefromstr( substr, oldstr, newstr );
+    asprintf( newstr, "%s%s", *newstr, substr );
+}
+int createnewMIDSS( void* data, size_t datalen, char** oldmidsstr, char** newmidsstr )
+{
+    RIL_GSM_BroadcastSmsConfigInfo** gsmBciPtrs = ( RIL_GSM_BroadcastSmsConfigInfo** )data;
+    int num = datalen / sizeof( RIL_GSM_BroadcastSmsConfigInfo* );
+    char* sub_mid_str;
+    int len;
+    int i;
+
+    for( i = 0; i < num; i++ ) // for services ids
+    {
+        if( ( gsmBciPtrs[i]->fromServiceId ) != ( gsmBciPtrs[i]->toServiceId ) )
+        { asprintf( &sub_mid_str, "%d-%d,", gsmBciPtrs[i]->fromServiceId, gsmBciPtrs[i]->toServiceId ); }
+        else
+        { asprintf( &sub_mid_str, "%d,", gsmBciPtrs[i]->fromServiceId ); }
+
+        if( 1 == gsmBciPtrs[i]->selected )
+        { addtostr( sub_mid_str, *oldmidsstr, newmidsstr ); }
+        else if ( 0 == gsmBciPtrs[i]->selected )
+        { removefromstr( sub_mid_str, *oldmidsstr, newmidsstr ); }
+
+        *oldmidsstr = *newmidsstr;
+    }
+
+    if( **newmidsstr == '\0' )
+    {
+        return -1;
+    }
+
+    len = strlen( *newmidsstr );
+
+    if( *( *newmidsstr + len - 1 ) == ',' )
+    { *( *newmidsstr + len - 1 ) = '\0'; }
+
+    return 0;
+}
+void createnewDICSS( void* data, size_t datalen, char** olddcssstr, char** newdcssstr )
+{
+    RIL_GSM_BroadcastSmsConfigInfo** gsmBciPtrs = ( RIL_GSM_BroadcastSmsConfigInfo** )data;
+    int num = datalen / sizeof( RIL_GSM_BroadcastSmsConfigInfo* );
+    char* sub_dcs_str;
+    int len;
+    int i;
+
+    for( i = 0; i < num; i++ ) //for CodeScheme configration
+    {
+        if( ( gsmBciPtrs[i]->fromCodeScheme ) != ( gsmBciPtrs[i]->toCodeScheme ) )
+        { asprintf( &sub_dcs_str, "%d-%d,", gsmBciPtrs[i]->fromCodeScheme, gsmBciPtrs[i]->toCodeScheme ); }
+        else
+        { asprintf( &sub_dcs_str, "%d,", gsmBciPtrs[i]->fromCodeScheme ); }
+
+        if( 1 == gsmBciPtrs[i]->selected )
+        { addtostr( sub_dcs_str, *olddcssstr, newdcssstr ); }
+        else if ( 0 == gsmBciPtrs[i]->selected )
+        { removefromstr( sub_dcs_str, *olddcssstr, newdcssstr ); }
+
+        *olddcssstr = *newdcssstr;
+    }
+
+    len = strlen( *newdcssstr );
+
+    if( *( *newdcssstr + len - 1 ) == ',' )
+    { *( *newdcssstr + len - 1 ) = '\0'; }
+}
+void requestGsmSetBroadcastSMSConfig( void* data, size_t datalen, RIL_Token t )
+{
+    int err;
+    char* cmd;
+    char* line;
+    ATResponse* p_response;
+    int select = -1;
+    char* oldmidsstr, *newmidsstr;
+    char* olddcssstr, *newdcssstr;
+
+    err = at_send_command_singleline( "AT+CSCB?", "+CSCB:", &p_response );
+    if( err < 0 || p_response->success == 0 )
+    {
+        at_response_free( p_response );
+        RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+        return;
+    }
+    else
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start( &line );               // skip the +CSCB:
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+        err = at_tok_nextint( &line, &select );
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+        err = at_tok_nextstr( &line, &oldmidsstr );
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+        err = at_tok_nextstr( &line, &olddcssstr );
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+    }
+
+
+    if( *oldmidsstr != '\0' )
+    { asprintf( &oldmidsstr, "%s,", oldmidsstr ); }
+
+    if( *olddcssstr != '\0' )
+    { asprintf( &olddcssstr, "%s,", olddcssstr ); }
+
+    err = createnewMIDSS( data, datalen, &oldmidsstr, &newmidsstr );
+
+    if( err == -1 )
+    {
+        RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+        at_response_free( p_response );
+        return;
+    }
+
+    createnewDICSS( data, datalen, &olddcssstr, &newdcssstr );
+    asprintf( &cmd, "AT+CSCB=0,\"%s\",\"%s\"", newmidsstr, newdcssstr );
+
+    at_response_free( p_response );
+    err = at_send_command( "AT+CSCB=1", &p_response );
+
+    if( err < 0 || p_response->success == 0 )
+    {
+        RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+        at_response_free( p_response );
+        return;
+    }
+
+    at_response_free( p_response );
+    err = at_send_command( cmd, &p_response );
+    free(cmd);
+
+    if( err < 0 || p_response->success == 0 )
+    { RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 ); }
+    else
+    { RIL_onRequestComplete( t, RIL_E_SUCCESS, NULL, 0 ); }
+
+    at_response_free( p_response );
+}
+// RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION
+void requestGsmSMSBroadcastActivation( void* data, size_t datalen __unused, RIL_Token t )
+{
+    int activate_flag = ( ( int* )data )[0];
+    int err;
+    char* cmd;
+    ATResponse* p_response;
+
+	// <!--added by wangmengying@2020.2.21 fix CT card send sms
+    if(ODM_CT_OPERATOR_3G == cur_oper &&  mode_flag < GHT_NL668)
+	// end-->
+    {
+        if( 0 == activate_flag )
+        { asprintf( &cmd, "AT$QCNMI=,,2,," ); }
+        else if ( 1 == activate_flag )
+        { asprintf( &cmd, "AT$QCNMI=,,0,," ); }
+        else
+        {
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+    }
+    else
+    {
+        if( 0 == activate_flag )
+        { asprintf( &cmd, "AT+CNMI=,,2,," ); }
+        else if ( 1 == activate_flag )
+        { asprintf( &cmd, "AT+CNMI=,,0,," ); }
+        else
+        {
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+    }
+
+    err = at_send_command( cmd, &p_response );
+    free(cmd);
+
+    if( err < 0 || p_response->success == 0 )
+    { RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 ); }
+    else
+    { RIL_onRequestComplete( t, RIL_E_SUCCESS, NULL, 0 ); }
+
+    at_response_free( p_response );
+}
+void requestGetSMSCAddress( void* data __unused, size_t datalen __unused, RIL_Token t )
+{
+    int err;
+    ATResponse* p_response = NULL;
+    char* line;
+    char response[22];
+
+    err = at_send_command_singleline( "AT+CSCA?", "+CSCA:", &p_response );
+
+    if( err < 0 || p_response->success == 0 )
+    {
+        RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+    }
+    else
+    {
+        line = p_response->p_intermediates->line;
+        err = at_tok_start( &line );               // skip the +CSCA:
+
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+
+        err = at_tok_nextstr( &line, &response );  // get the sms center string
+
+        if( err < 0 )
+        {
+            at_response_free( p_response );
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+
+        RIL_onRequestComplete( t, RIL_E_SUCCESS, &response, sizeof( response ) );
+    }
+
+    at_response_free( p_response );
+}
+void requestSetSMSCAddress( void* data, size_t datalen __unused, RIL_Token t )
+{
+    char* center_num = ( char* )data;
+    char* cmd = NULL;
+    int err;
+    ATResponse* p_response;
+
+    if( center_num[0] == '+' )
+    { asprintf( &cmd, "AT+CSCA=%s,145", center_num ); } // international number
+    else
+    {
+       //modified for NL678-E-00
+		if(mode_flag < GHT_MDM_NORMAL)
+		{
+			asprintf( &cmd, "AT+CSCA=%s,161", center_num ); 
+		}
+		else if(mode_flag <= GHT_NL678_E || mode_flag >= GHT_MDM_NORMAL)
+		{
+                    asprintf( &cmd, "AT+CSCA=%s,129", center_num ); 
+		}
+
+	}
+
+    err = at_send_command( cmd, &p_response );
+    free(cmd);
+
+    if( err < 0 || p_response->success == 0 )
+    { RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 ); }
+    else
+    { RIL_onRequestComplete( t, RIL_E_SUCCESS, NULL, 0 ); }
+
+    at_response_free( p_response );
+}
+void requestReportSMSMemoryStatus( void* data, size_t datalen __unused, RIL_Token t )
+{
+    int memory_availble = ( ( int* )data )[0];
+    int err;
+    ATResponse* p_response;
+    char cmd[24] = {0};
+    memset(cmd, 0, sizeof(cmd));
+
+	//modified for NL678-E-00
+	// <!--added by wangmengying@2020.2.21 fix CT card send sms
+    if(ODM_CT_OPERATOR_3G == cur_oper && mode_flag < GHT_NL668)
+	// end-->
+    {
+        if( 1 == memory_availble )
+        { sprintf(cmd, "%s", "AT$QCNMI=3,1" ); }
+        else if ( 0 == memory_availble )
+        { sprintf(cmd, "%s", "AT$QCNMI=0,0" ); }
+        else
+        {
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+    }
+    else
+    {
+        if( 1 == memory_availble )
+        { 
+				//modified for NL678-E-00
+				if(mode_flag < GHT_NL678_E)
+				{
+					sprintf(cmd, "%s", "AT+CNMI=3,1" ); 
+				}
+				else if(mode_flag == GHT_NL678_E)
+				{
+					sprintf(cmd, "%s", "AT+CNMI=1,1" ); 
+				}
+		  }
+        else if ( 0 == memory_availble )
+        { sprintf(cmd, "%s", "AT+CNMI=0,0" ); }
+        else
+        {
+            RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 );
+            return;
+        }
+    }
+
+    err = at_send_command( cmd, &p_response );
+
+    if( err < 0 || p_response->success == 0 )
+    { RIL_onRequestComplete( t, RIL_E_GENERIC_FAILURE, NULL, 0 ); }
+    else
+    { RIL_onRequestComplete( t, RIL_E_SUCCESS, NULL, 0 ); }
+
+    at_response_free( p_response );
+}
+/*  functions called when AT command comes up
+ *
+ */
+void onNewSmsNotification( char* s )
+{
+    //add by nodecom
+    /* can't issue AT commands here -- call on main thread */
+    RLOGD( "********enter onNewSmsNotification********" );
+
+// <!--added by wangmengying@2018.8.1 for recives SMS
+    static int location;
+// end--!>
+    char* response = NULL;
+    char* tmp;
+    char* line = NULL;
+    int err;
+
+    if( strStartsWith( s, "+CMTI:" ) )
+    {
+        sms_type = SMS_GENERAL;
+    }
+    else if ( strStartsWith( s, "+CDSI:" ) )
+    {
+        sms_type = SMS_SEND_REPORT;
+
+
+    }
+    else if( strStartsWith( s, "+CBMI:" ) )
+    {
+        sms_type = SMS_BROADCAST;
+    }
+
+    line = strdup( s );
+    tmp = line;
+    at_tok_start( &tmp );
+
+    err = at_tok_nextstr( &tmp, &response );
+
+    if ( err < 0 )
+    {
+        RLOGD( "sms request fail" );
+        free( line );
+        return;
+    }
+
+      //do not handle "+CDSI: "SR","XXX"" //added by lisf 20190225
+       if (!strcmp(response, "SR"))
+       {
+           RLOGD("sms request arrive but it is not a new sms");
+           free(line);
+           return;
+       }
+       
+
+    /* Read the memory location of the sms */
+    err = at_tok_nextint( &tmp, &location );
+
+    if ( err < 0 )
+    {
+        RLOGD( "error parse location" );
+        free( line );
+        return;
+    }
+
+    /*
+       asprintf(&cmd, "AT+CPMS=%s,%s,%s", "ME","ME","ME");
+    //at_send_command("AT+CPMS=\"ME\",\"ME\",\"ME\"", NULL);
+    at_send_command(cmd, NULL);
+    free(cmd);
+    if (!strcmp(response, "SR"))
+    {
+    NEW_SMS_TYPE =
+    //err=at_send_command("AT+CPMS=\"SR\",\"SR\",\"SR\"", NULL);
+    asprintf(&cmd, "AT+CPMS=%s,%s,%s", "SR","SR","SR");
+    err = at_send_command(cmd, NULL);
+    free(cmd);
+    if (err < 0)
+    {
+    RLOGD("******** set cpms failed,so we lost sms report ********");
+    RLOGD("******** err=%d",err);
+    return;
+    }
+    }
+    */
+    RLOGD( "********LEAVE onNewSmsNotification********" );
+// <!--added by wangmengying@2018.8.1 for recives SMS
+    RIL_requestTimedCallback ( receiveSMS, ( void* )&location, NULL );
+// end--!>
+    free( line );
+}
+
+void receiveSMS( void *param )
+{
+    int *ptr = (int*)param;
+    int location = *ptr;
+    char* cmd;
+    RLOGD("cur_oper %d", cur_oper);
+    // <!--added by wangmengying@2020.2.21 fix CT card send sms
+    if (((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper)) && (mode_flag < GHT_NL668))
+    {
+        asprintf( &cmd, "AT+CMGR=%d", location );
+        /* request the sms in a specific location */
+        at_send_command( cmd, NULL );
+        free( cmd );
+
+        /* remove the sms from specific location XXX temp fix*/
+        asprintf( &cmd, "AT$QCMGD=%d,0", location );
+        at_send_command( cmd, NULL );
+        free( cmd );
+    }
+    else
+    {
+        asprintf( &cmd, "AT+CMGR=%d", location );
+        /* request the sms in a specific location */
+        at_send_command( cmd, NULL );
+        free( cmd );
+
+        /* remove the sms from specific location XXX temp fix*/
+        asprintf( &cmd, "AT+CMGD=%d,0", location );
+        at_send_command( cmd, NULL );
+        free( cmd );
+    }
+    return;
+}
+#endif
diff --git a/hardware/ril/youyou_ril/sms.h b/hardware/ril/youyou_ril/sms.h
new file mode 100755
index 0000000..5e15ae1
--- /dev/null
+++ b/hardware/ril/youyou_ril/sms.h
@@ -0,0 +1,69 @@
+
+/*
+ *  sms.h
+ *  
+ *
+ *  Created by fupeilong on 1/22/11.
+ *  Copyright 2011 __MyCompanyName__. All rights reserved.
+ *
+ */
+ 
+/*when who why modified*/
+
+#ifndef SMS_H
+#define SMS_H 1
+#endif
+
+
+/*added by nodecom  for adding sms_send_report begin */
+typedef enum
+{
+    SMS_GENERAL = 0, 
+    SMS_SEND_REPORT = 1,
+    SMS_BROADCAST = 2
+} SMS_Type;
+
+/*added by nodecom  for adding sms_send_report end */
+/*  request functions
+ *
+ */
+
+// <!--added by wangmengying@2018.8.1 for recives SMS
+void receiveSMS(void *param);
+// end--!>
+
+void requestWriteSmsToSim(void *data, size_t datalen, RIL_Token t);
+
+void requestSendSMS(void *data, size_t datalen, RIL_Token t);
+
+void requestSMSAcknowledge(void *data, size_t datalen, RIL_Token t);
+
+void requestDeleteSmsOnSim(void *data, size_t datalen, RIL_Token t);
+
+#if 1
+/* added by nodecom begin */
+
+void requestGsmGetBroadcastSMSConfig(void *data, size_t datalen, RIL_Token t);
+
+void requestGsmSetBroadcastSMSConfig(void *data, size_t datalen, RIL_Token t);
+
+void requestGsmSMSBroadcastActivation(void *data, size_t datalen, RIL_Token t);
+
+void requestGetSMSCAddress(void *data, size_t datalen, RIL_Token t);
+ 
+void requestSetSMSCAddress(void *data, size_t datalen, RIL_Token t);
+
+void requestReportSMSMemoryStatus(void *data, size_t datalen, RIL_Token t);
+
+/* added by nodecom end */
+#endif
+/* * 
+ * functions called when AT command comes up  
+ *
+ */
+void onNewSmsNotification(char *line);
+
+/* BEGIN: Added by eric.li, 2019/1/11   PN:add support for send more message */
+void requestSendSMSExpectMore(void *data, size_t datalen, RIL_Token t);
+/* END:   Added by eric.li, 2019/1/11   PN:add support for send more message */
+
diff --git a/hardware/ril/youyou_ril/voice.c b/hardware/ril/youyou_ril/voice.c
new file mode 100755
index 0000000..65281e0
--- /dev/null
+++ b/hardware/ril/youyou_ril/voice.c
@@ -0,0 +1,940 @@
+/******************************************************************************
+  Copyright (C), 2019, Shenzhen G&T Industrial Development Co., Ltd
+
+  File:      voice.c
+
+  Author:  Fibocom-diego
+  Version: 1.0
+  Date:  2019.04
+
+  Description:   voices APIs
+
+** History:
+**Author (core ID)                Date          Number     Description of Changes
+**-----------------------------------------------------------------------------
+** NODECOM-Aron                30-10-2018         **   init version 
+** FIBOCOM-diego               10-01-2019         **   add requestDeviceIdentity support Androdi8.1
+** FIBOCOM-diego               15-04-2019         **   modify requestGetCurrentCalls return fake value for M910
+** -----------------------------------------------------------------------------
+******************************************************************************/
+#include <telephony/ril.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <alloca.h>
+#include "atchannel.h"
+#include "at_tok.h"
+#include "misc.h"
+#include <getopt.h>
+#include <sys/socket.h>
+#include <cutils/sockets.h>
+#include <cutils/properties.h>
+#include <termios.h>
+
+#include "ril_common.h"
+#include "voice.h"
+
+#define LOG_TAG GHT_RIL
+#include <utils/Log.h>
+
+//<!--[ODM][CLCC] gaoyunlai 20150506 modified for can not get the status of call when another hang up in call.
+#define POLL_CALL_STATE
+//end-->
+
+// <!--added by wangmengying@2018.8.1 for Call Waiting and Call Forwarding
+#define TIME_OUT_CGACT 151000
+// end--!>
+
+static const struct timeval TIMEVAL_CALLSTATEPOLL = {0,500000};
+extern int cur_oper;
+int voice_handover_flag = 0;
+//added for NL678-E-00
+extern product_model mode_flag;
+extern int odm_get_current_network_type();
+extern char *get_network_type();
+extern void OnResumeLTENetwork();
+
+RIL_Call *current_calls;
+int current_call_counts;
+
+/*called by callFromCLCCLine()*/
+static int clccStateToRILState(int state, RIL_CallState *p_state)
+{
+    switch(state)
+    {
+        case 0:
+            *p_state = RIL_CALL_ACTIVE;
+            return 0;
+        case 1:
+            *p_state = RIL_CALL_HOLDING;
+            return 0;
+        case 2:
+            *p_state = RIL_CALL_DIALING;
+            return 0;
+        case 3:
+            *p_state = RIL_CALL_ALERTING;
+            return 0;
+        case 4:
+            *p_state = RIL_CALL_INCOMING;
+            return 0;
+        case 5:
+            *p_state = RIL_CALL_WAITING;
+            return 0;
+        default:
+            return -1;
+    }
+}
+
+/**
+ * Note: directly modified line and has *p_call point directly into
+ * modified line
+ * called by requestGetCurrentCalls()
+ */
+static int callFromCLCCLine(char *line, RIL_Call *p_call)
+{
+    //+CLCC: 1,0,2,0,0,\"+18005551212\",145
+    //     index,isMT,state,mode,isMpty(,number,TOA)?
+
+    int err;
+    int state;
+    int mode;
+    err = at_tok_start(&line);
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &(p_call->index));
+    if (err < 0) goto error;
+    err = at_tok_nextbool(&line, &(p_call->isMT));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &state);
+    if (err < 0) goto error;
+
+    err = clccStateToRILState(state, &(p_call->state));
+    if (err < 0) goto error;
+
+    err = at_tok_nextint(&line, &mode);
+    if (err < 0) goto error;
+
+    p_call->isVoice = (mode == 0);
+
+    err = at_tok_nextbool(&line, &(p_call->isMpty));
+    if (err < 0) goto error;
+
+    if (at_tok_hasmore(&line))
+    {
+        err = at_tok_nextstr(&line, &(p_call->number));
+        /* tolerate null here */
+        if (err < 0)
+            return 0;
+        // Some lame implementations return strings
+        // like "NOT AVAILABLE" in the CLCC line
+        if (p_call->number != NULL
+                && 0 == strspn(p_call->number, "+0123456789"))
+        {
+            p_call->number = NULL;
+        }
+        err = at_tok_nextint(&line, &p_call->toa);
+        if (err < 0) goto error;
+    }
+    return 0;
+
+error:
+    RLOGD("invalid CLCC line\n");
+    return -1;
+}
+
+
+/*called by requestGetCurrentCalls()*/
+static void sendCallStateChanged(void *param __unused)
+{
+    RIL_onUnsolicitedResponse (
+            RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED,
+            NULL, 0);
+}
+
+void requestGetCurrentCalls(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err;
+    ATResponse *p_response;
+    ATLine *p_cur;
+    int countCalls;
+    int countValidCalls;
+    RIL_Call *p_calls;
+    RIL_Call **pp_calls;
+    int i;
+    int needRepoll = 0;
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+    int prevIncomingOrWaitingLine;
+
+    prevIncomingOrWaitingLine = s_incomingOrWaitingLine;
+    s_incomingOrWaitingLine = -1;
+#endif /*WORKAROUND_ERRONEOUS_ANSWER*/
+
+    //fake clcc response for 910 NB-iOT
+    if(mode_flag == GHT_M910_GL)
+    {
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+        return;
+    }
+    err = at_send_command_multiline ("AT+CLCC", "+CLCC:", &p_response);
+
+    if (err != 0 || p_response->success == 0)
+    {
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+        at_response_free(p_response);
+        return;
+    }
+
+    /* count the calls */
+    for (countCalls = 0, p_cur = p_response->p_intermediates
+            ; p_cur != NULL; p_cur = p_cur->p_next)
+    {
+        countCalls++;
+    }
+
+    /* yes, there's an array of pointers and then an array of structures */
+
+    pp_calls = (RIL_Call **)alloca(countCalls * sizeof(RIL_Call *));
+    p_calls = (RIL_Call *)alloca(countCalls * sizeof(RIL_Call));
+    memset (p_calls, 0, countCalls * sizeof(RIL_Call));
+
+    current_calls = (RIL_Call *)alloca(countCalls * sizeof(RIL_Call));
+    memset (current_calls, 0, countCalls * sizeof(RIL_Call));
+
+    /* init the pointer array */
+    for(i = 0; i < countCalls ; i++)
+    {
+        pp_calls[i] = &(p_calls[i]);
+    }
+    for (countValidCalls = 0, p_cur = p_response->p_intermediates
+            ; p_cur != NULL; p_cur = p_cur->p_next)
+    {
+
+        err = callFromCLCCLine(p_cur->line, p_calls + countValidCalls);
+        if (err != 0)
+        {
+            // <!--[ODM]wangmengying@2019.9.11 bug29133,stat is 6(released),should reply error
+            //continue;
+            break;
+            // end-->
+        }
+
+        //isDataAllowed=flase when use 4G SIM card
+        RLOGD("requestGetCurrentCalls p_calls[%d].isVoice=%d",
+                countValidCalls, p_calls[countValidCalls].isVoice );
+        if(p_calls[countValidCalls].isVoice == false)
+        {
+            continue;
+        }
+
+        current_calls[countValidCalls].index = p_calls[countValidCalls].index;
+        current_calls[countValidCalls].state = p_calls[countValidCalls].state;
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+        if (p_calls[countValidCalls].state == RIL_CALL_INCOMING
+                || p_calls[countValidCalls].state == RIL_CALL_WAITING
+           )
+        {
+            s_incomingOrWaitingLine = p_calls[countValidCalls].index;
+        }
+#endif /*WORKAROUND_ERRONEOUS_ANSWER*/
+
+        if (p_calls[countValidCalls].state != RIL_CALL_ACTIVE
+                && p_calls[countValidCalls].state != RIL_CALL_HOLDING)
+        {
+            needRepoll = 1;
+        }
+
+        countValidCalls++;
+    }
+
+    // <!--[ODM]wangmengying@2019.9.11 bug29133,stat is 6(released),should reply error
+    if (err != 0)
+    {
+        RLOGD("[%s,%d],err is [%d].\r",__FUNCTION__, __LINE__, err);
+        goto error;
+    }
+    //end-->
+
+    current_call_counts = countValidCalls;
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+    // Basically:
+    // A call was incoming or waiting
+    // Now it's marked as active
+    // But we never answered it
+    //
+    // This is probably a bug, and the call will probably
+    // disappear from the call list in the next poll
+    if (prevIncomingOrWaitingLine >= 0
+            && s_incomingOrWaitingLine < 0
+            && s_expectAnswer == 0
+       )
+    {
+        for (i = 0; i < countValidCalls ; i++)
+        {
+
+            if (p_calls[i].index == prevIncomingOrWaitingLine
+                    && p_calls[i].state == RIL_CALL_ACTIVE
+                    && s_repollCallsCount < REPOLL_CALLS_COUNT_MAX
+               )
+            {
+                RLOGD(
+                        "Hit WORKAROUND_ERRONOUS_ANSWER case."
+                        " Repoll count: %d\n", s_repollCallsCount);
+                s_repollCallsCount++;
+                goto error;
+            }
+        }
+    }
+
+    s_expectAnswer = 0;
+    s_repollCallsCount = 0;
+#endif /*WORKAROUND_ERRONEOUS_ANSWER*/
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, pp_calls,
+            countValidCalls * sizeof (RIL_Call *));
+
+    at_response_free(p_response);
+
+#ifdef POLL_CALL_STATE
+    if (countValidCalls)    // We don't seem to get a "NO CARRIER" message from
+        // smd, so we're forced to poll until the call ends.
+#else
+        if (needRepoll)
+#endif
+        {
+            RIL_requestTimedCallback (sendCallStateChanged, NULL, &TIMEVAL_CALLSTATEPOLL);
+        }
+
+    return;
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+
+
+void requestDial(void *data, size_t datalen __unused, RIL_Token t)
+{
+    RIL_Dial *p_dial;
+    char *cmd;
+    const char *clir;
+    int ret;
+    int send_retry = 0;
+    p_dial = (RIL_Dial *)data;
+    /*begin:added by lisf 20181121*/
+    int network_type = 0;
+    network_type = odm_get_current_network_type();
+    /*end:added by lisf 20181121*/
+    switch (p_dial->clir)
+    {
+        case 1:
+            clir = "I";
+            break;  /*invocation*/
+        case 2:
+            clir = "i";
+            break;  /*suppression*/
+        default:
+        case 0:
+            clir = "";
+            break;   /*subscription default*/
+    }
+    RLOGD("voice dial begin");
+    //asprintf(&cmd, "ATD%s%s;", p_dial->address, clir);
+	// <!--added by wangmengying@2020.2.21 fix bug41287,use CT card,modify dial AT command
+    if (((ODM_CT_OPERATOR_3G == cur_oper) ||(ODM_CT_OPERATOR_4G == cur_oper)) && (mode_flag < GHT_NL668))
+	// end-->
+    {
+        if (strcmp(get_network_type(),"SRLTE") != 0)
+        {
+/*begin:modified by lisf 20181121*/
+            if(14 == network_type)
+/*end:modified by lisf 20181121*/
+            {
+                at_send_command("AT+MODODR=8",NULL);
+                voice_handover_flag =1 ; //added by lisf 20190315
+
+/*begin:modified by lisf 20181121*/
+                while(6 != network_type
+                        && 7!= network_type
+                        && 13!= network_type
+                        && 10> send_retry)
+ /*end:modified by lisf 20181121*/
+                {
+                    network_type = odm_get_current_network_type();
+                    sleep(1);
+                    send_retry++;
+                    RLOGD("send_retry = %d",send_retry);
+                }
+            }
+        }
+        sleep(3);
+        asprintf(&cmd, "AT+CDV%s%s;", p_dial->address, clir);
+    }
+    else
+    {
+        asprintf(&cmd, "ATD%s%s;", p_dial->address, clir);
+    }
+    ret = at_send_command(cmd, NULL);
+
+    free(cmd);
+
+    /* success or failure is ignored by the upper layer here.
+       it will call GET_CURRENT_CALLS and determine success that way */
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+void  requestGetMute(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int response = 0;
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, &response,sizeof(response));
+}
+
+// <!--added by wangmengying@2018.8.1 for DTMF
+void requestDTMFStart(void *data, size_t datalen __unused, RIL_Token t)
+{
+    char c = ((char *)data)[0];
+    char *cmd = NULL;
+    //modified for NL678-E-00
+    if((mode_flag <=  GHT_NL678_E) || (mode_flag == GHT_MA510_GL) || (mode_flag == GHT_FG650))
+    {
+    	    asprintf(&cmd, "AT+VTS=\"%c\"", c);
+    }
+    at_send_command(cmd, NULL);
+    free(cmd);
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+void requestDTMFStop(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int err;
+
+    /* Send a command to cancel the DTMF tone*/
+    err = at_send_command("AT",NULL);
+    if (err != 0)
+        goto error;
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    return;
+
+error:
+    RLOGE("ERROR: requestDtmfStop failed");
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+
+void requestDTMF(void *data, size_t datalen __unused, RIL_Token t)
+{
+    char c = ((char *)data)[0];
+    char *cmd = NULL;
+
+    //modified for NL678-E-00
+    if((mode_flag <=  GHT_NL678_E) || (mode_flag == GHT_MA510_GL))
+    {
+    	    asprintf(&cmd, "AT+VTS=\"%c\"", c);
+    }
+
+    at_send_command(cmd, NULL);
+    free(cmd);
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+
+}
+// end--!>
+
+void requestSeparateConnection(void *data, size_t datalen __unused, RIL_Token t)
+{
+    char  cmd[12];
+    int   party = ((int*)data)[0];
+
+    // Make sure that party is in a valid range.
+    // (Note: The Telephony middle layer imposes a range of 1 to 7.
+    // It's sufficient for us to just make sure it's single digit.)
+    if (party > 0 && party < 10)
+    {
+        sprintf(cmd, "AT+CHLD=2%d", party);
+        at_send_command(cmd, NULL);
+        RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    }
+    else
+    {
+        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    }
+}
+
+void requestUDUB(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    /* user determined user busy */
+    /* sometimes used: ATH */
+    at_send_command("ATH", NULL);
+    /* success or failure is ignored by the upper layer here.
+       it will call GET_CURRENT_CALLS and determine success that way */
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+void requestConference(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    // 3GPP 22.030 6.5.5
+    // "Adds a held call to the conversation"
+    at_send_command("AT+CHLD=3", NULL);
+    /* success or failure is ignored by the upper layer here.
+       it will call GET_CURRENT_CALLS and determine success that way */
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+void requestAnswer(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    at_send_command("ATA", NULL);
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+    s_expectAnswer = 1;
+#endif  /* WORKAROUND_ERRONEOUS_ANSWER */
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+void requestSwitchWaitingOrHoldingAndActive(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    // 3GPP 22.030 6.5.5
+    // "Places all active calls (if any exist) on hold and accepts
+    //  the other (held or waiting) call."
+    at_send_command("AT+CHLD=2", NULL);
+
+#ifdef WORKAROUND_ERRONEOUS_ANSWER
+    s_expectAnswer = 1;
+#endif /* WORKAROUND_ERRONEOUS_ANSWER */
+
+    /* success or failure is ignored by the upper layer here.
+       it will call GET_CURRENT_CALLS and determine success that way */
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+void requestHangupForegroundResumeBackground(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    // 3GPP 22.030 6.5.5
+    // "Releases all active calls (if any exist) and accepts
+    //  the other (held or waiting) call."
+    //at_send_command("AT+CHLD=1", NULL);
+    //at_send_command("AT+CHUP", NULL);
+	// <!--added by wangmengying@2020.2.21 fix bug41335,bug41239,use CT card,modify hangup AT command
+    if(((ODM_CT_OPERATOR_3G == cur_oper) || (ODM_CT_OPERATOR_4G == cur_oper)) && (mode_flag < GHT_NL668))
+	// end-->
+    {
+        at_send_command("AT+CHV", NULL);
+        if(1 == voice_handover_flag)
+        {
+            OnResumeLTENetwork();
+            voice_handover_flag = 0;
+        }
+    }
+    else
+    {
+        at_send_command("AT+CHUP", NULL);//modified by nodecom
+    }
+
+    /* success or failure is ignored by the upper layer here.
+       it will call GET_CURRENT_CALLS and determine success that way */
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+void requestHangupWaitingOrBackground(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    // 3GPP 22.030 6.5.5
+    // "Releases all held calls or sets User Determined User Busy
+    //  (UDUB) for a waiting call."
+    //at_send_command("AT+CHLD=0", NULL);
+    //at_send_command("AT+CHUP", NULL);
+	// <!--added by wangmengying@2020.2.21 fix bug41335,bug41239,use CT card,modify hangup AT command
+    if(((ODM_CT_OPERATOR_3G == cur_oper) || (ODM_CT_OPERATOR_4G == cur_oper)) && (mode_flag < GHT_NL668))
+	// end-->
+    {
+        at_send_command("AT+CHV", NULL);
+    }
+    else
+    {
+        at_send_command("AT+CHUP", NULL);//modified by nodecom
+    }
+
+    /* success or failure is ignored by the upper layer here.
+       it will call GET_CURRENT_CALLS and determine success that way */
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+void requestHangup(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    int *p_line;
+    int ret;
+    char *cmd = NULL;
+    p_line = (int *)data;
+    int i;
+
+    // 3GPP 22.030 6.5.5
+    // "Releases a specific active call X"
+    for (i = 0; i < current_call_counts; i++) {
+        if (current_calls[i].index == p_line[0]) {
+            if (current_calls[i].state == RIL_CALL_ACTIVE
+                || current_calls[i].state == RIL_CALL_HOLDING) {
+                // <!--[ODM]wangmengying@2019.9.11 bug29472,MA510-GL-xx not support Call Related Supplementary Services Command(CHLD).
+                if (GHT_MA510_GL == mode_flag)
+                {
+                    asprintf(&cmd, "AT+CHUP");
+                }
+                else
+                {
+                    asprintf(&cmd, "AT+CHLD=1%d", p_line[0]);
+                }
+                // end-->
+            } else {
+                asprintf(&cmd, "AT+CHUP");
+            }
+            break;
+        }
+    }
+    if (cmd == NULL) {
+        asprintf(&cmd, "AT+CHUP");
+    }
+
+    //ret = at_send_command(cmd, NULL);
+	// <!--added by wangmengying@2020.2.21 fix bug41335,bug41239,use CT card,modify hangup AT command
+    if(((ODM_CT_OPERATOR_3G == cur_oper) || (ODM_CT_OPERATOR_4G == cur_oper)) && (mode_flag < GHT_NL668))
+	// end-->
+    {
+        ret = at_send_command("AT+CHV", NULL);
+    }
+    else
+    {
+        //ret = at_send_command("AT+CHUP", NULL);//modified by nodecom
+        ret = at_send_command(cmd, NULL);
+    }
+
+    //#endif
+	if (cmd != NULL) {
+		free(cmd);
+	}
+    /* success or failure is ignored by the upper layer here.
+       it will call GET_CURRENT_CALLS and determine success that way */
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+}
+
+// <!--added by wangmengying@2018.8.1 for Call Waiting
+void  requestGetClir(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    /** Gets current CLIR status
+     * "data" is NULL
+     * "response" is int *
+     * ((int *)data)[0] is "n" parameter from TS 27.007 7.7
+     * ((int *)data)[1] is "m" parameter from TS 27.007 7.7
+     */
+    int err = 0;
+    int response[2] ={0};
+    ATResponse *p_response;
+    char* line = NULL;
+
+	/* BEGIN: Added by eric.li, 2018/12/22   PN:modify for issue of query cmd AT+CLIR? that  timeout in 10 seconds  */
+	RLOGD("[%s,%d],requestGetClir Timeout is [%d]ms.\r",__FUNCTION__, __LINE__, QUERY_NETWORK_TIMEOUT);
+	err = at_send_command_singleline_timeout("AT+CLIR?","+CLIR:",QUERY_NETWORK_TIMEOUT,&p_response);
+	/* END:   Added by eric.li, 2018/12/22   PN:modify for issue of query cmd AT+CLIR? that  timeout in 10 seconds  */
+	
+    if (err < 0 || p_response->success == 0)
+        goto error;
+
+    line = p_response->p_intermediates->line;
+
+    err = at_tok_start(&line);
+    if (err < 0)
+        goto error;
+
+    err = at_tok_nextint(&line, &response[0]);
+    if (err < 0)
+        goto error;
+
+    err = at_tok_nextint(&line, &response[1]);
+    if (err < 0)
+        goto error;
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, response, sizeof(response));
+    at_response_free(p_response);
+    return;
+
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+    return;
+}
+
+void  requestSetClir(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    /**
+     * "data" is int *
+     * ((int *)data)[0] is "n" parameter from TS 27.007 7.7
+     *
+     * "response" is NULL
+     */
+    int err = 0;
+    char *cmd = NULL;
+
+    asprintf(&cmd, "AT+CLIR=%d", ((int *)data)[0]);
+
+    err = at_send_command(cmd,NULL);
+    if (err < 0)
+        goto error;
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    free(cmd);
+    return;
+
+error:
+    free(cmd);
+    RIL_onRequestComplete(t, RIL_E_PASSWORD_INCORRECT, NULL, 0);
+}
+
+void requestQueryCallWaiting(void *data __unused, size_t datalen __unused, RIL_Token t)
+{
+    /**
+     * "data" is const int *
+     * ((const int *)data)[0] is the TS 27.007 service class to query.
+     * "response" is a const int *
+     * ((const int *)response)[0] is 0 for "disabled" and 1 for "enabled"
+     *
+     * If ((const int *)response)[0] is = 1, then ((const int *)response)[1]
+     * must follow, with the TS 27.007 service class bit vector of services
+     * for which call waiting is enabled.
+     *
+     * For example, if ((const int *)response)[0]  is 1 and
+     * ((const int *)response)[1] is 3, then call waiting is enabled for data
+     * and voice and disabled for everything else
+     */
+    int err;
+    int response[2] = {0};
+    char *line = NULL;
+    ATResponse *p_response = NULL;
+    ATLine *p_cur = NULL;
+    int status = 0;
+    int service = 0;
+
+    err = at_send_command_singleline_timeout("AT+CCWA=1,2", "+CCWA:", QUERY_NETWORK_TIMEOUT, &p_response);
+    if (err < 0 || p_response->success == 0)
+        goto error;
+
+    for (p_cur = p_response->p_intermediates; p_cur != NULL;p_cur = p_cur->p_next)
+    {
+        line = p_cur->line;
+        status = 0;
+        service = 0;
+
+        err = at_tok_start(&line);
+        if (err < 0)
+            goto error;
+
+        err = at_tok_nextint(&line, &status);
+        if (err < 0)
+            goto error;
+
+        if (at_tok_hasmore(&line))
+        {
+            err = at_tok_nextint(&line, &service);
+            if (err < 0) goto error;
+        }
+
+        (response[0]) = status;
+        if(1 == status) {
+            (response[1]) = (response[1]) | service;
+        }
+    };
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, response, sizeof(response));
+    at_response_free(p_response);
+    return;
+
+error:
+    RLOGD("******** requestQueryCallWaiting is failed ********");
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(p_response);
+}
+
+void requestSetCallWaiting(void *data, size_t datalen, RIL_Token t)
+{
+    /**
+     * "data" is const int *
+     * ((const int *)data)[0] is 0 for "disabled" and 1 for "enabled"
+     * ((const int *)data)[1] is the TS 27.007 service class bit vector of
+     *                           services to modify
+     * "response" is NULL
+     */
+    ATResponse *p_response = NULL;
+    int err = 0;
+    char*cmd = NULL;
+    int enable, service_class;
+
+    if((datalen < 2)||(data == NULL)) goto error;
+
+    enable = ((int *)data)[0];
+    service_class = ((int *)data)[1];
+
+    /* no class */
+    if(0 == service_class)
+    {
+        asprintf(&cmd, "AT+CCWA=0,%d", enable);
+    }
+    else
+    {
+        asprintf(&cmd, "AT+CCWA=0,%d,%d", enable, service_class);
+    }
+    err = at_send_command_timeout(cmd,&p_response,TIME_OUT_CGACT); //wait long timeout
+    if (err < 0 || p_response->success == 0)
+        goto error;
+
+    RIL_onRequestComplete(t,RIL_E_SUCCESS,NULL,0);
+    at_response_free(p_response);
+    free(cmd);
+    return ;
+
+error:
+    free(cmd);
+    RIL_onRequestComplete(t,RIL_E_GENERIC_FAILURE,NULL,0);
+    at_response_free(p_response);
+}
+// end--!>
+
+// <!--added by wangmengying@2018.8.1 for Call Forwarding Number and Conditions
+void requestSetCallForward(void *data, RIL_Token t)
+{
+    int err = 0;
+    char *cmd;
+    RIL_CallForwardInfo *info = NULL;
+    ATResponse *atResponse = NULL;
+
+    info = ((RIL_CallForwardInfo *) data);
+
+    if(data == NULL)
+        goto error;
+    RLOGD("info->reason[%d] info->status[%d] info->number[%s]",info->reason,info->status,info->number);
+//added for info->number == NULL, return error 20181217;
+    if(info->number==NULL)
+    {
+        goto error;
+    }
+	
+    if(0 == info->status)
+    {
+        asprintf(&cmd,"AT+CCFC = %d,%d",info->reason, info->status);
+    }
+    else
+    {
+        if('+' == info->number[0])
+        {
+            info->toa = 145;
+        }
+        else
+        {
+            info->toa = 129;
+        }
+        if ( 0 == info->serviceClass ) {
+            asprintf(&cmd,"AT+CCFC = %d,%d,\"%s\",%d",
+                    info->reason, info->status,
+                    info->number, info->toa);
+        } else {
+            asprintf(&cmd,"AT+CCFC = %d,%d,\"%s\",%d,%d",
+                    info->reason, info->status,
+                    info->number, info->toa, info->serviceClass);
+        }
+    }
+
+    err = at_send_command_timeout(cmd,&atResponse,TIME_OUT_CGACT); //wait long timeout
+    free(cmd);
+    if (err < 0 || atResponse->success == 0)
+        goto error;
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
+    at_response_free(atResponse);
+    return;
+
+error:
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+    at_response_free(atResponse);
+}
+
+void requestQueryCallForwardStatus(void *data, RIL_Token t)
+{
+    int err = 0;
+    int i = 0;
+    int n = 0;
+    int tmp = 0;
+    ATResponse *atResponse = NULL;
+    ATLine *p_cur;
+    RIL_CallForwardInfo **responses = NULL;
+    char *tmp_char = NULL;
+    RIL_CallForwardInfo *info = NULL;
+    info = ((RIL_CallForwardInfo *) data);
+
+    char *cmd = NULL;
+
+    asprintf(&cmd, "AT+CCFC=%d,2", info->reason);
+
+    err = at_send_command_singleline_timeout(cmd, "+CCFC:", QUERY_NETWORK_TIMEOUT, &atResponse);
+    free(cmd);
+
+    if (err < 0 || atResponse->success == 0)
+        goto error;
+
+    for (p_cur = atResponse->p_intermediates; p_cur != NULL; p_cur = p_cur->p_next)
+        n++;
+
+    responses = (RIL_CallForwardInfo **) alloca(n * sizeof(RIL_CallForwardInfo *));
+
+    for (i = 0; i < n; i++) {
+        responses[i] = (RIL_CallForwardInfo*)alloca(sizeof(RIL_CallForwardInfo));
+        responses[i]->status = 0;
+        responses[i]->reason = 0;
+        responses[i]->serviceClass = 0;
+        responses[i]->toa = 0;
+        responses[i]->number = (char*)"";
+        responses[i]->timeSeconds = 0;
+    }
+
+    for (i = 0,p_cur = atResponse->p_intermediates; p_cur != NULL; p_cur = p_cur->p_next, i++) {
+        char *line = p_cur->line;
+
+        err = at_tok_start(&line);
+        if (err < 0) goto error;
+
+        err = at_tok_nextint(&line, &(responses[i]->status));
+        if (err < 0) goto error;
+
+        err = at_tok_nextint(&line, &(responses[i]->serviceClass));
+        if (err < 0) goto error;
+
+        if(!at_tok_hasmore(&line)) continue;
+
+        err = at_tok_nextstr(&line, &(responses[i]->number));
+        //if (err < 0) goto error;
+
+        if(!at_tok_hasmore(&line)) continue;
+
+        err = at_tok_nextint(&line, &(responses[i]->toa));
+        //if (err < 0) goto error;
+
+        if(!at_tok_hasmore(&line)) continue;
+        //at_tok_nextint(&line,&tmp);
+        at_tok_nextstr(&line, &tmp_char);
+
+        if(!at_tok_hasmore(&line)) continue;
+        at_tok_nextint(&line,&tmp);
+
+        if(!at_tok_hasmore(&line)) continue;
+        err = at_tok_nextint(&line, &(responses[i]->timeSeconds));
+        //if (err < 0) goto error;
+
+    }
+
+    RIL_onRequestComplete(t, RIL_E_SUCCESS, responses, n*sizeof(RIL_CallForwardInfo **));
+    at_response_free(atResponse);
+
+    return;
+
+error:
+    at_response_free(atResponse);
+    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
+}
+// end--!>
diff --git a/hardware/ril/youyou_ril/voice.h b/hardware/ril/youyou_ril/voice.h
new file mode 100755
index 0000000..2deecde
--- /dev/null
+++ b/hardware/ril/youyou_ril/voice.h
@@ -0,0 +1,46 @@
+#ifndef _VOICE_H_
+#define _VOICE_H_
+
+/*when who why modified*/
+
+void requestGetCurrentCalls(void *data, size_t datalen, RIL_Token t);
+
+void requestDial(void *data, size_t datalen, RIL_Token t);
+
+void requestGetMute(void *data, size_t datalen, RIL_Token t);
+
+void requestDTMFStart(void *data, size_t datalen, RIL_Token t);
+
+void requestDTMFStop(void *data, size_t datalen, RIL_Token t);
+
+void requestDTMF(void *data, size_t datalen, RIL_Token t);
+
+void requestSeparateConnection(void *data, size_t datalen, RIL_Token t);
+
+void requestUDUB(void *data, size_t datalen, RIL_Token t);
+
+void requestConference(void *data, size_t datalen, RIL_Token t);
+
+void requestAnswer(void *data, size_t datalen, RIL_Token t);
+
+void requestSwitchWaitingOrHoldingAndActive(void *data, size_t datalen, RIL_Token t);
+
+void requestHangupForegroundResumeBackground(void *data, size_t datalen, RIL_Token t);
+
+void requestHangupWaitingOrBackground(void *data, size_t datalen, RIL_Token t);
+
+void requestHangup(void *data, size_t datalen, RIL_Token t);
+
+void  requestGetClir(void *data, size_t datalen, RIL_Token t);  
+
+void  requestSetClir(void *data, size_t datalen, RIL_Token t);  
+// <!--added by wangmengying@2018.8.1 for Call Forwarding Number and Conditions
+void requestSetCallForward(void *data, RIL_Token t);
+
+void requestQueryCallForwardStatus(void *data, RIL_Token t);
+// end--!>
+void requestQueryCallWaiting(void *data, size_t datalen, RIL_Token t);
+
+void requestSetCallWaiting(void *data, size_t datalen, RIL_Token t);
+
+#endif /*_VOICE_H_*/
diff --git a/kernel4.14/arch/arm64/boot/dts/sprd/ud710-2h10.dts b/kernel4.14/arch/arm64/boot/dts/sprd/ud710-2h10.dts
index 7d6307d..43679b8 100755
--- a/kernel4.14/arch/arm64/boot/dts/sprd/ud710-2h10.dts
+++ b/kernel4.14/arch/arm64/boot/dts/sprd/ud710-2h10.dts
@@ -42,7 +42,7 @@
 
 	chosen {
 		stdout-path = &uart1;
-		bootargs = "earlycon=sprd_serial,0x70100000,115200n8 console=ttyS1,115200n8 loglevel=1 init=/init root=/dev/mmcblk0p30 rootfstype=ext4 ro rootwait androidboot.hardware=ud710_2h10 androidboot.dtbo_idx=0 printk.devkmsg=on pcie_ports=compat";
+		bootargs = "earlycon=sprd_serial,0x70100000,115200n8 console=ttyS1,115200n8 loglevel=7 init=/init root=/dev/mmcblk0p30 rootfstype=ext4 ro rootwait androidboot.hardware=ud710_2h10 androidboot.dtbo_idx=0 printk.devkmsg=on pcie_ports=compat";
 	};
 
 	ipi: interrupt-controller {
@@ -747,8 +747,8 @@
 };
 
 &usb3 {
-	extcon = <&extcon_gpio>, <&pmic_typec>;
-	vbus-supply = <&vddvbus>;
+//	extcon = <&extcon_gpio>, <&pmic_typec>;
+//	vbus-supply = <&vddvbus>;
 	status = "okay";
 };
 
diff --git a/kernel4.14/arch/arm64/configs/sprd_roc1_defconfig b/kernel4.14/arch/arm64/configs/sprd_roc1_defconfig
index e907eaf..45af791 100755
--- a/kernel4.14/arch/arm64/configs/sprd_roc1_defconfig
+++ b/kernel4.14/arch/arm64/configs/sprd_roc1_defconfig
@@ -1549,7 +1549,7 @@ CONFIG_MDIO_BUS=y
 # CONFIG_MDIO_HISI_FEMAC is not set
 # CONFIG_MDIO_OCTEON is not set
 # CONFIG_MDIO_THUNDER is not set
-CONFIG_R8168=y
+# CONFIG_R8168 is not set
 CONFIG_PHYLIB=y
 CONFIG_SWPHY=y
 # CONFIG_LED_TRIGGER_PHY is not set
@@ -1601,7 +1601,7 @@ CONFIG_PPP_ASYNC=y
 # CONFIG_PPP_SYNC_TTY is not set
 # CONFIG_SLIP is not set
 CONFIG_SLHC=y
-# CONFIG_USB_NET_DRIVERS is not set
+CONFIG_USB_NET_DRIVERS=y
 CONFIG_WLAN=y
 # CONFIG_WIRELESS_WDS is not set
 # CONFIG_WLAN_VENDOR_ADMTEK is not set
@@ -3078,7 +3078,7 @@ CONFIG_USB_SERIAL=y
 # CONFIG_USB_SERIAL_TI is not set
 # CONFIG_USB_SERIAL_CYBERJACK is not set
 # CONFIG_USB_SERIAL_XIRCOM is not set
-# CONFIG_USB_SERIAL_OPTION is not set
+CONFIG_USB_SERIAL_OPTION=y
 # CONFIG_USB_SERIAL_OMNINET is not set
 # CONFIG_USB_SERIAL_OPTICON is not set
 # CONFIG_USB_SERIAL_XSENS_MT is not set
@@ -3087,7 +3087,8 @@ CONFIG_USB_SERIAL=y
 # CONFIG_USB_SERIAL_QT2 is not set
 # CONFIG_USB_SERIAL_UPD78F0730 is not set
 # CONFIG_USB_SERIAL_DEBUG is not set
-
+# CONFIG_USB_NET_CDCETHER is not set
+CONFIG_USB_USBNET=y
 #
 # USB Miscellaneous drivers
 #
diff --git a/kernel4.14/drivers/usb/dwc3/dwc3-sprd.c b/kernel4.14/drivers/usb/dwc3/dwc3-sprd.c
old mode 100644
new mode 100755
index cad2f83..9288b98
--- a/kernel4.14/drivers/usb/dwc3/dwc3-sprd.c
+++ b/kernel4.14/drivers/usb/dwc3/dwc3-sprd.c
@@ -172,6 +172,67 @@ static ssize_t u1u2_enable_store(struct device *dev,
 }
 static DEVICE_ATTR_RW(u1u2_enable);
 
+//add stephen  ++
+static ssize_t usb_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct dwc3_sprd *sdwc = dev_get_drvdata(dev);
+	struct dwc3 *dwc;
+
+	if (!sdwc)
+		return -EINVAL;
+
+	dwc = platform_get_drvdata(sdwc->dwc3);
+	if (!dwc)
+		return -EINVAL;
+
+	
+	return sprintf(buf, sdwc->dr_mode == USB_DR_MODE_PERIPHERAL ? "DEVICE" : "HOST");
+}
+
+static ssize_t usb_mode_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t size)
+{
+	struct dwc3_sprd *sdwc = dev_get_drvdata(dev);
+	struct dwc3 *dwc;
+	unsigned long flags;
+	enum usb_dr_mode mode = USB_DR_MODE_UNKNOWN;
+	spin_lock_irqsave(&sdwc->lock, flags);
+	if (!sdwc)
+		return -EINVAL;
+
+	dwc = platform_get_drvdata(sdwc->dwc3);
+	if (!dwc)
+		return -EINVAL;
+
+	if (!strncmp(buf, "host", 4)){
+		
+		__pm_stay_awake(&sdwc->wake_lock);
+
+		sdwc->vbus_active = true;
+		sdwc->wq_mode = USB_DR_MODE_HOST;
+		mode = sdwc->wq_mode;
+		queue_work(system_unbound_wq, &sdwc->work);
+	}
+	else if (!strncmp(buf, "device", 6)){
+		
+		__pm_stay_awake(&sdwc->wake_lock);
+		sdwc->vbus_active = true;
+		sdwc->wq_mode = USB_DR_MODE_PERIPHERAL;
+		mode = sdwc->wq_mode;
+		queue_work(system_unbound_wq, &sdwc->work);
+	}
+	else
+		return -EINVAL;
+
+	spin_unlock_irqrestore(&sdwc->lock, flags);
+	return size;
+}
+static DEVICE_ATTR_RW(usb_mode);
+
+//add  stephen  --
+
 static ssize_t current_speed_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
@@ -190,6 +251,7 @@ static ssize_t current_speed_show(struct device *dev,
 static DEVICE_ATTR_RO(current_speed);
 
 static struct attribute *dwc3_sprd_attrs[] = {
+	&dev_attr_usb_mode.attr,
 	&dev_attr_u1u2_enable.attr,
 	&dev_attr_maximum_speed.attr,
 	&dev_attr_current_speed.attr,
@@ -468,6 +530,7 @@ static void dwc3_sprd_hot_plug(struct dwc3_sprd *sdwc)
 	sdwc->wq_mode = USB_DR_MODE_UNKNOWN;
 	spin_unlock_irqrestore(&sdwc->lock, flags);
 
+	pr_err("stephen in dwc3_sprd_hot_plug current_mode:%d\n",current_mode);
 	if (current_state) {
 		spin_lock_irqsave(&sdwc->lock, flags);
 		if (sdwc->block_active) {
@@ -534,7 +597,7 @@ static void dwc3_sprd_hot_plug(struct dwc3_sprd *sdwc)
 static void dwc3_sprd_notifier_work(struct work_struct *work)
 {
 	struct dwc3_sprd *sdwc = container_of(work, struct dwc3_sprd, work);
-
+	pr_err("stephen to dwc3_sprd_notifier_work sdwc->dr_mode:%d\n",sdwc->dr_mode);
 	dwc3_sprd_hot_plug(sdwc);
 }
 
@@ -736,7 +799,7 @@ static int dwc3_sprd_probe(struct platform_device *pdev)
 	int ret;
 
 	dev_info(&pdev->dev, "[%s]enter\n", __func__);
-
+	pr_err("stephen in dwc3_sprd_probe\n");
 	if (!node) {
 		dev_err(dev, "can not find device node\n");
 		return -ENODEV;
@@ -864,7 +927,7 @@ static int dwc3_sprd_probe(struct platform_device *pdev)
 	/* get vbus/id gpios extcon device */
 	if (of_property_read_bool(node, "extcon")) {
 		struct device_node *extcon_node;
-
+		pr_err("stephen  we have usb dw3 extcon\n");
 		sdwc->edev = extcon_get_edev_by_phandle(sdwc->dev, 0);
 		if (IS_ERR(sdwc->edev)) {
 			dev_err(dev, "failed to find vbus extcon device.\n");
@@ -911,19 +974,25 @@ static int dwc3_sprd_probe(struct platform_device *pdev)
 		 * In some cases, FPGA, USB Core and PHY may be always powered
 		 * on.
 		 */
+		pr_err("stephen  we have no  usb dw3 extcon set vbus_active\n");
 		sdwc->vbus_active = true;
 
 		if (boot_calibration) {
 			sdwc->dr_mode = USB_DR_MODE_PERIPHERAL;
 		} else {
 			if (IS_ENABLED(CONFIG_USB_DWC3_HOST) ||
-			    IS_ENABLED(CONFIG_USB_DWC3_DUAL_ROLE))
+			    IS_ENABLED(CONFIG_USB_DWC3_DUAL_ROLE)){
 				sdwc->dr_mode = USB_DR_MODE_HOST;
-			else
+				sdwc->wq_mode = sdwc->dr_mode; //add  stephen
+				pr_err("stephen  dr_mode USB_DR_MODE_HOST\n");
+			}
+			else{
+				pr_err("stephen  dr_mode USB_DR_MODE_PERIPHERAL\n");
 				sdwc->dr_mode = USB_DR_MODE_PERIPHERAL;
+			}
 		}
 
-		dev_info(dev, "DWC3 is always running as %s\n",
+		dev_info(dev, "stephen DWC3 is always running as %s\n",
 			 sdwc->dr_mode == USB_DR_MODE_PERIPHERAL ? "DEVICE" : "HOST");
 	}
 
@@ -946,13 +1015,19 @@ static int dwc3_sprd_probe(struct platform_device *pdev)
 	pm_runtime_set_active(dev);
 	pm_runtime_enable(dev);
 
-	if (of_property_read_bool(node, "extcon"))
+	if (of_property_read_bool(node, "extcon")){
+		pr_err("stephen have extcon to dwc3_sprd_detect_cable\n");
 		dwc3_sprd_detect_cable(sdwc);
-	else
+	}
+	else{
+		pr_err("stephen  no extcon to system_unbound_wq\n");
+		pr_err("stephen sdwc->dr_mode:%d",sdwc->dr_mode);
 		queue_work(system_unbound_wq, &sdwc->work);
+	}
 
 	dev_info(&pdev->dev, "[%s]end\n", __func__);
 
+	pr_err("stephen  dwc3_sprd_probe ok\n");
 	return 0;
 
 err_extcon_id:
diff --git a/kernel4.14/drivers/usb/serial/option.c b/kernel4.14/drivers/usb/serial/option.c
old mode 100644
new mode 100755
index 8cdca3f..a635041
--- a/kernel4.14/drivers/usb/serial/option.c
+++ b/kernel4.14/drivers/usb/serial/option.c
@@ -50,6 +50,28 @@ static int option_attach(struct usb_serial *serial);
 static void option_release(struct usb_serial *serial);
 static void option_instat_callback(struct urb *urb);
 
+//add  stephen ++
+
+/* Fibocom products */
+#define FIBOCOM_VENDOR_ID 0x2cb7
+#define FIBOCOM_PRODUCT_L71X 0x0001
+
+#define FIBOCOM_USB_VENDOR_AND_INTERFACE_INFO(vend, cl, sc, pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
+	| USB_DEVICE_ID_MATCH_VENDOR, \
+	.idVendor = (vend), \
+	.bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), \
+	.bInterfaceProtocol = (pr)
+	
+/*
+{ FIBOCOM_USB_VENDOR_AND_INTERFACE_INFO(FIBOCOM_VENDOR_ID, 0xff, 0xff, 0xff) },
+{ FIBOCOM_USB_VENDOR_AND_INTERFACE_INFO(FIBOCOM_VENDOR_ID, 0x0a, 0x00, 0xff) },
+{ USB_DEVICE_AND_INTERFACE_INFO(0x19d2, 0x0256, 0xff, 0xff, 0xff) },
+{ USB_DEVICE_AND_INTERFACE_INFO(0x19d2, 0x0579, 0xff, 0xff, 0xff) },
+*/
+//add  stephen  --
+
 /* Vendor and product IDs */
 #define OPTION_VENDOR_ID			0x0AF0
 #define OPTION_PRODUCT_COLT			0x5000
@@ -569,6 +591,7 @@ static void option_instat_callback(struct urb *urb);
 
 
 static const struct usb_device_id option_ids[] = {
+	{ USB_DEVICE(0x2cb7, 0x0001) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA_LIGHT) },
diff --git a/kernel4.14/drivers/usb/serial/usb_wwan.c b/kernel4.14/drivers/usb/serial/usb_wwan.c
old mode 100644
new mode 100755
index 59bfcb3..59024b3
--- a/kernel4.14/drivers/usb/serial/usb_wwan.c
+++ b/kernel4.14/drivers/usb/serial/usb_wwan.c
@@ -36,6 +36,11 @@
 #include <linux/serial.h>
 #include "usb-wwan.h"
 
+//add  stephen ++
+#define FIBOCOM_BCDUSB 0x0100
+#define FIBOCOM_VENDOR_ID 0x2cb7
+//add  stephen  --
+
 /*
  * Generate DTR/RTS signals on the port using the SET_CONTROL_LINE_STATE request
  * in CDC ACM.
diff --git a/packages/apps/Settings/src/com/android/settings/SettingsActivity.java b/packages/apps/Settings/src/com/android/settings/SettingsActivity.java
old mode 100644
new mode 100755
index 00cf069..38880e2
--- a/packages/apps/Settings/src/com/android/settings/SettingsActivity.java
+++ b/packages/apps/Settings/src/com/android/settings/SettingsActivity.java
@@ -641,11 +641,12 @@ public class SettingsActivity extends SettingsDrawerActivity
         final StringBuilder changedList = new StringBuilder();
         somethingChanged = setTileEnabled(changedList,
                 new ComponentName(packageName, WifiSettingsActivity.class.getName()),
-                pm.hasSystemFeature(PackageManager.FEATURE_WIFI), isAdmin) || somethingChanged;
+                pm.hasSystemFeature(PackageManager.FEATURE_WIFI) && false, isAdmin) || somethingChanged;
 
         somethingChanged = setTileEnabled(changedList, new ComponentName(packageName,
                         Settings.BluetoothSettingsActivity.class.getName()),
-                pm.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH), isAdmin)
+                        //pm.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH), isAdmin)
+                (pm.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)  && false), isAdmin)
                 || somethingChanged;
 
 
@@ -715,7 +716,7 @@ public class SettingsActivity extends SettingsDrawerActivity
 
         somethingChanged = setTileEnabled(changedList, new ComponentName(packageName,
                         Settings.WifiDisplaySettingsActivity.class.getName()),
-                WifiDisplaySettings.isAvailable(this), isAdmin)
+                WifiDisplaySettings.isAvailable(this) && false, isAdmin)
                 || somethingChanged;
 
         // Enable/disable the Me Card page.
